<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>program filter</TITLE>
<link rel="stylesheet" type="text/css" href="../doc/html/doc.css" />
<link href="../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>PROGRAM <em class=program>filter</em></H1>

<table border=0 summary="dart header" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Modules">MODULES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>
   Main program for driving ensemble filter assimilations. 
</P>
<P>
   <em class=program>filter</em> is a Fortran 90 program, and provides a large
   number of options for controlling execution behavior and parameter configuration
   that are driven from its namelist. 
   See the <a href=#Namelist>namelist</a> section below for more details.
   The number of assimilation steps to be done 
   is controlled by the input observation sequence and by the 
   time-stepping capabilities of the model being used in the assimilation.
</P><P>
   This overview includes these subsections:
</P>
<UL><LI> <A href="#ProgramFlow">Program Flow</A> </LI>
    <LI> <A href="#FilterTypes">Filter Types</A> </LI>
    <LI> <A href="#GettingStarted">Getting Started</A> </LI>
    <LI> <A href="#FreeRun">Free Model Run after Assimilation</A> </LI>
    <LI> <A href="#EvalOnly">Evaluate a Model State against Observations</A> </LI>
    <LI> <A href="#Verify">Compare Results with and without Assimilation</A> </LI>
    <LI> <A href="#QCVals">DART Quality Control Values on Output</A> </LI>
    <LI> <A href="#Inflation">Description of Inflation Options</A> </LI>
    <LI> <A href="#DetailedProgramFlow">Detailed Program Flow</A> </LI>
</UL>
<P>
   See the <A href="http://www.image.ucar.edu/DAReS/DART">DART web site</A> 
   for more documentation, including a discussion of the capabilities of the
   assimilation system, a diagram of the entire execution cycle, the options
   and features.
</P>


<A NAME="ProgramFlow"></A>
<H4>Overview of Program Flow</H4>
<P>
   The basic execution loop is:
</P>
<UL><LI>Read in model initial conditions, observations, set up and initialize</LI>
    <LI>Until out of observations:
    <UL><LI>Run multiple copies of the model to get forecasts of model state</LI>
        <LI>Assimilate all observations in the current time window</LI>
        <LI>Repeat</LI>
    </UL></LI>
    <LI>Write out diagnostic files, restart files, 
        final observation sequence file</LI>
</UL>
<P>
The time of the observations in the input observation sequence file
controls the length of execution of filter.
</P> 
<P>
For large, parallel models, the execution loop is usually
wrapped in an external script which does these additional steps:
</P>
<UL><LI>Link to an observation sequence file which contains only observation times
        within the next assimilation window </LI>
    <LI>Convert the latest model output files to DART format</LI>
    <LI>Link any output inflation files from the previous step to be
        the input files for this step</LI>
    <LI>Run filter, which will exit after doing the assimilation without trying
        to advance the model</LI>
    <LI>Convert the filter output to be model input</LI>
    <LI>Save the output diagnostic files for later</LI>
    <LI>Advance the N copies of the model using the model scripts or whatever
        method is appropriate</LI>
    <LI>Repeat until all data is assimilated</LI>
</UL>
<P>
For large models filter is almost always compiled to be a parallel MPI
program, and most large models are themselves a parallel program using
OpenMP, MPI, or both.  MPI programs usually cannot start other MPI programs,
so the external script submits both the filter job and the N model advances
to a batch system so all run as independent parallel jobs.
</P>
<P>
   The same source code is used for all applications of filter.
   The code specific to the types of observations and the interface code
   for the computational model is configured at compile time.
   The DART directory structure is arranged slightly differently than usual
   in that the main code is spread across a dozen directories
   at the top level, e.g. the filter source code is in DART/filter/filter.f90.
   Each model has a separate directory under DART/models, and under each model
   is a work directory where the code is compiled and can be run for testing.
   Generally when a full-size experiment is done the executables are copied
   to a different location - e.g. scratch space on a large filesystem - since the
   data files for 10s to 100s of copies of a model can get very large.
</P>

<A NAME="FilterTypes"></A>
<H4>Types of Filters available</H4>
<P>
   The different types of assimilation algorithms 
   (EAKF, ENKF, Kernel filter, Particle filter, etc.) are determined
   by the <em class=code>&amp;assim_tools_nml:filter_kind</em> entry,
   described in <a href="../assim_tools/assim_tools_mod.html">assim_tools_mod.html</a>.
   Despite having 'filter' in the name, they are assimilation algorithms
   and so are implemented in <em class=file>assim_tools_mod.f90</em>.
</P>

<A NAME="GettingStarted"></A>
<H4>Getting Started</H4>
<P>
Running a successful assimilation takes careful diagnostic work 
and experiment iterations to find the best settings for your 
specific case.  The basic
Kalman filter can be coded in only a handful of lines; the hard work is 
making the right choices to compensate for sampling errors,
model bias, observation error, lack of model divergence, variations
in observation density in space and time, random correlations, etc.  
There are tools built into DART to deal with most of these problems
but it takes careful work to apply them correctly.
</P> <P>
If you are adding a new model or a new observation type, we suggest
you assimilate exactly one observation, with no model advance, 
with inflation turned off, with a large cutoff, and with the 
outlier threshold off (see below for how to set these namelist 
items).  Run an assimilation.  Look at the obs_seq.final file
to see what the forward operator computed.  Use ncdiff to difference
the Prior and Posterior Diag NetCDF files and look at the changes
(the "innovations") in the various model fields.  Is it in the right
location for that observation?  Does it have a reasonable value?
</P> <P>
Then assimilate a group of observations and check the results 
carefully. Run the observation diagnostics and look at the total
error and spread.  Look carefully at the number of observations
being assimilated compared to how many are available.  Assimilations
that are not working can give good looking statistics if they reject
all but the few observations that happen to match the current state.
The errors should grow as the model advances and then shrink when
new observations are assimilated, so a time-plot of the RMSE
should show a sawtooth pattern.  The initial error might be large
but it should decrease and then reach a roughly stable level.
The spread should remain constant, at a value around the expected 
observation error level.
If the spread is too small that is ok for the baseline case; 
several of the DART facilities described below are intended to 
compensate for ensemble members getting too close to each other.
Once you believe you have a working assimilation case, this
will be your baseline case.
Then one by one enable or tune each of the items below, checking 
each time to see what is the effect on the results.
</P> <P>
Suggestions for the most common namelist settings and features built
into DART for running a successful assimilation include:
</P>
<ul>
<li>Ensemble Size
<P>
In practice, ensemble sizes between 20 and 100 seem to work best.  
Fewer than 20-30 members leads to statistical errors which are too large.
More than
100 members takes longer to run with very little return, and eventually
the results get worse again.  Often the limit on the number of members
is based on the size of the model since you have to run N copies
of the model each time you move forward in time.  If you can,
start with 50-60 members and then experiment with fewer or more
once you have a set of baseline results to compare it with.
The namelist setting for ensemble size is
<em class="code">&amp;filter_nml :: ens_size </em>
</P></li>
<li>Localization
<P>
There are two main advantages to using localization.  One is it avoids
an observation impacting unrelated state variables because of spurious
corelations.  The other is that especially for large models it improves
run-time performance because only points within the localization
radius need to be considered.  Because of the way the parallelization
was implemented in DART, localization was easy to add and
using it usually results in a very large performance gain. 
See <a href="../assim_tools/assim_tools_mod.html#Localization">here</a>
for a discussion of localization-related namelist items.
</P></li>
<li>Inflation
<P>
Since the filter is being run with a fixed number of ensembles
which is usually small compared to the number of degrees of freedom
of the model (i.e. the size of the state vector), the tendency
is for all the ensemble members to collapse towards a single solution.
Inflation increases the spread of the members in a systematic way
to avoid problems of collapse.  There are several sophisticated
options on inflation, including spatial and temporal adaptive
and damping options, which help deal with observations which
vary in density over time and location.
See <a href="#Inflation">here</a>
for a discussion of inflation-related namelist items.
</P></li>
<li>Outlier Rejection
<P>
Outlier rejection can be used to avoid bad observations (ones
where the value was recorded in error or the processing has an
error and a non-physical value was generated).  It also avoids
observations which have accurate values but the mean of the
ensemble members is so far from the observation value that
assimilating it would result in unacceptably large increments
that might destablize the model run.  If the difference between
the observation and the prior ensemble mean is more than N standard
deviations from the square root of the sum of the 
prior ensemble and observation error variance, the observation will
be rejected.
The namelist setting for the number of standard deviations
to include is
<em class="code">&amp;filter_nml :: outlier_threshold </em>
and we typically suggest starting with a value of 3.0.
</P></li>
<li>Sampling Error
<P>
For small ensemble sizes a table of expected statistical error 
distributions can be generated before running DART.  Corrections
accounting for these errors are applied during the assimilation 
to increase the ensemble
spread which can improve the assimilation results.  
The namelist item to enable this option is 
<em class="code">&amp;assim_tools_nml :: sampling_error_correction</em>.
Additionally you will need to have a 
precomputed correction file <em class="file">final_full.X</em>,
where X matches your ensemble size, in the run directory.
See the description of the namelist item in the
<a href="../assim_tools/assim_tools_mod.html#Namelist">
&amp;assim_tools_nml</a> namelist, and 
<a href="../system_simulation/system_simulation.html">look here</a>
for instructions on where to find (or how to generate) 
the auxiliary file needed by this code.
See Anderson (2011).
</P></li>
</ul>


<A NAME="FreeRun"></A>
<H4>Free run/Forecast After Assimilation</H4>
<P>
   Separate scripting can be done to support forecasts starting from the
   analyzed model states.  After filter exits, the models can be
   run freely (with no assimilated data) further forward in time
   using one or more of the last updated model states from filter.
   Since all ensemble members are equally likely a member can be
   selected at random, or a member close to the mean can be chosen.
   See the <a href="../utilities/closest_member_tool.html">closest_member_tool</a>
   for one way to select a "close" member.  The ensemble mean is available to
   be used, but since it is a combination of all the member states it
   may not have self-consistent features, so using a single member is
   usually preferred.
</P>

<A NAME="EvalOnly"></A>
<H4>Evaluating Observations Without Assimilation</H4>
<P>
   Filter can be used
   to evaluate the accuracy of a single model state based on a set of
   available observations. 
   Convert the model data
   into a single DART state vector, and either copy or link it so there
   appear to be 2 separate ensemble members (which are identical).
   Set the filter namelist ensemble size to 2
   by setting 
   <em class="code">ens_size</em> to 2 in the
   &amp;filter_nml namelist.
   Turn off the outlier threshold and both Prior and Posterior inflation
   by setting 
   <em class="code">outlier_threshold</em> to -1, and
   both the <em class="code">inf_flavor</em> values to 0 in the
   same &amp;filter_nml namelist.
   Set all observation types to be 'evaluate-only' and have no types
   in the 'assimilate' list by listing all types in the
   <em class="code">evaluate_these_obs_types</em>
   list in the <em class="code">&amp;obs_kind_nml</em>
   section of the namelist, and none in the assimilation list.  
   Run filter as usual, including model advances if needed.
   Run observation diagnostics on the resulting obs_seq.final file to
   compute the difference between the observed values and the
   predicted values from this model state.
</P>

<A NAME="Verify"></A>
<H4>Verification/Comparison With and Without Assimilation</H4>
<P>
   To compare results of an experiment with and without assimilating data, 
   do one run assimilating the observations.  Then do a second run where
   all the observation types are moved to the 
   <em class="code">evaluate_these_obs_types</em>
   list in the <em class="code">&amp;obs_kind_nml</em>
   section of the namelist.  Also turn inflation off by setting both 
   <em class="code">inf_flavor</em> values to 0 in the &amp;filter_nml namelist.  
   The forward operators will still be called, but they will have no
   impact on the model state.  Then the two sets of diagnostic state space
   netcdf files can be compared to evaluate the impact of assimilating 
   the observations, and the observation diagnostic files can also be compared.
</P>

<A NAME="QCVals"></A>
<H4>DART Quality Control Flag added to Output Observation Sequence File</H4>
<P>
   The filter adds a quality control field with metadata 'DART quality control'
   to the obs_seq.final file. At present, this field can have the following
   values:
</P>

<TABLE border=0 cellpadding=3 width=100% summary='dart quality control flags'>
   <TR><TD>0:</TD><TD> Observation was assimilated successfully </TD></TR>
   <TR><TD>1:</TD><TD> Observation was evaluated only but not
      used in the assimilation </TD></TR>
   <TR><TD>2:</TD><TD> The observation was used but one or more of
      the posterior forward observation operators failed </TD></TR>
   <TR><TD>3:</TD><TD> The observation
      was evaluated only but not used AND one or more of the posterior 
      forward observation operators failed </TD></TR>
   <TR><TD>4:</TD><TD> One or more prior forward observation
      operators failed so the observation was not used </TD></TR>
   <TR><TD>5:</TD><TD> The observation was
      not used because it was not selected in the namelist to be assimilated
      or evaluated </TD></TR>
   <TR><TD>6:</TD><TD> The prior quality control value was too high so the
      observation was not used.  </TD></TR>
   <TR><TD>7:</TD><TD> Outlier test failed (see below)</TR>
</TABLE>

<P>
   The outlier test computes the difference between the observation value
   and the prior ensemble mean.  It then computes a standard deviation by
   taking the square root of the sum of the observation error variance and
   the prior ensemble variance for the observation.  If the difference
   between the ensemble mean and the observation value is more than the
   specified number of standard deviations, then the observation is not
   used and the DART quality control field is set to 7.
</P>

<A NAME="Inflation"></A>
<H4>Discussion of Inflation Options</H4>
<P>
There are two choices for the basic type of inflation:
observation space or state space.  Almost all users use state
space inflation and the rest of this discussion applies
to this type.  (If you are interested in observation
space inflation, talk to Jeff first.)
</P> <P>
State space inflation changes the spread of a set of ensemble members
without changing the mean value.  The algorithm computes the mean 
and standard deviation for each variable in the state vector 
in turn, and then moves the values away from the mean in such a 
way that the mean remains unchanged. The resulting standard deviation
is (generally) larger than before.  It can be applied to the
Prior state, before observations are assimilated (the most
frequently used case), or it can be applied to the Posterior
state, after assimilation.  See Anderson (2007), Anderson (2009).
</P> <P>
Inflation can be a single value applied to all
state space variables over all times.  It can 
be a single value per state space variable, constant
in time.  And finally, it can vary with time, adapting
to different densities of observations in time and space.
To enable state space inflation, see the <em>inf_flavor</em>
namelist options below.
To allow the values to adapt through time in each 
assimilation window see the <em>inf_sd_initial</em> description.
See the <em>inf_xxx_from_restart</em> options to set
a value in the namelist versus reading in the initial values
from a file.
There are additional options to damp inflation through time. 
In regions
where the density of observations varies in time the damping
slowly lowers the inflation values in the absence of new
observations at those locations.
In practice with large geophysical models using damped
inflation has been a successful strategy.
See the section describing <em>inf_damping</em>.
</P> <P>
The following namelist items related to inflation
are all found in the <em class=file>input.nml</em> file,
in the &amp;filter_nml namelist. 
The detailed descriptions are in the
<a href="#Namelist">namelist</a> section below.
Here we try to give some basic advice about
commonly used values and suggestions for
where to start.
In the namelist each entry has
two values.  The first is for Prior inflation
and the second is for Posterior inflation.
If <em>inf_flavor</em> is 0, all other settings for that
column are ignored.
</P>
<dl>
<dt>
<em>&amp;filter_nml :: inf_flavor</em><br />
valid values: 0, 1, 2, 3
<dd>
Set the type of Prior and Posterior inflation applied
to the state vector.  Values mean:
<table border=0 cellpadding=3 width=100% summary='types of inflation'>
   <tr><td>0:</td><td> No inflation </td></tr>
   <tr><td>1:</td><td> Observation space inflation </td></tr>
   <tr><td>2:</td><td> Spatially-varying state space inflation </td></tr>
   <tr><td>3:</td><td> Spatially-fixed state space inflation </td></tr>
</table>
Spatially-varying state space inflation stores an array of inflation values,
one for each item in the state vector.  If time-evolution is enabled each
value can evolve independently.  Spatially-fixed state space inflation 
uses a single inflation value for all items in the state vector.
If time-evolution is enabled that single value can evolve.
See <em>inf_sd_initial</em> below for control of the time-evolution behavior.
In practice
we recommend starting with no inflation at all (both values 0),
and then when first trying out inflation start with type 2 
prior inflation and no inflation (0) for posterior.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_deterministic</em><br />
valid values: .true. or .false.
<dd>
Recommend always using .true..
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_initial</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If not reading in inflation values from a restart file,
the initial value to set for the inflation.  Generally
we recommend starting with just slightly above 1.0, 
maybe 1.02, for a slight amount of initial inflation.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_sd_initial</em><br />
valid values: 0.0 to infinity, or -1 to disable
<dd>
If not reading in inflation standard deviation values
from a file, the initial value to set for the inflation
standard deviation.  This value (or these values)
control whether the inflation values evolve with time or 
not.  A negative value prevents
the inflation values from being updated, so they are
constant throughout the run.  If positive, the inflation
values evolve through time.  Even though we talk
about a single inflation value, the inflation has
a gaussian distribution with a mean and standard deviation.
We use the mean value when we inflate, and the
standard deviation indicates how sure 
of the value we are. Larger standard deviation values are 
less sure and the inflation value will vary more quickly 
with time.
Smaller values are more sure and the time evolution will
be slower since we are more confident that the mean is correct.
We have had good results setting this and <em>inf_sd_lower_bound</em>
to 0.6 for large geophysical models.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_lower_bound</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If inflation is time-evolving (see <em>inf_sd_initial</em> namelist item above),
then this sets the lowest value the inflation can evolve to.
Setting a number less than one allows for deflation but generally
in a well-observed system the ensemble needs more spread and not less.
We recommend a setting of 1.0.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_upper_bound</em><br />
valid values: real numbers, usually 1.0 or slightly larger
<dd>
If inflation is time-evolving (see <em>inf_sd_initial</em> namelist item above),
then this sets the largest value the inflation can evolve to.
We recommend a setting of 100.0, although if the inflation
values reach those levels there is probably a problem
with the assimilation.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_sd_lower_bound</em><br />
valid values: 0.0 to infinity, or -1 to disable
<dd>
If the setting of <em>inf_sd_initial</em> is
-1.0 (to disable time evolution of inflation) then set
this to the same value.  Otherwise, set a lower value
that the standard deviation of the inflation cannot fall
below.  As the width of the inflation distribution changes,
this sets a lower bound for the value.  Lower values will
let the inflation vary more slowly with time; larger values
will allow the inflation to adapt in time more quickly.
We have had good results setting this and <em>inf_sd_initial</em>
to 0.6 for large geophysical models.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_damping</em><br />
valid values: 0.0 to 1.0
<dd>
Applies to all state-space inflation types, but most frequently
used with time-adaptive inflation variants.
The difference between the current inflation value and 1.0 
is multiplied by this factor before the next assimilation cycle. 
A value of 0.0 turns all inflation off by forcing the inflation value to 1.0.
A value of 1.0 turns damping off by leaving the original inflation value unchanged.
We have had good results in large geophysical models using 
time- and space-adaptive state-space inflation and setting the
damping to a value of 0.9, which damps slowly.  Damping appears to
particularly help in cases where there are dense clusters of observations
at irregular times.  Areas that are heavily observed evolve
large inflation values to prevent the ensemble members from losing
too much spread. However if then the area is unobserved for some
period of time there was no mechanism to force the inflation values to drop 
back down to smaller levels.  The damping factor accomplishes this.
<br /> <br />
<dt>
<em>&amp;filter_nml :: inf_output_restart </em><br />
valid values: .true. or .false.
<dd>
If true, write the inflation and standard deviation 
values into a restart file.  The name is selected by
the <em>inf_out_file_name</em> string. 
An initial run could be done
to let spatially-varying inflation values evolve 
in a spinup phase, and then the saved values can be read back in
and used as fixed values in further runs.  Or if a long assimilation
run is executed in separate jobs steps and time-varying
inflation is used, then the restart file from the
previous job step must be supplied as an input file
for the next step (from <em>inf_in_file_name</em>).
There is an inflation value
and inflation standard deviation per state vector item,
so the total file size will be two times the state vector length.
<br /> <br />
</dl>

<P>
The suggested procedure for testing inflation options 
is to start without
any (both <em>inf_flavor</em> values set to 0).  Then enable Prior
state space, spatially-varying inflation, with no Posterior
inflation (set <em>inf_flavor</em> to [2, 0]).  Then try damped
inflation (set <em>inf_damping</em> to 0.9 and set <em>inf_sd_initial</em>
and <em>inf_sd_lower_bound</em> to 0.6).  The inflation values and
standard deviation are written out to the Prior_Diag.nc
and Posterior_Diag.nc files as the last 2 'copies', so 
the inflation fields can be plotted (we often use 
<a href="http://meteora.ucsd.edu/~pierce/ncview_home_page.html">ncview</a>
).  
Expected inflation values are generally in the 1 to 10 range; 
if values grow much larger than this it usually indicates
a problem with the assimilation.
</P> 


<A NAME="WhereToModify"></A>
<H4>Directories expected to be Modified</H4>
<P>
DART is distributed as a toolkit/library/facility that can be
used as-is with the existing models and observations, but is also
designed so that users can add new models, new observation types
and forward operators, and new assimilation algorithms.  
</P>
<P>
The locations in the DART code tree which are intended to be
modified by users are:
</P>
<DL>
<DT>New Models</DT><DD>Add a new directory in the <em class=file>models</em> subdirectory.  
Copy (recursively, e.g. <em class=code>cp -r</em>) the contents of the
<em class=file>template</em> directory and modify from there.  Note that the 
<em class=file>model_mod.f90</em>
file in the template dir is appropriate for small models; for large geophysical
models see the <em class=file>full_model_mod.f90</em> file 
and also examine other model directories for ideas.
See additional documentation in the <a href="../models/model_mod.html">model_mod</a>
documentation, and the 
<a href="http://www.image.ucar.edu/DAReS/DART/DART_Documentation.php#adding_a_model">
DART web pages</a> on adding new models.
</DD>
<DT>New Observation Types</DT><DD>Define a new type via a file in the 
<em class=file>obs_def</em> subdirectory.  To convert observations from other
formats to DART format, add a new directory in the <em class=file>observations</em> subdirectory.
See additional documentation in the <a href="../obs_def/obs_def_mod.html">obs_def_mod</a>
documentation, and the 
<a href="http://www.image.ucar.edu/DAReS/DART/DART_Observations.php#adding_types">
DART web pages</a> on adding new models.
</DD>
<DT>New Observation Forward Operators</DT><DD>If the forward operator is more
complicated than directly interpolating a field in the model state, a new module can be
added in the <em class=file>obs_def</em> subdirectory. See the same
documentation for adding new observations types above.
<DT>New Assimilation Algorithms</DT><DD>If you want to try
out a different filter type modify the filter code in the
<em class=file>assim_tools/assim_tools_mod.f90</em> file.
See the <a href="../assim_tools/assim_tools_mod.html">assim_tools_mod</a> documentation.
</DD>
</DL>


<A NAME="DetailedProgramFlow"></A>
<H4>Detailed Program Execution Flow</H4>
<P>
The detailed execution flow inside the filter program is:
</P>

<ul>
<li>Read in observations.  </li>
<li>Read in state vector restart files.  </li>
<li>Initialize inflation fields, possibly reading restart files. </li>
<li>Initialize output netcdf diagnostic files. </li>
<li>Trim off any observations if start/stop times specified. </li>
<li>Begin main assimilation loop:
<ul>
<li>Check model time vs observation times: 
<ul>
<li>If current assimilation window is earlier than model time, error. </li>
<li>If current assimilation window includes model time, begin assimilating. </li>
<li>If current assimilation window is later than model time, advance model:
<ul>
<li>Write out current state vectors for all ensemble members. </li>
<li>Advance the model by subroutine call or by shell script:
<ul>
<li>Convert the data into format suitable for model. </li>
<li>Tell the model to run up to the requested time. </li>
<li>Convert the new data back into DART format. </li>
</ul>
</li>
<li>Read in new state vectors for all ensemble members. </li>
</ul></li>
</ul></li>
<li>Apply prior inflation if requested. </li>
<li>Compute ensemble of prior observation values with forward operators. </li>
<li>Compute and write out prior state space diagnostics. (Note this is AFTER
    any prior inflation has been applied.)</li>
<li>Compute and write out prior observation space diagnostics. </li>
<li>Assimilate all observations in this window:
<ul>
<li>Get all obs locations and kinds. </li>
<li>Get all state vector locations and kinds. </li>
<li>For each observation:
<ul>
<li>Compute the observation increments. </li>
<li>Find all other obs and states within localization radius. </li>
<li>Compute the covariance between obs and state variables. </li>
<li>Apply increments weighted by correlation values. </li>
<li>Apply increments to any remaining unassimilated observations. </li>
<li>Loop until all observations in window processed. </li>
</ul></li>
</ul></li>
<li>Apply posterior inflation if requested. </li>
<li>Compute ensemble of posterior observation values with forward operators. </li>
<li>Compute and write out posterior state space diagnostics. </li>
<li>Compute and write out posterior observation space diagnostics. </li>
<li>Loop until all observations in input file processed. </li>
</ul></li>
<li>Close diagnostic files. </li>
<li>Write out final observation sequence file. </li>
<li>Write out inflation restart files if requested. </li>
<li>Write out state vector restart files if requested. </li>
<li>Release memory for state vector and observation ensemble members. </li>
</ul>
  
<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST ====================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from 
prematurely terminating the namelist.
</P>

<div class=namelist>
<pre>
&amp;filter_nml
   async                    = 0,
   adv_ens_command          = "./advance_model.csh",
   ens_size                 = 20,
   start_from_restart       = .false.,
   output_restart           = .false.,
   obs_sequence_in_name     = "obs_seq.out",
   obs_sequence_out_name    = "obs_seq.final",
   restart_in_file_name     = "filter_ics",
   restart_out_file_name    = "filter_restart",
   init_time_days           = 0,
   init_time_seconds        = 0,
   first_obs_days           = -1,
   first_obs_seconds        = -1,
   last_obs_days            = -1,
   last_obs_seconds         = -1,
   num_output_state_members = 0,
   num_output_obs_members   = 0,
   output_interval          = 1,
   num_groups               = 1,
   input_qc_threshold       =  3.0,
   outlier_threshold        = -1.0,
   enable_special_outlier_code = .false.,
   output_forward_op_errors = .false.,
   output_restart_mean      = .false.,
   output_timestamps        = .false.,
   output_inflation         = .true.,
   trace_execution          = .false.,
   silence                  = .false.,

   inf_flavor                  = 0,                       0,
   inf_initial_from_restart    = .false.,                 .false.,
   inf_sd_initial_from_restart = .false.,                 .false.,
   inf_output_restart          = .false.,                 .false.,
   inf_deterministic           = .true.,                  .true.,
   inf_in_file_name            = 'not_initialized',       'not_initialized',
   inf_out_file_name           = 'not_initialized',       'not_initialized',
   inf_diag_file_name          = 'not_initialized',       'not_initialized',
   inf_initial                 = 1.0,                     1.0,
   inf_sd_initial              = 0.0,                     0.0,
   inf_damping                 = 1.0,                     1.0,
   inf_lower_bound             = 1.0,                     1.0,
   inf_upper_bound             = 1000000.0,               1000000.0,
   inf_sd_lower_bound          = 0.0,                     0.0
/
</pre>
</div>

<br />
<br />

<P>
Particular options to be aware of are:
async, ens_size, cutoff (localization radius), inflation flavor, outlier_threshold,
restart filenames (including inflation), obs_sequence_in_name, horiz_dist_only,
binary or ascii controls for state vector and observation sequence file formats.
Some of these important items are located in other namelists, but all are in the
same input.nml file.
</P>
<P>
The inflation control variables are all
dimensioned 2, the first value being for the prior inflation and the second
being for the posterior inflation.
</P>

<br />

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>
<TR><TD>async</TD>
    <TD>integer</TD>
    <TD>Controls method for advancing model:
         <UL>
          <LI>0 is subroutine call</LI>
          <LI>2 is shell command</LI>
          <LI>4 is mpi-job script</LI>
         </UL>
 </TD></TR>

<TR><TD>adv_ens_command</TD>
    <TD>character(len=129)</TD>
    <TD>Command sent to shell if async is 2. 
 </TD></TR>

<TR><TD>ens_size</TD>
    <TD>integer</TD>
    <TD>Size of ensemble.
 </TD></TR>

<TR><TD>start_from_restart</TD>
    <TD>logical</TD>
    <TD>True means start from a restart file, false means 
        perturb a single state vector in restart file. 
 </TD></TR>

<TR><TD>output_restart</TD>
    <TD>logical</TD>
    <TD>True means output a restart file. 
 </TD></TR>

<TR><TD>obs_sequence_in_name</TD>
    <TD>character(len=129)</TD>
    <TD>File name from which to read an observation sequence. 
 </TD></TR>

<TR><TD>obs_sequence_out_name</TD>
    <TD>character(len=129)</TD>
    <TD>File name to which to write output observation sequence. 
 </TD></TR>

<TR><TD>restart_in_file_name</TD>
    <TD>character(len=129)</TD>
    <TD>File containing state restart vectors. 
 </TD></TR>

<TR><TD>restart_out_file_name</TD>
    <TD>character(len=129)</TD>
    <TD>File to which to write restart state vectors. 
 </TD></TR>

<TR><TD>init_time_days</TD>
    <TD>integer</TD>
    <TD>If negative, don't use. If non-negative, override the initial 
        days read from state data restart file. 
 </TD></TR>

<TR><TD>init_time_seconds</TD>
    <TD>integer</TD>
    <TD>If negative don't use. If non-negative, override the initial
        seconds read from state data restart file. 
 </TD></TR>

<TR><TD>first_obs_days</TD>
    <TD>integer</TD>
    <TD>If negative, don't use. If non-negative, ignore all observations
        before this time.
 </TD></TR>

<TR><TD>first_obs_seconds</TD>
    <TD>integer</TD>
    <TD>If negative, don't use. If non-negative, ignore all observations
        before this time.
 </TD></TR>

<TR><TD>last_obs_days</TD>
    <TD>integer</TD>
    <TD>If negative, don't use. If non-negative, ignore all observations
        after this time.
 </TD></TR>

<TR><TD>last_obs_seconds</TD>
    <TD>integer</TD>
    <TD>If negative, don't use. If non-negative, ignore all observations
        after this time.
 </TD></TR>

<TR><TD>num_output_state_members</TD>
    <TD>integer</TD>
    <TD>Number of ensemble members to be included in the state 
        diagnostic output.
 </TD></TR>

<TR><TD>num_output_obs_members</TD>
    <TD>integer</TD>
    <TD>Number of ensemble members to be included in the 
        output observation sequence file.
 </TD></TR>

<TR><TD>output_interval</TD>
    <TD>integer</TD>
    <TD>Output state and observation diagnostics every 'N'th 
        assimilation time, N is output_interval.
 </TD></TR>

<TR><TD>num_groups</TD>
    <TD>integer</TD>
    <TD>Number of groups for hierarchical filter.
 </TD></TR>

<TR><TD>outlier_threshold</TD>
    <TD>real(r8)</TD>
    <TD>Reject observation if prior mean is more than this many 
        standard deviations from observation. Negative means no check. 
 </TD></TR>

<TR><TD>enable_special_outlier_code</TD>
    <TD>logical</TD>
    <TD>If true call a subroutine which can be customized by the user to do 
more elaborate outlier thresholding tests.  See <em class=code>failed_outlier()
</em> near the bottom of <em class=file>filter.f90</em> for where to add the 
custom code, and for commented out examples of possible tests.  Turning this
flag on and off allows comparisons to be made between the default outlier
threshold code and any custom settings without having to recompile the code.
To change the outlier behavior you will have to add code in
<em class=file>DART/filter/filter.f90</em> and recompile your executables.
As distributed, turning this flag on and off will make no difference in the
results.
 </TD></TR>

<TR><TD>input_qc_threshold</TD>
    <TD>real(r8)</TD>
    <TD>Reject observation if incoming QC value exceeds this value.
        Incoming observations usually have a QC value provided with
        the dataset, e.g. NCEP obs include an incoming data QC.  
 </TD></TR>

<TR><TD>output_forward_op_errors</TD>
    <TD>logical</TD>
    <TD> True means output errors from forward observation operators.  This is 
the 'istatus' error return code from the model interpolate routine.  An ascii
text file 
<em class=file>prior_forward_op_errors</em> and/or 
<em class=file>post_forward_op_errors</em> will be
created in the current directory.  For each ensemble member which returns a
non-zero return code, a line will be written to this file.  Each line will
have three values listed: the observation number, the ensemble member number,
and the istatus return code.  Be cautious when turning this option on.  The
number of lines in this file can be up to the number of observations times
the number of ensemble members times the number of assimilation cycles
performed.  This option is generally most useful when run with a small
observation sequence file and a small number of ensemble members to diagnose
forward operator problems.
 </TD></TR>

<TR><TD>output_restart_mean</TD>
    <TD>logical</TD>
    <TD>True means output a restart file which contains the ensemble mean.  
The file name will be the value of the namelist item
<em class=code>&amp;filter_nml::restart_out_file_name</em>
with the string <em class=code>.mean</em> appended.  Even if 
<em class=code>&amp;ensemble_manager_nml::single_restart_file_out</em>
is true the mean data will be written to a separate file.
 </TD></TR>

<TR><TD>output_timestamps</TD>
    <TD>logical</TD>
    <TD>True means write timing information to the log before and after 
        the model advance and the observation assimilation phases.
 </TD></TR>

<TR><TD>output_inflation</TD>
    <TD>logical</TD>
    <TD>True means output inflation values in the prior and posterior
        diagnostic files.  False omits them.
 </TD></TR>

<TR><TD>trace_execution</TD>
    <TD>logical</TD>
    <TD>True means output very detailed messages about what routines
        are being called in the main filter loop.  Useful if a job
        hangs or otherwise doesn't execute as expected.
 </TD></TR>

<TR><TD>silence</TD>
    <TD>logical</TD>
    <TD>True means output almost no runtime messages.  Not recommended
        for general use, but can speed long runs of the lower order models
        if the execution time becomes dominated by the volume of output. 
 </TD></TR>

<TR><TD colspan=3>All subsequent variables are arrays of length 2.<br />
                  The first element is for the prior, the second element is 
                  for the posterior.
 </TD></TR>

<TR><TD>inf_flavor</TD>
    <TD>integer array dimension(2)</TD>
    <TD>Inflation flavor for [prior, posterior]
        <UL>
         <LI>0 = none</LI>
         <LI>1 = obs_space</LI>
         <LI>2 = spatially-varying state space</LI>
         <LI>3 = spatially-fixed state space </LI>
        </UL>
        (See sd_initial below for how to set the time evolution options.)
 </TD></TR>

<TR><TD>inf_initial_from_restart</TD>
    <TD>logical array dimension(2)</TD>
    <TD>If true, get initial mean values for inflation from restart file.
        If false, use the corresponding namelist value 
        <em class=code>inf_initial</em>.
 </TD></TR>

<TR><TD>inf_sd_initial_from_restart</TD>
    <TD>logical array dimension(2)</TD>
    <TD>If true, get initial standard deviation values for 
        inflation from restart file.
        If false, use the corresponding namelist value 
        <em class=code>inf_sd_initial</em>.
 </TD></TR>

<TR><TD>inf_deterministic</TD>
    <TD>logical array dimension(2)</TD>
    <TD>True means deterministic inflation, false means stochastic. 
 </TD></TR>

<TR><TD>inf_output_restart</TD>
    <TD>logical array dimension(2)</TD>
    <TD>Output an inflation restart file if true. 
 </TD></TR>

<TR><TD>inf_in_file_name</TD>
    <TD>character(len=129) dimension(2)</TD>
    <TD>Filename to read inflation restart values from. 
 </TD></TR>

<TR><TD>inf_out_file_name</TD>
    <TD>character(len=129) dimension(2)</TD>
    <TD>Filename to write inflation restart values into.
 </TD></TR>

<TR><TD>inf_diag_file_name</TD>
    <TD>character(len=129) dimension(2)</TD>
    <TD>Filename to write output diagnostics for observation 
        space inflation into. 
 </TD></TR>

<TR><TD>inf_initial</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Initial value of inflation if not read from restart file. 
 </TD></TR>

<TR><TD>inf_sd_initial</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Initial value of inflation standard deviation if not read 
        from restart file.  If negative, do not update the inflation
        values, so they are time-constant.  If positive, the inflation
        values will adapt through time, so they are time-varying.
 </TD></TR>

<TR><TD>inf_damping</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Damping factor for inflation mean values.  
The difference between the current inflation value and 1.0 is multiplied by
this factor before the next assimilation cycle.  The value should be between
0.0 and 1.0.  Setting a value of 0.0 is full damping, which in fact
turns all inflation off by fixing the inflation value at 1.0.   A value
of 1.0 turns inflation damping off leaving the original inflation value
unchanged.
 </TD></TR>

<TR><TD>inf_lower_bound</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Lower bound for inflation value.
 </TD></TR>

<TR><TD>inf_upper_bound</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Upper bound for inflation value.
 </TD></TR>

<TR><TD>inf_sd_lower_bound</TD>
    <TD>real(r8) dimension(2)</TD>
    <TD>Lower bound for inflation standard deviation. 
        If using a negative value for <em class=code>sd_initial</em> 
        this should also be negative to preserve the setting.
 </TD></TR>

</TBODY> 
</TABLE>
</div>

<br />
<br />

<H4 class=indent1>Deprecated or Obsolete namelist variables</H4>
<P>The following table contains the deprecated or obsolete namelist variables.
   If only deprecated, the values will have no effect.  If obsolete,
   it is a FATAL ERROR to have these in the namelist.
</P>

<div>
<TABLE border=0 cellpadding=3 width=100% summary='deprecated namelist items'>
<THEAD align=left>
<TR><TH>Contents    </TH>
    <TH>Type        </TH>
    <TH>Description </TH></TR>
</THEAD>

<TBODY valign=top>
<TR><TD>output_state_ens_mean</TD>
    <TD><b>obsolete</b></TD>
    <TD>The ensemble mean is now always in the state diagnostic output.
 </TD></TR>

<TR><TD>output_state_ens_spread</TD>
    <TD><b>obsolete</b></TD>
    <TD>The ensemble spread is now always in the state diagnostic output.
 </TD></TR>

<TR><TD>output_obs_ens_mean</TD>
    <TD><b>obsolete</b></TD>
    <TD>The ensemble mean is now always in the output observation sequence file.
 </TD></TR>

<TR><TD>output_obs_ens_spread</TD>
    <TD><b>obsolete</b></TD>
    <TD>The ensemble spread is now always in the output observation sequence file.
 </TD></TR>

<TR><TD>inf_start_from_restart</TD>
    <TD><b>obsolete</b></TD>
    <TD>The mean and standard deviation now have separate namelist controls.
 </TD></TR>
</TBODY>
</TABLE>

</div>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Describe the modules used by this program.                       -->
<!--==================================================================-->

<A NAME="Modules"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>MODULES USED</H2>
<PRE>
types_mod
obs_sequence_mod
obs_def_mod
time_manager_mod
utilities_mod
assim_model_mod
assim_tools_mod
obs_model_mod
ensemble_manager_mod
adaptive_inflate_mod
mpi_utilities_mod
smoother_mod
</PRE>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>
<UL>
 <LI>input ensemble member data; from restart_in_file_name</LI>
 <LI>output ensemble member data; from restart_out_file_name</LI>
 <LI>input observation sequence file; from obs_sequence_in_name</LI>
 <LI>output observation space diagnostic file; from obs_sequence_out_name</LI>
 <LI>output state space prior diagnostics file; Prior_Diag.nc</LI>
 <LI>output state space posterior diagnostics file; Posterior_Diag.nc</LI>
 <LI>input state space inflation data (if enabled); from inf_in_file_name</LI>
 <LI>output state space inflation data (if enabled); from inf_out_file_name</LI>
 <LI>input.nml, to read &amp;filter_nml</LI>
</UL>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ul>
<li>Anderson, J. L., 2001: 
An Ensemble Adjustment Kalman Filter for Data Assimilation.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">129</span>, 2884-2903.<br />
<a href="http://dx.doi.org/10.1175/1520-0493%282001%29129%3C2884%3AAEAKFF%3E2.0.CO%3B2"
target="_blank" >
doi: 10.1175/1520-0493(2001)129&lt;2884:AEAKFF&gt;2.0.CO;2</a> 
<br />
</li>
<li>Anderson, J. L., 2003:
A Local Least Squares Framework for Ensemble Filtering.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">131</span>, 634-642.<br />
<a href="http://dx.doi.org/10.1175/1520-0493%282003%29131%3C0634%3AALLSFF%3E2.0.CO%3B2"
target="_blank" >
doi: 10.1175/1520-0493(2003)131&lt;0634:ALLSFF&gt;2.0.CO;2</a>
<br />
</li>
<li>Anderson, J. L., 2007: 
An adaptive covariance inflation error correction algorithm for ensemble filters.
<span style="font-style: italic;">Tellus A</span>,
<span style="font-weight: bold;">59</span>, 210-224.<br />
<a href="http://dx.doi.org/10.1111/j.1600-0870.2006.00216.x"
target="_blank" >
doi: 10.1111/j.1600-0870.2006.00216.x </a>
<br />
</li>
<li>Anderson, J. L., 2007:
Exploring the need for localization in ensemble data 
assimilation using a hierarchical ensemble filter.
<span style="font-style: italic;">Physica D</span>,
<span style="font-weight: bold;">230</span>, 99-111.<br />
<a href="http://dx.doi.org/10.1016/j.physd.2006.02.011"
target="_blank" >
doi:10.1016/j.physd.2006.02.011</a>
<br />
</li>
<li>Anderson, J., Collins, N., 2007:
Scalable Implementations of Ensemble Filter Algorithms for Data Assimilation.
<span style="font-style: italic;">Journal of Atmospheric and Oceanic Technology</span>, 
<span style="font-weight: bold;">24</span>, 1452-1463.<br />
<a href="http://dx.doi.org/10.1175/JTECH2049.1"
target="_blank" >
doi: 10.1175/JTECH2049.1</a>
<br />
</li>
<li>Anderson, J. L., 2009: 
Spatially and temporally varying adaptive covariance inflation for ensemble filters.
<span style="font-style: italic;">Tellus A</span>,
<span style="font-weight: bold;">61</span>, 72-83.<br />
<a href="http://dx.doi.org/10.1111/j.1600-0870.2008.00361.x"
target="_blank" >
doi: 10.1111/j.1600-0870.2008.00361.x</a>
<br />
</li>
<li>Anderson, J., T. Hoar, K. Raeder, H. Liu,
N. Collins, R. Torn, and  A. Arellano, 2009:
The Data Assimilation Research Testbed: A Community Facility.
<span style="font-style: italic;">Bull. Amer. Meteor. Soc.</span>,
<span style="font-weight: bold;">90</span>, 1283-1296.<br />
<a href="http://dx.doi.org/10.1175/2009BAMS2618.1"
target="_blank" >
doi: 10.1175/2009BAMS2618.1</a>
<br />
</li>
<li>Anderson, J. L., 2010:
A Non-Gaussian Ensemble Filter Update for Data Assimilation.
<span style="font-style: italic;">Mon. Wea. Rev.</span>,
<span style="font-weight: bold;">139</span>, 4186-4198.<br />
<a href="http://dx.doi.org/10.1175/2010MWR3253.1"
target="_blank" >
doi: 10.1175/2010MWR3253.1</a>
<br />
</li>
<li>Anderson, J. L., 2011:
Localization and Sampling Error Correction
in Ensemble Kalman Filter Data Assimilation. 
Submitted for publication, Jan 2011.  
Contact author.</li>

</ul>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100% summary='error table'>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>ens_size in namelist is ###: Must be &gt; 1</TD>
    <!-- comment --><TD VALIGN=top>Ensemble size must be at least 2. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>inf_flavor= ### Must be 0, 1, 2, 3.</TD>
    <!-- comment --><TD VALIGN=top>Only inflation options 0 to 3 are supported. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>Posterior observation space inflation (type 1) not supported.</TD>
    <!-- comment --><TD VALIGN=top>Posterior observation space inflation doesn't work. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_main</TD>
    <!-- message --><TD VALIGN=top>Number of processes &gt; model size.</TD>
    <!-- comment --><TD VALIGN=top>Number of processes can't exceed model size for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_generate_copy_meta_data</TD>
    <!-- message --><TD VALIGN=top>output metadata in filter needs state ensemble size &lt; 10000, not ###.</TD>
    <!-- comment --><TD VALIGN=top>Only up to 10000 ensemble members with state output for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_generate_copy_meta_data</TD>
    <!-- message --><TD VALIGN=top>output metadata in filter needs obs ensemble size &lt; 10000, not ###.</TD>
    <!-- comment --><TD VALIGN=top>Only up to 10000 ensemble members with obs space output for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>filter_setup_obs_sequence</TD>
    <!-- message --><TD VALIGN=top>input obs_seq file has ### qc fields; must be &lt; 2.</TD>
    <!-- comment --><TD VALIGN=top>Only 0 or 1 qc fields in input obs sequence for now. </TD></TR>

<TR><!-- routine --><TD VALIGN=top>get_obs_copy_index</TD>
    <!-- message --><TD VALIGN=top>Did not find observation copy with metadata observation.</TD>
    <!-- comment --><TD VALIGN=top>Only 0 or 1 qc fields in input obs sequence for now. </TD></TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
none
</P>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<P>
Many.  New assimilation algorithms, support for new observation
types, support for additional models, better performance on higher
numbers of MPI tasks...   The list is long.  Send email to
<a href="mailto:dart@ucar.edu">dart@ucar.edu</a> if you are
interested in additional functionality in DART.
</P>

<P><!-- make sure the 'top' is aligned correctly --></P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact: </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision: </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source: </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date: </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change History: </TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
