! DART software - Copyright 2004 - 2013 UCAR. This open source software is
! provided by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download
!
! DART $Id$

!----------------------------------------------------------------------
! WARNING!!  The file obs_def_mod.f90 is AUTOGENERATED by the
! 'preprocess' program.  Any changes made to this file will be
! overwritten when it is regenerated.  To make permanent changes
! in the code, edit DEFAULT_obs_def_mod.F90, or edit the
! observation specific obs_def_xxx_mod.f90 files.
!----------------------------------------------------------------------


!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Any observation-specific modules which contain executable code to
! handle the interpolation and/or reading and writing of the obs will
! have the module code inserted here.  Then models only have to use
! the obs_def_mod module, and only include obs_def_mod.f90 in their
! path_names files.  To change the observation types/kinds, edit the
! model-specific 'input.nml' file and add or remove lines from the
! &preprocess_nml section, the 'input_files' list.
!
! Start of any user-defined executable module code
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
!No module code needed for ../../../obs_def/obs_def_reanalysis_bufr_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_radar_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_radar_mod

use        types_mod, only : r8, missing_r8, PI, deg2rad
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                             check_namelist_read, find_namelist_in_file,   &
                             nmlfileunit, do_output, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, write_location, read_location, &
                             interactive_location, get_location
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_U_WIND_COMPONENT, KIND_V_WIND_COMPONENT, &
                             KIND_TEMPERATURE, KIND_VERTICAL_VELOCITY,     &
                             KIND_RAINWATER_MIXING_RATIO, KIND_DENSITY,    &
                             KIND_GRAUPEL_MIXING_RATIO,                    &
                             KIND_SNOW_MIXING_RATIO,                       &
                             KIND_POWER_WEIGHTED_FALL_SPEED,               &
                             KIND_RADAR_REFLECTIVITY

implicit none
private

public :: read_radar_ref, get_expected_radar_ref,                          &
          read_radial_vel, write_radial_vel, interactive_radial_vel,       &
          get_expected_radial_vel, get_obs_def_radial_vel, set_radial_vel, &
          get_expected_fall_velocity

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical :: module_initialized = .false.

! Derived type for radial velocity.  Contains auxiliary information stored
! with each obs of this type; used to compute the forward operator.
! See more extensive comments in the interactive_radial_vel() routine for
! expected units, etc.  Technically, the radar location is unused in the
! forward operators currently in this code, but it may be useful for post
! processing or diagnostics, especially if multiple radar locations are
! in the same file.
type radial_vel_type
   private
   type(location_type) :: radar_location      ! location of radar
   real(r8)            :: beam_direction(3)   ! direction of beam
   real(r8)            :: nyquist_velocity    ! nyquist velocity
end type radial_vel_type

! Cumulative index into radial velocity metadata array
integer :: velkeycount = 0

! For error message content
character(len=256) :: msgstring

! Values which are initialized at run time so some can be changed by
! namelist.  After initialization, treated as parameters (values not changed).

! Note that the value of gravity is hardcoded here.  The value for gravity
! used in the model should match this value.   See additional comments
! below in the initialize_constants() subroutine.

real(r8) :: param_gravity     ! gravitational acceleration (m s^-2)

                              ! empirical constants:
real(r8) :: param_a           ! 10^^18 * a (const in rain fall speed eqn)
real(r8) :: param_b           !          b (const in rain fall speed eqn)
real(r8) :: param_c           ! 10^^18 * c (const in snow fall speed eqn)
real(r8) :: param_d           !          d (const in snow fall speed eqn)

real(r8) :: param_CD          ! drag coefficient for graupel/hail
real(r8) :: param_rhos0       ! reference density (kg m^-3) in emperical
                              !  dropsize-fall speed eqn
real(r8) :: param_e           ! parameter in graupel/hail fall speed eqn

                              ! results of gamma function applied to:
real(r8) :: param_gam7b       !   (7+b)
real(r8) :: param_gam7d       !   (7+d)
real(r8) :: param_gam7f       !   (7+0.5)

                              ! exponents in equations for:
real(r8) :: param_powr        !   rain fall speed
real(r8) :: param_pows        !   snow fall speed
real(r8) :: param_powg_dry    !   dry graupel/hail fall speed
real(r8) :: param_powg_wet    !   wet graupel/hail fall speed

                              ! parameters in the equations for:
real(r8) :: param_fs_r        !   rain fall speed
real(r8) :: param_fs_wet_s    !   wet snow fall speed
real(r8) :: param_fs_dry_s    !   dry snow fall speed
real(r8) :: param_fs_wet_g    !   wet graupel/hail fall speed
real(r8) :: param_fs_dry_g    !   dry graupel/hail fall speed

                              ! parameters in the equations for:
real(r8) :: param_refl_r      !   reflectivity from rain
real(r8) :: param_refl_wet_s  !   reflectivity from wet snow
real(r8) :: param_refl_dry_s  !   reflectivity from dry snow
real(r8) :: param_refl_wet_g  !   reflectivity from wet graupel/hail
real(r8) :: param_refl_dry_g  !   reflectivity from dry graupel/hail

!-------------------------------------------------------------
! Namelist with default values
!
! Obsolete: convert_to_dbz and dbz_threshold
!  convert_to_dbz and dbz_threshold have both been removed from the namelist.
!  Values will always be converted to dBZ, and threshold was only used to
!  ensure the log() call never saw a real 0.0_r8.  Please remove these
!  values from your namelist to avoid a run-time error.
!
! There are two replicated sets of 3 namelist values below.
! In each case, there is 1 logical value and 2 numeric values.
! If the logical is false, the numeric values are ignored.
! If true, then the 2 numeric values are:
!  1) a threshold value.  If the observation or forward operator value is
!     less than this threshold, it will be set to a different value.
!  2) the value it should be set to.
! The value is separate from the threshold to allow, for example, the option
! of setting all values below -20 dBZ to -40 dBZ.
!
! If the observation value or the forward operator already has a value of
! missing_r8 it is assumed either the istatus is marked as failed (for the
! forward operator) or that the QC (quality control) flag is set to not
! assimilate this observation and that value is left unchanged regardless of
! the setting on the apply_ref_limit flag.  Note however that it is not a
! good idea to reset a good but small observation value to missing_r8 -- do
! not use it as the lowest_reflectivity setting.
!
! The next 3 namelist items apply to the incoming observation values.
! They are in the namelist so they can be changed at runtime, instead
! of set only when the observation file is originally generated.
!
! apply_ref_limit_to_obs:
!  Logical.  If .TRUE. replace all reflectivity values less than
!  "reflectivity_limit_obs" with "lowest_reflectivity_obs" value.
!  If .FALSE. leave all values as-is.  Defaults to .FALSE.
!
! reflectivity_limit_obs:
!  The threshold value.  Observed reflectivity values less than this
!  threshold will be set to the "lowest_reflectivity_obs" value.
!  Units are dBZ.  Defaults to -10.0.
!
! lowest_reflectivity_obs:
!  The 'set-to' value.  Observed reflectivity values less than the
!  threshold will be set to this value.  Units are dBZ.  Defaults to -10.0.
!
! The next 3 namelist items apply to the forward operator values (the returned
! value from each ensemble member predicting what the observation value should
! be given the current state in this particular member).
!
! apply_ref_limit_to_fwd_op:
!  Same as "apply_ref_limit_to_obs", but for the forward operator.
!
! reflectivity_limit_fwd_op:
!  Same as "reflectivity_limit_obs", but for the forward operator values.
!
! lowest_reflectivity_fwd_op:
!  Same as "lowest_reflectivity_obs", but for the forward operator values.
!
! max_radial_vel_obs:
!  Integer value.  Maximum number of observations of this type to support at
!  run time.  This is combined total of all obs_seq files, for example the
!  observation diagnostic program potentially opens multiple obs_seq.final
!  files, or the obs merge program can also open multiple obs files.
!  Default is 1,000,000 observations.
!
! dielectric_factor:
!  According to Smith (1984), there are two choices for the dielectric
!  factor, depending on how the snow particle sizes are specified.
!  If melted raindrop diameters are used, then the factor is 0.224.  If
!  equivalent ice sphere diameters are used, then the factor is 0.189.
!  Since the common convention is to use melted raindrop diameters, the
!  default here is 0.224.
!
! n0_rain, n0_graupel, n0_snow:
!  Intercept parameters (m^-4) for size distributions of each hydrometeor.
!  The defaults below are for the Lin et al. microphysics scheme
!  with the Hobbs settings for graupel/hail.  (The Hobbs graupel settings
!  are also the default for the Lin scheme in WRF 2.2 and 3.0.)
!
! rho_rain, rho_graupel, rho_snow:
!  Density (kg m^-3) of each hydrometeor type.  The defaults below are for the
!  Lin et al. microphysics scheme with the Hobbs setting for graupel/hail.
!
! allow_wet_graupel:
!  Logical.  It is difficult to predict/diagnose whether graupel/hail has a
!  wet or dry surface.  Even when the temperature is above freezing,
!  evaporation and/or absorption can still result in a dry surface.  This
!  issue is important because the reflectivity from graupel with a wet surface
!  is significantly greater than that from graupel with a dry surface.
!  Currently, the user has two options for how to compute graupel
!  reflectivity.  If allow_wet_graupel is .false. (the default), then graupel
!  is always assumed to be dry.  If allow_wet_graupel is .true., then graupel
!  is assumed to be wet (dry) when the temperature is above (below) freezing.
!  A consequence is that a sharp gradient in reflectivity will be produced at
!  the freezing level.  In the future, it might be better to provide the
!  option of having a transition layer.
!
! microphysics_type:
!  Integer. Tells obs_def_radar_mod what microphysical scheme is employed
!  to enable some smarter decisions in handling fall velocity and radar
!  reflectivity.
!   1  - Kessler scheme
!   2  - Lin et al. microphysics  (default)
!   3  - User selected scheme where 10 cm reflectivity and power weighted fall
!        velocity are expected in the state vector (failure if not found)
!   4  - User selected scheme where only power weighted fall velocity is
!        expected (failure if not found)
!   5  - User selected scheme where only reflectivity is expected (failure
!        if not found)
!  -1  - ASSUME FALL VELOCITY IS ZERO, allows over-riding the failure modes
!        above if reflectivity and/or fall velocity are not available but a
!        result is desired for testing purposes only.
!
! allow_dbztowt_conv:
!  Logical. Flag to enable use of the dbztowt routine where reflectivity is
!  available, but not the power-weighted fall velocity. This scheme uses
!  emperical relations between reflectivity and fall velocity, with poor
!  accuracy for highly reflective, low density particles (such as water coated
!  snow aggregates). Expect questionable accuracy in radial velocity from
!  the forward operator with high elevation angles where ice is present in
!  the model state.

logical  :: apply_ref_limit_to_obs     = .false.
real(r8) :: reflectivity_limit_obs     = -10.0_r8
real(r8) :: lowest_reflectivity_obs    = -10.0_r8
logical  :: apply_ref_limit_to_fwd_op  = .false.
real(r8) :: reflectivity_limit_fwd_op  = -10.0_r8
real(r8) :: lowest_reflectivity_fwd_op = -10.0_r8
integer  :: max_radial_vel_obs         = 1000000
logical  :: allow_wet_graupel          = .false.
integer  :: microphysics_type          = 2
logical  :: allow_dbztowt_conv         = .false.


! Constants which depend on the microphysics scheme used.  Should be set
! in the namelist to match the case being run.

real(r8) :: dielectric_factor =  0.224_r8
real(r8) :: n0_rain           =  8.0e6_r8
real(r8) :: n0_graupel        =  4.0e6_r8
real(r8) :: n0_snow           =  3.0e6_r8
real(r8) :: rho_rain          = 1000.0_r8
real(r8) :: rho_graupel       =  400.0_r8
real(r8) :: rho_snow          =  100.0_r8


namelist /obs_def_radar_mod_nml/ apply_ref_limit_to_obs,     &
                                 reflectivity_limit_obs,     &
                                 lowest_reflectivity_obs,    &
                                 apply_ref_limit_to_fwd_op,  &
                                 reflectivity_limit_fwd_op,  &
                                 lowest_reflectivity_fwd_op, &
                                 max_radial_vel_obs,         &
                                 allow_wet_graupel,          &
                                 dielectric_factor,          &
                                 microphysics_type,          &
                                 allow_dbztowt_conv,         &
                                 n0_rain,                    &
                                 n0_graupel,                 &
                                 n0_snow,                    &
                                 rho_rain,                   &
                                 rho_graupel,                &
                                 rho_snow


! Module global storage for auxiliary obs data, allocated in init routine
type(radial_vel_type), allocatable :: radial_vel_data(:)

contains

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of executable routines
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine initialize_module

! Called once to set values and allocate space

integer :: iunit, io, rc

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

module_initialized = .true.

! Log the version of this source file.
call register_module(source, revision, revdate)

! Read the namelist entry.
call find_namelist_in_file("input.nml", "obs_def_radar_mod_nml", iunit)
read(iunit, nml = obs_def_radar_mod_nml, iostat = io)
call check_namelist_read(iunit, io, "obs_def_radar_mod_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_radar_mod_nml)
if (do_nml_term()) write(     *     , nml=obs_def_radar_mod_nml)

! Consistency warning; print a message if the thresholds and lower values
! are going to be used and are different.
call check_namelist_limits(apply_ref_limit_to_obs,     &
                           reflectivity_limit_obs,     &
                           lowest_reflectivity_obs,    &
                           apply_ref_limit_to_fwd_op,  &
                           reflectivity_limit_fwd_op,  &
                           lowest_reflectivity_fwd_op)

! Allocate space for the auxiliary information associated with each obs
! This code must be placed after reading the namelist, so the user can
! increase or decrease the number of obs supported and use more or less
! memory at run time.
allocate(radial_vel_data(max_radial_vel_obs), stat = rc)
if (rc /= 0) then
   write(msgstring, *) 'initial allocation failed for radial vel obs data,', &
                       'itemcount = ', max_radial_vel_obs
   call error_handler(E_ERR,'initialize_module', msgstring, &
                      source, revision, revdate)
endif

! Set the module global values that do not change during the run.
! This code uses some values which are set in the namelist, so this call
! *must* happen after the namelist read above.
call initialize_constants()

! Log the values used for the constants.
call print_constants()

end subroutine initialize_module

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Radial velocity section
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine read_radial_vel(velkey, ifile, fform)

! Main read subroutine for the radial velocity observation auxiliary data.

integer,          intent(out)          :: velkey
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=8)    :: header
logical             :: is_asciifile
type(location_type) :: radar_location
real(r8)            :: beam_direction(3)
real(r8)            :: nyquist_velocity
integer             :: oldkey

! radar_location: Refers to the lat/lon/height/vertical coordinate option
!   for the radar. Its type is defined through location_type in location_mod.
!   Uses the read_location function in location_mod.
!
! beam_direction: This is a 3-element array specific to the radar module:
!     beam_direction(1) = sin(azimuth)*cos(elevation)
!     beam_direction(2) = cos(azimuth)*cos(elevation)
!     beam_direction(3) = sin(elevation)

if ( .not. module_initialized ) call initialize_module

is_asciifile = ascii_file_format(fform)

if (is_asciifile) then
      ! Read the character identifier for verbose formatted output
      read(ifile, FMT="(a8)") header
      if(header /= 'platform') then
         call error_handler(E_ERR,'read_radial_vel', &
              "Expected location header 'platform' in input file", &
              source, revision, revdate)
      endif
endif

! read_location is a DART library routine that expects an optional string
! arg, but the other two read routines are local to this module and we can
! tell them exactly what format to be reading because we already know it.
radar_location   = read_location        (ifile, fform)
beam_direction   = read_beam_direction  (ifile, is_asciifile)
nyquist_velocity = read_nyquist_velocity(ifile, is_asciifile)

! Read in the velkey for this particular observation, however, it will
! be discarded and a new, unique key will be generated in the set routine.
if (is_asciifile) then
   read(ifile, *) oldkey
else
   read(ifile) oldkey
endif

! Generate new unique radial velocity observation key, and set the contents
! of the private defined type.
call set_radial_vel(velkey, radar_location, beam_direction, nyquist_velocity)

end subroutine read_radial_vel

!----------------------------------------------------------------------

subroutine write_radial_vel(velkey, ifile, fform)

! Write radial velocity auxiliary information to the obs_seq file.

integer,          intent(in)           :: velkey, ifile
character(len=*), intent(in), optional :: fform

logical             :: is_asciifile
type(location_type) :: radar_location
real(r8)            :: beam_direction(3)
real(r8)            :: nyquist_velocity

if ( .not. module_initialized ) call initialize_module

! Simple error check on key number before accessing the array
call velkey_out_of_range(velkey)

is_asciifile = ascii_file_format(fform)

if (is_asciifile) then
   ! Write the 5 character identifier for verbose formatted output
   write(ifile, "('platform')")
endif

! Extract the values for this key and call the appropriate write routines.
radar_location    = radial_vel_data(velkey)%radar_location
beam_direction(:) = radial_vel_data(velkey)%beam_direction(:)
nyquist_velocity  = radial_vel_data(velkey)%nyquist_velocity

! write_location routine is part of the DART library and wants the optional
! format string argument.  The other two routines are local to this module,
! and we have already figured out if it is a unformatted/binary file or
! formatted/ascii, so go ahead and pass that info directly down to the routines.
call         write_location(ifile, radar_location,    fform)
call   write_beam_direction(ifile, beam_direction(:), is_asciifile)
call write_nyquist_velocity(ifile, nyquist_velocity,  is_asciifile)

! Write out the velkey used for this run, however this will be discarded
! when this observation is read in and a new key will be generated.
! (It may be useful for correlating error messages or identifying particular
! observations so we are leaving it as part of the aux data.)
if (is_asciifile) then
   write(ifile, *) velkey
else
   write(ifile) velkey
endif

end subroutine write_radial_vel

!----------------------------------------------------------------------

function read_beam_direction(ifile, is_asciiformat)

! Reads beam_direction from file that was written by write_beam_direction.
! See read_radial_vel for additional discussion.

integer, intent(in) :: ifile
logical, intent(in) :: is_asciiformat
real(r8)            :: read_beam_direction(3)

character(len=5)   :: header
real(r8)           :: beam_direction(3)

if ( .not. module_initialized ) call initialize_module


if (is_asciiformat) then
   read(ifile, "(a5)" ) header

   if(header /= 'dir3d') then
      write(msgstring,*)"Expected beam_direction header 'dir3d' in input file, got ", header
      call error_handler(E_ERR, 'read_beam_direction', msgstring, source, revision, revdate)
   endif
   ! Now read the beam_direction data value into temporaries
   read(ifile, *) beam_direction(1), beam_direction(2), beam_direction(3)
else
   ! No header label, just the binary direction values.
   read(ifile)    beam_direction(1), beam_direction(2), beam_direction(3)
endif

! Check for illegal values
if (minval(beam_direction) < -1.0_r8 .or. maxval(beam_direction) > 1.0_r8) then
   write(msgstring,*) "beam_direction value must be between -1 and 1, got: ", &
                       beam_direction(1), beam_direction(2), beam_direction(3)
   call error_handler(E_ERR, 'read_beam_direction', msgstring, &
                      source, revision, revdate)
endif

! set function return value
read_beam_direction(:) = beam_direction(:)

end function read_beam_direction

!----------------------------------------------------------------------

subroutine write_beam_direction(ifile, beam_direction, is_asciiformat)

! Writes beam_direction to obs file.

integer,  intent(in) :: ifile
real(r8), intent(in) :: beam_direction(3)
logical,  intent(in) :: is_asciiformat

if ( .not. module_initialized ) call initialize_module

if (is_asciiformat) then
   write(ifile, "('dir3d')" )
   write(ifile, *) beam_direction(1), beam_direction(2), beam_direction(3)
else
   write(ifile)    beam_direction(1), beam_direction(2), beam_direction(3)
endif

end subroutine write_beam_direction

!----------------------------------------------------------------------

function read_nyquist_velocity(ifile, is_asciiformat)

! Reads Nyquist velocity from file that was written by write_nyquist_velocity.
! See read_radial_vel for additional discussion.

integer, intent(in) :: ifile
logical, intent(in) :: is_asciiformat
real(r8)            :: read_nyquist_velocity

logical, save :: first_time = .true.

if ( .not. module_initialized ) call initialize_module

if (is_asciiformat) then
   read(ifile, *) read_nyquist_velocity
else
   read(ifile)    read_nyquist_velocity
endif

! idealized obs leave the nyquist velocity as missing_r8.
! warn the user (once) but allow it.  they will not be unfolded
! at assimilation time, which is usually the desired behavior
! for an idealized ob.

if (read_nyquist_velocity == missing_r8 .and. first_time) then
   write(msgstring, *) "no doppler velocity unfolding can be done on these observations"
   call error_handler(E_MSG, 'read_nyquist_velocity:', &
                      "radar observation(s) with missing nyquist velocities encountered on read", &
                      source, revision, revdate, text2=msgstring)

   first_time = .false.
endif

! Check for illegal values; must be non-negative (missing is ok).
if (read_nyquist_velocity < 0.0_r8 .and. read_nyquist_velocity /= missing_r8) then
   write(msgstring,*) "bad value for nyquist velocity: ", read_nyquist_velocity
   call error_handler(E_ERR, 'read_nyquist_velocity:', msgstring, &
                      source, revision, revdate, text2="nyquist velocity must be non-negative")
endif

end function read_nyquist_velocity

!----------------------------------------------------------------------

subroutine write_nyquist_velocity(ifile, nyquist_velocity, is_asciiformat)

! Writes Nyquist velocity to obs file.

integer,  intent(in) :: ifile
real(r8), intent(in) :: nyquist_velocity
logical,  intent(in) :: is_asciiformat

if ( .not. module_initialized ) call initialize_module

if (is_asciiformat) then
   write(ifile, *) nyquist_velocity
else
   write(ifile)    nyquist_velocity
endif

end subroutine write_nyquist_velocity

!----------------------------------------------------------------------

subroutine get_obs_def_radial_vel(velkey, radar_location, beam_direction, &
                                  nyquist_velocity)

! Return the auxiliary contents of a given radial velocity observation

integer,             intent(in)  :: velkey
type(location_type), intent(out) :: radar_location
real(r8),            intent(out) :: beam_direction(3)
real(r8),            intent(out) :: nyquist_velocity

! Simple error check on key number before accessing the array
call velkey_out_of_range(velkey)

radar_location    = radial_vel_data(velkey)%radar_location
beam_direction    = radial_vel_data(velkey)%beam_direction(:)
nyquist_velocity  = radial_vel_data(velkey)%nyquist_velocity

end subroutine get_obs_def_radial_vel

!----------------------------------------------------------------------

subroutine set_radial_vel(velkey, radar_location, beam_direction, nyquist_velocity)

! Common code to increment the current key count, and set the private
! contents of this observation's auxiliary data.

integer,             intent(out) :: velkey
type(location_type), intent(in)  :: radar_location
real(r8),            intent(in)  :: beam_direction(3)
real(r8),            intent(in)  :: nyquist_velocity

if ( .not. module_initialized ) call initialize_module

! The total velocity metadata key count from all sequences
velkeycount = velkeycount + 1
velkey = velkeycount             ! set the return value

! Simple error check on key number before accessing the array
! This errors out if too key value now too large.
call velkey_out_of_range(velkey)

radial_vel_data(velkey)%radar_location    = radar_location
radial_vel_data(velkey)%beam_direction(:) = beam_direction(:)
radial_vel_data(velkey)%nyquist_velocity  = nyquist_velocity

end subroutine set_radial_vel

!----------------------------------------------------------------------

subroutine interactive_radial_vel(velkey)

! Interactively reads in auxiliary information for a radial velocity obs.

integer, intent(out) :: velkey

! Uses interactive_location of DART location_mod, plus the local subroutines
! interactive_beam_direction and set_radial_vel.
! See read_radial_vel for more information.

! velkey is internally incremented in the set routine, and only counts
! the index for this specialized observation kind.

type(location_type)  :: location
real(r8)             :: beam_direction(3)
real(r8)             :: nyquist_velocity

if ( .not. module_initialized ) call initialize_module

!Note: Obs location will subsequently be read in by the standard DART module
! "interactive_obs_def". No check is performed here whether radar location,
! obs location, and beam direction are self-consistent. It is the user's
! responsibility to make sure that they are.  This set of information
! does overspecify the problem slightly, but it is expensive to compute
! the true beam direction because of bending of the beam and earth curvature.


write(*, *)
write(*, *) 'Beginning to inquire for information on radar location.'
write(*, *)
write(*, *) 'WARNING!! Make sure that you select 3 (height) for the'
write(*, *) 'vertical coordinate option and enter height in meters.'
write(*, *) 'This location is where the radar source is located.  The later'
write(*, *) 'location question will be asking about where the observation'
write(*, *) 'itself is located.'
write(*, *)

call interactive_location(location)

write(*, *)
write(*, *) 'Beginning to inquire for information on radar beam direction.'
write(*, *)

call interactive_beam_direction(beam_direction)

write(*, *)
write(*, *) 'Beginning to inquire for information on radar Nyquist velocity.'
write(*, *)

call interactive_nyquist_velocity(nyquist_velocity)


call set_radial_vel(velkey, location, beam_direction, nyquist_velocity)

write(*, *)
write(*, *) 'End of specialized section for radial velocity.'
write(*, *) 'You will now have to enter the regular obs information.'
write(*, *)

end subroutine interactive_radial_vel

!----------------------------------------------------------------------

subroutine interactive_beam_direction(beam_direction)

! Prompt for beam direction information in azimuth/elevation degrees.

real(r8), intent(out) :: beam_direction(3)

real(r8) :: az, el

az = -1.0
do while (az < 0.0 .or. az > 360.0)
   write(*, *) 'Input the beam direction azimuth in degrees (0 <= az <= 360):'
   read(*, *) az
end do

el = -1.0
do while (el < 0.0 .or. el > 90.0)
   write(*, *) 'Input the beam direction elevation in degrees (0 <= el <= 90):'
   read(*, *) el
end do

! Convert to radians and compute the actual values stored with the observation.
az = az * deg2rad
el = el * deg2rad

beam_direction(1) = sin(az) * cos(el)
beam_direction(2) = cos(az) * cos(el)
beam_direction(3) = sin(el)

end subroutine interactive_beam_direction

!----------------------------------------------------------------------

subroutine interactive_nyquist_velocity(nyquist_velocity)

! Prompt for Nyquist velocity

real(r8), intent(out) :: nyquist_velocity

nyquist_velocity = -1.0

do while (nyquist_velocity < 0.0)
   write(*, *) 'Input Nyquist velocity for this obs point in m/sec'
   write(*, *) '(Typical values are 10-100 m/s, must be >= 0):'
   read(*, *)  nyquist_velocity
end do

end subroutine interactive_nyquist_velocity

!----------------------------------------------------------------------

subroutine get_expected_radial_vel(state_vector, location, velkey, &
                                   radial_vel, istatus)

! This is the main forward operator routine for radar Doppler velocity.

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: velkey
real(r8),            intent(out) :: radial_vel
integer,             intent(out) :: istatus


! Given a location and the state vector from one of the ensemble members,
! compute the model-predicted radial velocity that would be observed
! at that location.  The value is returned in 'radial_vel'.
! 'istatus' is the return code.  0 is success; any positive value signals an
! error (different values can be used to indicate different error types).
! Negative istatus values are reserved for internal use only by DART.
!
! The along-beam component of the 3-d air velocity is computed from the
! u, v, and w fields plus the beam_direction.  The along-beam component
! of power-weighted precipitation fall velocity is added to the result.
!
! Reference: Lin et al., 1983 (J. Climate Appl.Meteor., 1065-1092)

real(r8) :: u, v, w, precip_fall_speed
real(r8) :: debug_location(3)
logical  :: debug = .false.   ! set to .true. to enable debug printout

if ( .not. module_initialized ) call initialize_module

! Simple error check on key number before accessing the array
call velkey_out_of_range(velkey)

call interpolate(state_vector, location, KIND_U_WIND_COMPONENT, u, istatus)
if (istatus /= 0) then
   radial_vel = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_V_WIND_COMPONENT, v, istatus)
if (istatus /= 0) then
   radial_vel = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_VERTICAL_VELOCITY, w, istatus)
if (istatus /= 0) then
   radial_vel = missing_r8
   return
endif

call get_expected_fall_velocity(state_vector, location, precip_fall_speed, istatus)
if (istatus /= 0) then
   radial_vel = missing_r8
   return
endif

radial_vel = radial_vel_data(velkey)%beam_direction(1) * u +    &
             radial_vel_data(velkey)%beam_direction(2) * v +    &
             radial_vel_data(velkey)%beam_direction(3) * (w-precip_fall_speed)

! Good return code.  Reset possible istatus error from trying to compute
! weighted fall speed directly.
istatus = 0

if (debug) then
   debug_location = get_location(location)
   print *
   print *, 'radial velocity key: ', velkey
   print *, 'obs location (deg): ', debug_location(1),         &
                                    debug_location(2),         debug_location(3)
   print *, 'obs location (rad): ', debug_location(1)*deg2rad, &
                                    debug_location(2)*deg2rad, debug_location(3)
   print *, 'interpolated u: ', u
   print *, 'interpolated v: ', v
   print *, 'interpolated w: ', w
   print *, 'interp or derived fall speed: ', precip_fall_speed
   print *, 'final radial_vel: ', radial_vel
   print *, 'istatus: ', istatus
endif

end subroutine get_expected_radial_vel

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Expected fall velocity section
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine get_expected_fall_velocity(state_vector, location,  &
                                      precip_fall_speed, istatus)

! This is the main forward operator routine for the expected
! fall velocity, and it also used as part of computing expected
! radial velocity.

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: precip_fall_speed
integer,             intent(out) :: istatus

! Local vars
real(r8) :: qr, qg, qs, rho, temp, refl
logical, save :: first_time = .true.

! If the model can return the precipitation fall speed directly, let it do
! so. Otherwise, attempt to compute if Kessler or Lin type microphysics,
! or see if the dbztowt routine is desired. Note that the computation for
! Lin and Kessler is expected to be reasonably accurate for 10cm radar.

! Should we check microphysics_type var or just go ahead and try to get a value?
istatus = 0
precip_fall_speed = 0.0_r8
call interpolate(state_vector, location, KIND_POWER_WEIGHTED_FALL_SPEED, &
                 precip_fall_speed, istatus)

! If able to get value, return here.
if (istatus == 0) return

! If the user explicitly wanted to interpolate in the field, try to complain
! if it could not.  Note that the interp could fail for other reasons.
if (microphysics_type == 3 .or. microphysics_type == 4) then
   ! Could return a specific istatus code here to indicate this condition.
   if (first_time) then
      call error_handler(E_MSG,'get_expected_fall_velocity', &
                         'interpolate failed. Fall Speed may NOT be in state vector', '', '', '')
      first_time = .false.
   endif
   return
endif

! If not in the state vector, try to calculate it here based on the
! setting of the microphysics_type namelist.

! if Kessler or Lin we can compute the fall velocity
if (microphysics_type == 1 .or. microphysics_type == 2) then
   call interpolate(state_vector, location, KIND_RAINWATER_MIXING_RATIO, qr, istatus)
   if (istatus /= 0) then
      precip_fall_speed = missing_r8
      return
   endif
   if (microphysics_type == 2) then
      call interpolate(state_vector, location, KIND_GRAUPEL_MIXING_RATIO, qg, istatus)
      if (istatus /= 0) then
         precip_fall_speed = missing_r8
         return
      endif
      call interpolate(state_vector, location, KIND_SNOW_MIXING_RATIO, qs, istatus)
      if (istatus /= 0) then
         precip_fall_speed = missing_r8
         return
      endif
   endif
   ! Done with Lin et al specific calls
   call interpolate(state_vector, location, KIND_DENSITY, rho, istatus)
   if (istatus /= 0) then
      precip_fall_speed = missing_r8
      return
   endif
   call interpolate(state_vector, location, KIND_TEMPERATURE, temp, istatus)
   if (istatus /= 0) then
      precip_fall_speed = missing_r8
      return
   endif
   call get_LK_precip_fall_speed(qr, qg, qs, rho, temp, precip_fall_speed)
   ! Done with Lin et al or Kessler -
else if (microphysics_type == 5 .and. allow_dbztowt_conv) then
   ! Provided reflectivity field - will estimate fall velocity using empirical relations
   call get_expected_radar_ref(state_vector, location, refl, istatus)
   if (istatus /= 0) then
      precip_fall_speed = missing_r8
      return
   endif
   call interpolate(state_vector, location, KIND_DENSITY, rho, istatus)
   if (istatus /= 0) then
      precip_fall_speed = missing_r8
      return
   endif
   precip_fall_speed = dbztowt(refl, rho, missing_r8)
else if (microphysics_type < 0) then
   ! User requested setting fall velocity to zero - use with caution
   precip_fall_speed = 0.0_r8
else
   ! Couldn't manage to compute a fall velocity
   precip_fall_speed = missing_r8
   istatus = 2
endif


end subroutine get_expected_fall_velocity

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Radar reflectivity
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine read_radar_ref(obsvalue, refkey)

! Main read subroutine for radar reflectivity observations.
! Reflectivity obs have no auxiliary data to read, but this routine
! may optionally alter the observation value at run time.

real(r8),         intent(inout)        :: obsvalue
integer,          intent(out)          :: refkey


if ( .not. module_initialized ) call initialize_module

! Unused, but set to a known value.
refkey = 0

! Alter observation value, if namelist settings request it.
if ((apply_ref_limit_to_obs) .and. &
    (obsvalue < reflectivity_limit_obs) .and. (obsvalue /= missing_r8)) then
   obsvalue = lowest_reflectivity_obs
endif

end subroutine read_radar_ref

!----------------------------------------------------------------------

subroutine get_expected_radar_ref(state_vector, location, ref, istatus)

! The main forward operator routine for radar reflectivity observations.

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: ref
integer,             intent(out) :: istatus

! Given a location and the state vector from one of the ensemble members,
! compute the model-predicted radar reflectivity that would be observed
! at that location.  The returned value is in dBZ.

! If apply_ref_limit_to_fwd_op, reflectivity values which are below
! reflectivity_limit_fwd_op will be set to lowest_reflectivity_fwd_op.

! "interpolate()" ultimately calls model_mod routine "model_interpolate()"
! to get model values of qr, qg, qs, rho, and temp at the ob location. Then
! the routine "get_LK_reflectivity()" is called to compute the radar reflectivity
! factor value, Z, that corresponds to the hydrometeor and thermodynamic values.

real(r8)      :: qr, qg, qs, rho, temp
real(r8)      :: debug_location(3)
logical       :: debug = .false.  ! set to .true. to enable debug printout
logical, save :: first_time = .true.

if ( .not. module_initialized ) call initialize_module

! Start with known values before calling interpolate routines.
qr   = 0.0_r8
qg   = 0.0_r8
qs   = 0.0_r8
rho  = 0.0_r8
temp = 0.0_r8

! If the model can return radar reflectivity data directly, give it a chance
! to do so.  Otherwise, compute the various fields individually and then do
! the computation here.  Note that the computation here is accurate only
! for the simple single-moment microphysics schemes (e.g., Kessler or Lin).

! Try to draw from state vector first
call interpolate(state_vector, location, KIND_RADAR_REFLECTIVITY, ref, istatus)
if (istatus /= 0) then

   ! If the user explicitly wanted to interpolate in the field, try to complain
   ! if it could not.  Note that the interp could fail for other reasons.
   if (microphysics_type == 3 .or. microphysics_type == 5) then
      ! Could return a specific istatus code here to indicate this condition.
      if (first_time) then
         call error_handler(E_MSG,'get_expected_radar_ref', &
                            'interpolate failed. Reflectivity may NOT be in state vector', '', '', '')
         first_time = .false.
      endif
      return
   endif

   if (microphysics_type == 1 .or. microphysics_type == 2) then

      call interpolate(state_vector, location, KIND_RAINWATER_MIXING_RATIO, &
                       qr, istatus)
      if (istatus /= 0) then
         ref = missing_r8
         return
      endif

      if (microphysics_type == 2) then
         ! Also need some ice vars
         call interpolate(state_vector, location, KIND_GRAUPEL_MIXING_RATIO, &
                          qg, istatus)
         if (istatus /= 0) then
            ref = missing_r8
            return
         endif

         call interpolate(state_vector, location, KIND_SNOW_MIXING_RATIO, &
                          qs, istatus)
         if (istatus /= 0) then
            ref = missing_r8
            return
         endif
      endif
      call interpolate(state_vector, location, KIND_DENSITY, rho, istatus)
      if (istatus /= 0) then
         ref = missing_r8
         return
      endif

      call interpolate(state_vector, location, KIND_TEMPERATURE, temp, istatus)
      if (istatus /= 0) then
         ref = missing_r8
         return
      endif

      call get_LK_reflectivity(qr, qg, qs, rho, temp, ref)

      ! Always convert to dbz.  Make sure the value, before taking the logarithm,
      ! is always slightly positive.
      ! tiny() is a fortran intrinsic function that is > 0 by a very small amount.

      ref = 10.0_r8 * log10(max(tiny(ref), ref))
   else
      ! not in state vector and not Lin et al or Kessler so can't do reflectivity
      ref = missing_r8
   endif
endif

if ((apply_ref_limit_to_fwd_op) .and. &
    (ref < reflectivity_limit_fwd_op) .and. (ref /= missing_r8)) then
   ref = lowest_reflectivity_fwd_op
endif

! Do not return a missing data value with a successful return code.
if (ref == missing_r8 .and. istatus == 0) then
   istatus = 1
endif

if (debug) then
   debug_location = get_location(location)
   print *
   print *, 'obs location (deg): ', debug_location(1),         &
                                    debug_location(2),         debug_location(3)
   print *, 'obs location (rad): ', debug_location(1)*deg2rad, &
                                    debug_location(2)*deg2rad, debug_location(3)
   print *, 'interpolated qr: ', qr
   print *, 'interpolated qg: ', qg
   print *, 'interpolated qs: ', qs
   print *, 'interpolated rho: ', rho
   print *, 'interpolated temp: ', temp
   print *, 'final reflectivity: ', ref
   print *, 'istatus: ', istatus
endif

end subroutine get_expected_radar_ref

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Helper routines
!----------------------------------------------------------------------
!----------------------------------------------------------------------

subroutine get_LK_reflectivity(qr, qg, qs, rho, temp, ref)

! Computes the equivalent radar reflectivity factor in mm^6 m^-3 for
! simple single-moment microphysics schemes such as the Kessler and
! Lin et al. schemes.  (Note:  the equivalent reflectivity factor is usually
! called simply "reflectivity" throughout this code.)  For more details
! about the computations, see the initialize_constants subroutine and
! the references below.

real(r8), intent(in)  :: qr, qg, qs ! rain,graupel,snow mixing ratios (kg kg^-1)
real(r8), intent(in)  :: rho        ! air density (kg m^-3)
real(r8), intent(in)  :: temp       ! air temperature (K)
real(r8), intent(out) :: ref        ! equivalent reflectivity factor (mm^6 m^-3)

! References: Ferrier, 1994 (JAS, 249-280)
!             Gilmore et al., 2004 (MWR, 2610-2627)
!             Lin et al., 1983 (JCAM, 1065-1092)
!             Smith 1984 (JCAM, 1258-1260)
!             Smith at al., 1975 (JAM, 1156-1165)
!             Caya, "Radar observations in DART" (DART subversion repository)

real(r8) :: precip

if ( .not. module_initialized ) call initialize_module

ref = 0.0_r8

! RAIN
if ( qr >= 1.0e-6_r8 ) then
   precip = rho * qr
   ref = ref + param_refl_r * (precip**1.75_r8)
endif

! HAIL / GRAUPEL
! The exponent 1.6625 is 1.75*0.95.  The 0.95 factor is included as an
! approximation for Mie scattering (Smith et al. 1975).  This approximation
! is appropriate for a 10-cm wavelength radar.

if ( qg >= 1.0e-6_r8 ) then
    precip = rho * qg
    if (.not. allow_wet_graupel .or. temp < 273.15_r8) then
       ref = ref + param_refl_dry_g * (precip**1.75_r8)
    else
       ref = ref + param_refl_wet_g * (precip**1.6625_r8)
    endif
endif

! SNOW
if ( qs >= 1.0e-6_r8 ) then
   precip = rho * qs
   if ( temp < 273.15_r8 ) then
      ref = ref + param_refl_dry_s * (precip**1.75_r8)
   else
      ref = ref + param_refl_wet_s * (precip**1.75_r8)
   endif
endif

end subroutine get_LK_reflectivity

!----------------------------------------------------------------------

subroutine get_LK_precip_fall_speed(qr, qg, qs, rho, temp, precip_fall_speed)

! Computes power-weighted precipitation fall speed in m s^-1 for simple single-
! moment microphysics schemes such as the Kessler and Lin et al. schemes.
! For more details, see the initialize_constants subroutine and the
! references below.

real(r8), intent(in)  :: qr, qg, qs        ! rain,graupel,snow mixing ratios (kg kg^-1)
real(r8), intent(in)  :: rho               ! air density (kg m^-3)
real(r8), intent(in)  :: temp              ! air temperature (K)
real(r8), intent(out) :: precip_fall_speed ! power-weighted precip. fall speed (m s^-1)

! References: Ferrier, 1994 (JAS, 249-280)
!             Gilmore et al., 2004 (MWR, 2610-2627)
!             Lin et al., 1983 (JCAM, 1065-1092)
!             Smith 1984 (JCAM, 1258-1260)
!             Smith at al., 1975 (JAM, 1156-1165)
!             Caya, "Radar observations in DART" (DART subversion repository)

! alpha is the adjustment for air density in the emperical
! dropsize-fall speed equation
real(r8) :: precip_r, precip_s, precip_g, alpha, ref

if ( .not. module_initialized ) call initialize_module

precip_r = rho * qr
precip_s = rho * qs
precip_g = rho * qg
alpha    = sqrt(param_rhos0/rho)

precip_fall_speed = 0.0_r8

! RAIN
if (qr >= 1.0e-6_r8) then
   precip_fall_speed = precip_fall_speed + alpha * param_fs_r * (precip_r**param_powr)
endif

! HAIL/GRAUPEL
if (qg >= 1.0e-6_r8) then
   if (.not. allow_wet_graupel .or. temp < 273.15_r8) then
      precip_fall_speed = precip_fall_speed + sqrt(param_e/rho) * &
                          param_fs_dry_g * (precip_g**param_powg_dry)
   else
      precip_fall_speed = precip_fall_speed + sqrt(param_e/rho) * &
                          param_fs_wet_g * ((precip_g/(PI*rho_graupel))**param_powg_wet)
   endif
endif

! SNOW
if (qs >= 1.0e-6_r8) then
   if ( temp < 273.15_r8 ) then
      precip_fall_speed = precip_fall_speed + alpha * param_fs_dry_s * &
                          (precip_s**param_pows)
   else
      precip_fall_speed = precip_fall_speed + alpha * param_fs_wet_s * &
                          (precip_s**param_pows)
   endif
endif

if (precip_fall_speed > 0.0_r8) then
   call get_LK_reflectivity(qr, qg, qs, rho, temp, ref)
   if (ref > 0.0_r8) then
      precip_fall_speed = precip_fall_speed/ref
   else
      precip_fall_speed = 0.0_r8
   endif
endif

end subroutine get_LK_precip_fall_speed

!----------------------------------------------------------------------

function dbztowt(rf, rho, spval)

! Convert reflectivity (in DBZ, not Z) to terminal fall speed.
! (Code from the pyncommas system - author D. Dowell)

real(r8), intent(in)  :: rf           ! reflectivity (dBZ)
real(r8), intent(in)  :: rho          ! density (km/m**3)
real(r8), intent(in)  :: spval        ! bad/missing data flag
real(r8)              :: dbztowt

! Local vars
real(r8) :: refl         ! reflectivity (Z)

if ( (rf == spval) .or. (rho == spval) ) then
   dbztowt = spval
else
   ! Convert back to Z for this calculation.
   refl = 10.0**(0.1*rf)
   ! Original code used opposite sign - be careful if updating.
   dbztowt = 2.6 * refl**0.107 * (1.2/rho)**0.4
endif

end function dbztowt

!----------------------------------------------------------------------

subroutine initialize_constants()

! Initialize module global constants.

! IMPORTANT: Uses namelist values, so this routine cannot be called until
! after the namelist has been read.

! NOTE: gravity is currently hardcoded here.  We should find a way to let the
! model have input if it uses a slightly different value for G, or if it is
! working on a different planet with an entirely different set of constants.
! Question:  how much impact on the results does changing G have?
!
! Most of the constants below are used for the computation of reflectivity and
! power-weighted precipitation fall speed from the model state.  Only simple
! single-moment microphysics schemes, such as the Kessler and Lin et al.
! schemes, are currently supported.  For these schemes, rain, snow, and
! graupel/hail are assumed to have inverse exponential size distributions:
!
!    n(D)=n0*exp(-lambda*D),
!
! where D is the particle diameter, n is the number of particles per unit
! volume and per particle size interval, n0 is the intercept parameter, and
! lambda is the slope parameter.  Lambda is a function of the model-predicted
! hydrometeor mixing ratio and air density.
!
! For Rayleigh scattering from a spherical raindrop, the reflectivity is
! proportional to the 6th moment of the raindrop's diameter.  The basic form of
! the complicated expressions below comes from integrating this relationship
! between reflectivity and diameter over the entire distribution of hydrometeor
! sizes.  Complications arise because not all hydrometeors are spherical, and
! returned power depends significantly on whether hydrometeors have a wet or
! dry surface.  In addition, for large hailstones, Mie scattering rather than
! Rayleigh scattering must be considered.
!
! References: Ferrier, 1994 (JAS, 249-280)
!             Gilmore et al., 2004 (MWR, 2610-2627)
!             Lin et al., 1983 (JCAM, 1065-1092)
!             Smith 1984 (JCAM, 1258-1260)
!             Smith at al., 1975 (JAM, 1156-1165)
!             Caya, "Radar observations in DART" (DART subversion repository)


! In general, the value used for gravity here should match the value used
! for gravity in the model.
param_gravity  = 9.81_r8        ! Acceleration of gravity (m s^-2)
param_a        = 8.42e20_r8
param_b        = 0.8_r8
param_c        = 4.84e18_r8
param_d        = 0.25_r8
param_CD       = 0.6_r8
param_rhos0    = 1.0_r8
param_e        = 4.0_r8*param_gravity*rho_graupel/(3.0_r8*param_CD)

param_gam7b    = 3376.92_r8
param_gam7d    = 1155.38_r8
param_gam7f    = 1871.25_r8
param_powr     = (7.0_r8 + param_b)/4.0_r8
param_pows     = (7.0_r8 + param_d)/4.0_r8
param_powg_dry = (7.0_r8 + 0.5_r8) /4.0_r8
param_powg_wet = 1.7875_r8


! In the expressions for power-weighted precipitation fall speed for each
! hydrometeor category, the following parameters are computed from the
! constants that do not vary in time and space.  These equations are rather
! complicated, so refer to "Radar observations in DART" by A. Caya for details.
! (A pdf of this paper is in the DART subversion repository.)
! The 0.95 exponenent in the equation for param_fs_wet_g is an approximation
! for the effects of Mie scattering (Smith et al. 1975).  This approximation
! is appropriate for a 10-cm wavelength radar.

param_fs_r     = n0_rain * param_a * param_gam7b / &
                 (PI * rho_rain * n0_rain)**param_powr

param_fs_wet_s = n0_snow * param_c * param_gam7d / &
                 (PI * rho_snow * n0_snow)**param_pows

param_fs_dry_s = dielectric_factor * ((rho_snow/rho_rain)**2.0_r8) * &
                 param_fs_wet_s

param_fs_wet_g = ((7.2e20_r8)**0.95_r8) * param_gam7f / &
                 (720.0_r8 * (n0_graupel**0.8375_r8))

param_fs_dry_g = 1.0e18_r8 * dielectric_factor *                               &
                 ((rho_graupel/rho_rain)**2.0_r8) * n0_graupel * param_gam7f / &
                 (PI * rho_graupel * n0_graupel)**param_powg_dry

! In the expressions for reflectivity for each hydrometeor category, the
! following parameters are computed from the constants that do not vary in time
! and space.  Computing these parameters now means that the equations in the
! get_LK_reflectivity subroutine will have the following simple form:
!
!   ref = param_refl_r * (rho*qr)**1.75.
!
! The 0.95 exponenent in the equation for param_refl_wet_g is an approximation
! for the effects of Mie scattering (Smith et al. 1975).  This approximation is
! appropriate for a 10-cm wavelength radar.

param_refl_r     = 7.2e20_r8 / (((PI*rho_rain)**1.75_r8)*(n0_rain**0.75_r8))

param_refl_wet_s = 7.2e20_r8 / (((PI*rho_snow)**1.75_r8)*(n0_snow**0.75_r8))

param_refl_dry_s = dielectric_factor * ((rho_snow/rho_rain)**2.0_r8) * &
                 param_refl_wet_s

param_refl_wet_g = (7.2e20_r8/(((PI*rho_graupel)**1.75_r8) * &
                 (n0_graupel**0.75_r8)))**0.95_r8

param_refl_dry_g = dielectric_factor * ((rho_graupel/rho_rain)**2.0_r8) * &
                 7.2e20_r8 / (((PI*rho_graupel)**1.75_r8)*(n0_graupel**0.75_r8))



end subroutine initialize_constants

!----------------------------------------------------------------------

subroutine print_constants()

! Log the constants set in the code.
! Prints to both the log file and standard output.

! The values in this list which are also in the namelist will have their
! values written by the write(nml=) code, but this routine includes all
! the fixed constants so they are written in one place, both to standard
! output and the log file. Using the correct values is critical to doing
! the appropriate computation, so some duplication is probably a good thing.

write(msgstring, *) 'Constants used in the obs_def_radar module:'
call error_handler(E_MSG,'', msgstring, '', '', '')

call pr_con(dielectric_factor , "dielectric_factor" )
call pr_con(n0_rain           , "n0_rain"           )
call pr_con(n0_graupel        , "n0_graupel"        )
call pr_con(n0_snow           , "n0_snow"           )
call pr_con(rho_rain          , "rho_rain"          )
call pr_con(rho_graupel       , "rho_graupel"       )
call pr_con(rho_snow          , "rho_snow"          )
call pr_con(param_gravity     , "param_gravity"     )
call pr_con(param_a           , "param_a"           )
call pr_con(param_b           , "param_b"           )
call pr_con(param_c           , "param_c"           )
call pr_con(param_d           , "param_d"           )
call pr_con(param_CD          , "param_CD"          )
call pr_con(param_rhos0       , "param_rhos0"       )
call pr_con(param_e           , "param_e"           )
call pr_con(param_gam7b       , "param_gam7b"       )
call pr_con(param_gam7d       , "param_gam7d"       )
call pr_con(param_gam7f       , "param_gam7f"       )
call pr_con(param_powr        , "param_powr"        )
call pr_con(param_pows        , "param_pows"        )
call pr_con(param_powg_dry    , "param_powg_dry"    )
call pr_con(param_powg_wet    , "param_powg_wet"    )
call pr_con(param_fs_r        , "param_fs_r"        )
call pr_con(param_fs_wet_s    , "param_fs_wet_s"    )
call pr_con(param_fs_dry_s    , "param_fs_dry_s"    )
call pr_con(param_fs_wet_g    , "param_fs_wet_g"    )
call pr_con(param_fs_dry_g    , "param_fs_dry_g"    )
call pr_con(param_refl_r      , "param_refl_r"        )
call pr_con(param_refl_wet_s  , "param_refl_wet_s"    )
call pr_con(param_refl_dry_s  , "param_refl_dry_s"    )
call pr_con(param_refl_wet_g  , "param_refl_wet_g"    )
call pr_con(param_refl_dry_g  , "param_refl_dry_g"    )

end subroutine print_constants

!----------------------------------------------------------------------

subroutine pr_con(c_val, c_str)

! Utility routine to print a string and value

real(r8),         intent(in) :: c_val
character(len=*), intent(in) :: c_str

write(msgstring, "(A30,A,ES28.8)") c_str, " = ", c_val
call error_handler(E_MSG,'', msgstring, '', '', '')

end subroutine pr_con

!----------------------------------------------------------------------

subroutine velkey_out_of_range(velkey)

! Range check velkey and trigger a fatal error if larger than allocated array.

integer, intent(in) :: velkey

! fine -- no problem.
if (velkey <= max_radial_vel_obs) return

! Bad news.  Tell the user.
write(msgstring, *) 'velkey (',velkey,') exceeds max_radial_vel_obs (', &
                     max_radial_vel_obs,')'
call error_handler(E_MSG,'set_radial_vel', msgstring, '', '', '')
call error_handler(E_ERR,'set_radial_vel', &
                   'Increase max_radial_vel_obs in namelist', &
                   source, revision, revdate)

end subroutine velkey_out_of_range

!----------------------------------------------------------------------

subroutine check_namelist_limits(apply_ref_limit_to_obs, &
   reflectivity_limit_obs, lowest_reflectivity_obs, apply_ref_limit_to_fwd_op,&
   reflectivity_limit_fwd_op, lowest_reflectivity_fwd_op)

! Consistency warning; print a message if the thresholds and lower values
! are going to be used and are different.

logical,  intent(in) :: apply_ref_limit_to_obs
real(r8), intent(in) :: reflectivity_limit_obs
real(r8), intent(in) :: lowest_reflectivity_obs
logical,  intent(in) :: apply_ref_limit_to_fwd_op
real(r8), intent(in) :: reflectivity_limit_fwd_op
real(r8), intent(in) :: lowest_reflectivity_fwd_op

! The point here is to gently remind the user if they are setting different
! limits on the actual observation values and the forward operator, since
! that may be what they intend, but it isn't something they should be doing
! by mistake.  But we don't want to be annoying, so this code only prints
! informative messages to the log file and does not stop with an error.

! If neither limit is being enforced, return silently.
if (.not. apply_ref_limit_to_obs .and. .not. apply_ref_limit_to_fwd_op) return

! If both are on, and the limits and set-to values are the same, fine also.
if (apply_ref_limit_to_obs .and. apply_ref_limit_to_fwd_op) then
   if ((reflectivity_limit_obs  == reflectivity_limit_fwd_op) .and. &
       (lowest_reflectivity_obs == lowest_reflectivity_fwd_op)) return
endif

! Either only one of the limits is on, and/or the limits or set-to
! values do not match.  Print something to the log file to note that they
! are not the same.
if (apply_ref_limit_to_obs) then
   write(msgstring, *) 'reflectivity obs values less than ', &
      reflectivity_limit_obs, 'will be set to', lowest_reflectivity_obs
else
   write(msgstring, *) 'reflectivity obs values will be processed unchanged'
endif
call error_handler(E_MSG,'check_namelist_limits', msgstring, '', '', '')

if (apply_ref_limit_to_fwd_op) then
   write(msgstring, *) 'reflectivity forward operator values less than ', &
      reflectivity_limit_fwd_op, 'will be set to', lowest_reflectivity_fwd_op
else
   write(msgstring, *) 'reflectivity forward operator values will be processed unchanged'
endif
call error_handler(E_MSG,'check_namelist_limits', msgstring, '', '', '')

end subroutine check_namelist_limits

!----------------------------------------------------------------------

end module obs_def_radar_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_radar_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
!No module code needed for ../../../obs_def/obs_def_metar_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_dew_point_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_dew_point_mod

use        types_mod, only : r8, missing_r8, t_kelvin
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, set_location, get_location , write_location, &
                             read_location
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_SURFACE_PRESSURE, KIND_VAPOR_MIXING_RATIO, KIND_PRESSURE

implicit none
private

public :: get_expected_dew_point

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module



subroutine get_expected_dew_point(state_vector, location, key, td, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: td               ! dewpoint (K)
integer,             intent(out) :: istatus

integer  :: ipres
real(r8) :: qv                            ! water vapor mixing ratio (kg/kg)
real(r8) :: e_mb                          ! water vapor pressure (mb)
real(r8), PARAMETER :: e_min = 0.001_r8   ! threshold for minimum vapor pressure (mb),
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: p_mb                          ! pressure (mb)

character(len=129) :: errstring

if ( .not. module_initialized ) call initialize_module

if(key == 1) then
   ipres = KIND_PRESSURE
elseif(key == 2) then
   ipres = KIND_SURFACE_PRESSURE
else
   write(errstring,*)'key has to be 1 (upper levels) or 2 (2-meter), got ',key
   call error_handler(E_ERR,'get_expected_dew_point', errstring, &
        source, revision, revdate)
endif

call interpolate(state_vector, location, ipres, p_Pa, istatus)
if (istatus /= 0) then
   td = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_VAPOR_MIXING_RATIO, qv, istatus)
if (istatus /= 0) then
   td = missing_r8
   return
endif
if (qv < 0.0_r8 .or. qv >= 1.0_r8) then
   td = missing_r8
   if (istatus == 0) istatus = 1
   return
endif

!------------------------------------------------------------------------------
!  Compute water vapor pressure.
!------------------------------------------------------------------------------

p_mb = p_Pa * 0.01_r8

e_mb = qv * p_mb / (0.622_r8 + qv)
e_mb = max(e_mb, e_min)

!------------------------------------------------------------------------------
!  Use Bolton's approximation to compute dewpoint.
!------------------------------------------------------------------------------

td = t_kelvin + (243.5_r8 / ((17.67_r8 / log(e_mb/6.112_r8)) - 1.0_r8) )

end subroutine get_expected_dew_point

!----------------------------------------------------------------------------

end module obs_def_dew_point_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_dew_point_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_rel_humidity_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_rel_humidity_mod

use        types_mod, only : r8, missing_r8, L_over_Rv
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, set_location, get_location, write_location, &
                             read_location, vert_is_pressure
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_TEMPERATURE, KIND_PRESSURE, KIND_VAPOR_MIXING_RATIO

implicit none
private

public :: get_expected_relative_humidity

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save       :: module_initialized   = .false.
logical, save       :: first_time_warn_low  = .true.
logical, save       :: first_time_warn_high = .true.
character(len=64)   :: msgstring
real(r8), parameter :: MIN_VALUE = 1.0e-9
real(r8), parameter :: MAX_VALUE = 1.1

contains

!----------------------------------------------------------------------

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module

!----------------------------------------------------------------------------

subroutine get_expected_relative_humidity(state_vector, location, rh, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: rh     ! relative humidity (fraction)
integer,             intent(out) :: istatus

real(r8) :: qvap, tmpk, xyz(3), pres, es, qsat

if ( .not. module_initialized ) call initialize_module

!  interpolate the mixing ratio to the location
call interpolate(state_vector, location, KIND_VAPOR_MIXING_RATIO, qvap, istatus)
if (istatus /= 0 .or. qvap < 0.0_r8) then
   if (istatus == 0) then
      qvap = epsilon(0.0_r8)
   else
      rh = missing_r8
      if (istatus == 0) istatus = 99
      return
   endif
endif

!  interpolate the temperature to the desired location
call interpolate(state_vector, location, KIND_TEMPERATURE, tmpk, istatus)
if (istatus /= 0 .or. tmpk <= 0.0_r8) then
   rh = missing_r8
   if (istatus == 0) istatus = 99
   return
endif

!  interpolate the pressure, if observation location is not pressure
if ( vert_is_pressure(location) ) then
   xyz = get_location(location)
   pres = xyz(3)
else
   ! pressure comes back in pascals (not hPa or mb)
   call interpolate(state_vector, location, KIND_PRESSURE, pres, istatus)
   if (istatus /= 0 .or. pres <= 0.0_r8 .or. pres >= 120000.0_r8)  then
      rh = missing_r8
      if (istatus == 0) istatus = 99
      return
   endif
endif

!  Compute the rh
es   = 611.0_r8 * exp(L_over_Rv * (1.0_r8 / 273.0_r8 - 1.0_r8 / tmpk))
qsat = 0.622_r8 * es / (pres - es)
rh   = qvap / qsat

!  Check for unreasonable values and return limits
if (rh < MIN_VALUE) then
   if (first_time_warn_low) then
      write(msgstring, '(A,F12.6)') 'values lower than low limit detected, e.g.', rh
      call error_handler(E_MSG,'get_expected_relative_humidity', msgstring,      &
                         text2='all values lower than 1e-9 will be set to 1e-9', &
                         text3='this message will only print once')
      first_time_warn_low = .false.
   endif
   rh = MIN_VALUE
endif

if (rh > MAX_VALUE) then
   if (first_time_warn_high) then
      write(msgstring, '(A,F12.6)') 'values higher than high limit detected, e.g.', rh
      call error_handler(E_MSG,'get_expected_relative_humidity', msgstring,      &
                         text2='all values larger than 1.1 will be set to 1.1', &
                         text3='this message will only print once')
      first_time_warn_high = .false.
   endif
   rh = MAX_VALUE
endif

return
end subroutine get_expected_relative_humidity

!----------------------------------------------------------------------------

end module obs_def_rel_humidity_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_rel_humidity_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_altimeter_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_altimeter_mod

use        types_mod, only : r8, missing_r8
use    utilities_mod, only : register_module
use     location_mod, only : location_type
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_SURFACE_PRESSURE, KIND_SURFACE_ELEVATION

implicit none
private

public :: get_expected_altimeter, compute_altimeter

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module


subroutine get_expected_altimeter(state_vector, location, altimeter_setting, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: altimeter_setting     ! altimeter (hPa)
integer,             intent(out) :: istatus

real(r8) :: psfc                ! surface pressure value   (Pa)
real(r8) :: hsfc                ! surface elevation level  (m above SL)

if ( .not. module_initialized ) call initialize_module

!  interpolate the surface pressure to the desired location
call interpolate(state_vector, location, KIND_SURFACE_PRESSURE, psfc, istatus)
if (istatus /= 0) then
   altimeter_setting = missing_r8
   return
endif

!  interpolate the surface elevation to the desired location
call interpolate(state_vector, location, KIND_SURFACE_ELEVATION, hsfc, istatus)
if (istatus /= 0) then
   altimeter_setting = missing_r8
   return
endif

!  Compute the altimeter setting given surface pressure and height, altimeter is hPa
altimeter_setting = compute_altimeter(psfc * 0.01_r8, hsfc)

if (altimeter_setting < 880.0_r8 .or. altimeter_setting >= 1100.0_r8) then
   altimeter_setting = missing_r8
   if (istatus == 0) istatus = 1
   return
endif

return
end subroutine get_expected_altimeter


function compute_altimeter(psfc, hsfc)

real(r8), parameter :: k1 = 0.190284_r8
real(r8), parameter :: k2 = 8.4228807E-5_r8

real(r8), intent(in) :: psfc  !  (hPa)
real(r8), intent(in) :: hsfc  !  (m above MSL)

real(r8) :: compute_altimeter !  (hPa)

compute_altimeter = ((psfc - 0.3_r8) ** k1 + k2 * hsfc) ** (1.0_r8 / k1)

return
end function compute_altimeter

!----------------------------------------------------------------------------

end module obs_def_altimeter_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_altimeter_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_gps_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_gps_mod

use        types_mod, only : r8, missing_r8, RAD2DEG, DEG2RAD, PI
use    utilities_mod, only : register_module, error_handler, E_ERR, &
                             nmlfileunit, check_namelist_read,      &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, set_location, get_location, &
                             vert_is_height, &
                             VERTISHEIGHT
use  assim_model_mod, only : interpolate

use     obs_kind_mod, only : KIND_TEMPERATURE, KIND_SPECIFIC_HUMIDITY, &
                             KIND_PRESSURE

implicit none
private

public :: set_gpsro_ref, get_gpsro_ref, write_gpsro_ref, read_gpsro_ref, &
          get_expected_gpsro_ref, interactive_gpsro_ref

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

! Storage for the special information required for GPS RO observations
!

! Because we are currently only generating one observation type
! (GPSRO_REFRACTIVITY), there must be enough of these to cover all gps
! obs in all obs_seq files that are read in (e.g. for obs_diag if you
! cover multiple days or weeks, you must have enough room for all of them.)
! the local operator needs none of this additional info; the best approach
! would be to keep a single KIND_GPSRO, but make 2 observation types.
! the local has no additional metadata; the nonlocal needs one of these
! allocated and filled in.
integer :: max_gpsro_obs = 100000

type gps_nonlocal_type
   private
   character(len=6) :: gpsro_ref_form
   real(r8)         :: ray_direction(3)
   real(r8)         :: rfict
   real(r8)         :: step_size
   real(r8)         :: ray_top
end type gps_nonlocal_type

type(gps_nonlocal_type), allocatable :: gps_data(:)

namelist /obs_def_gps_nml/ max_gpsro_obs

character(len=129) :: string1, string2
integer  :: ii
integer  :: keycount

contains

!------------------------------------------------------------------------------


  subroutine initialize_module
!------------------------------------------------------------------------------
!
! initialize global gps private key number and allocate space for obs data
integer :: rc, iunit

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

! global count of all gps observations from any input file
keycount = 0

! Read the namelist entry
call find_namelist_in_file("input.nml", "obs_def_gps_nml", iunit)
read(iunit, nml = obs_def_gps_nml, iostat = rc)
call check_namelist_read(iunit, rc, "obs_def_gps_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_gps_nml)
if (do_nml_term()) write(     *     , nml=obs_def_gps_nml)

! find max number of gps obs which can be stored, and initialize type
allocate(gps_data(max_gpsro_obs), stat = rc)
if (rc /= 0) then
   write(string1, *) 'initial allocation failed for gps observation data,', &
                       'itemcount = ', max_gpsro_obs
   call error_handler(E_ERR,'initialize_module', string1, &
                      source, revision, revdate)
endif

end subroutine initialize_module



 subroutine set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)
!------------------------------------------------------------------------------
!
! increment key and set all private data for this observation

integer,          intent(out) :: gpskey
real(r8),         intent(in)  :: nx, ny, nz, rfict0, ds, htop
character(len=6), intent(in)  :: subset0

if ( .not. module_initialized ) call initialize_module

keycount = keycount + 1
gpskey = keycount

if(gpskey > max_gpsro_obs) then
   write(string1, *) 'key (',gpskey,') exceeds max_gpsro_obs (',max_gpsro_obs,')'
   string2 = 'Increase max_gpsro_obs in input.nml &obs_def_gps_nml namelist.'
   call error_handler(E_ERR,'read_gpsro_ref', string1, &
                      source, revision, revdate, text2=string2)
endif

gps_data(gpskey)%ray_direction(1) = nx
gps_data(gpskey)%ray_direction(2) = ny
gps_data(gpskey)%ray_direction(3) = nz
gps_data(gpskey)%gpsro_ref_form   = subset0

gps_data(gpskey)%rfict     = rfict0
gps_data(gpskey)%step_size = ds
gps_data(gpskey)%ray_top   = htop

end subroutine set_gpsro_ref


 subroutine get_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)
!------------------------------------------------------------------------------
!
! return all private data for this observation

integer,          intent(in)  :: gpskey
real(r8),         intent(out) :: nx, ny, nz, rfict0, ds, htop
character(len=6), intent(out) :: subset0

if ( .not. module_initialized ) call initialize_module

if (gpskey < 1 .or. gpskey > keycount) then
   write(string1, *) 'key (',gpskey,') out of valid range (1<=key<=',keycount,')'
   call error_handler(E_ERR,'get_gpsro_ref', string1, &
                      source, revision, revdate)
endif

nx = gps_data(gpskey)%ray_direction(1)
ny = gps_data(gpskey)%ray_direction(2)
nz = gps_data(gpskey)%ray_direction(3)
subset0 = gps_data(gpskey)%gpsro_ref_form

rfict0 = gps_data(gpskey)%rfict
ds     = gps_data(gpskey)%step_size
htop   = gps_data(gpskey)%ray_top

end subroutine get_gpsro_ref



 subroutine write_gpsro_ref(gpskey, ifile, fform)
!------------------------------------------------------------------------------
!

integer,          intent(in)           :: gpskey, ifile
character(len=*), intent(in), optional :: fform


if ( .not. module_initialized ) call initialize_module

! Write the 5 character identifier for verbose formatted output
! Write out the obs_def key for this observation
if (ascii_file_format(fform)) then
   write(ifile,11) gpskey
   write(ifile, *) gps_data(gpskey)%rfict, gps_data(gpskey)%step_size, &
                   gps_data(gpskey)%ray_top, &
                  (gps_data(gpskey)%ray_direction(ii), ii=1, 3), &
                   gps_data(gpskey)%gpsro_ref_form
11  format('gpsroref', i8)
else
   write(ifile) gpskey
   write(ifile) gps_data(gpskey)%rfict, gps_data(gpskey)%step_size, &
                gps_data(gpskey)%ray_top, &
               (gps_data(gpskey)%ray_direction(ii), ii=1, 3), &
                gps_data(gpskey)%gpsro_ref_form
endif

end subroutine write_gpsro_ref



 subroutine read_gpsro_ref(gpskey, ifile, fform)
!------------------------------------------------------------------------------
!
! Every GPS observation has its own (metadata) gpskey.
! When you read multiple gps observation sequence files, it is necessary
! to track the total number of metadata gpskeys read, not just the number
! in the current file.
!

integer,          intent(out)          :: gpskey
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

integer :: keyin    ! the metadata key in the current obs sequence

real(r8) :: nx, ny, nz, rfict0, ds, htop
character(len=6) :: subset0
character(len=8) :: header

if ( .not. module_initialized ) call initialize_module

if (ascii_file_format(fform)) then
   read(ifile, FMT='(a8, i8)') header, keyin    ! throw away keyin
   if(header /= 'gpsroref') then
       call error_handler(E_ERR,'read_gpsro_ref', &
       'Expected header "gpsroref" in input file', source, revision, revdate)
   endif
   read(ifile, *) rfict0, ds, htop, nx, ny, nz, subset0
else
   read(ifile) keyin          ! read and throw away
   read(ifile) rfict0, ds, htop, nx, ny, nz, subset0
endif


! increment key and set all private data for this observation
call set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)

end subroutine read_gpsro_ref


subroutine interactive_gpsro_ref(gpskey)
!----------------------------------------------------------------------
!
! Interactively prompt for the info needed to create a gps refractivity
! observation.  Increments the key number and returns it.

integer, intent(out) :: gpskey

real(r8) :: nx, ny, nz, rfict0, ds, htop
character(len=6) :: subset0
integer :: gpstype


if ( .not. module_initialized ) call initialize_module

!Now interactively obtain reflectivity type information
! valid choices are local or non-local

write(*, *)
write(*, *) 'Beginning to inquire information on reflectivity type.'
write(*, *)

100 continue
write(*, *) 'Enter 1 for local refractivity (GPSREF)'
write(*, *) 'Enter 2 for non-local refractivity/excess phase delay (GPSEXC)'
write(*, *)

read(*,*) gpstype

select case (gpstype)
   case (1)
      subset0 = 'GPSREF'
   case (2)
      subset0 = 'GPSEXC'
   case default
      write(*,*) 'Bad value, must enter 1 or 2'
      goto 100
end select

if (gpstype == 2) then
    ! FIXME:  i have no idea what valid values are for any
   !  of the following items, so i cannot add any error checking or
   !  guidance for the user.

   write(*, *)
   write(*, *) 'Enter X, Y, Z value for ray direction'
   write(*, *)
   read(*,*) nx, ny, nz

   write(*, *)
   write(*, *) 'Enter local curvature radius'
   write(*, *)
   read(*,*) rfict0

   write(*, *)
   write(*, *) 'Enter step size'
   write(*, *)
   read(*,*) ds

   write(*, *)
   write(*, *) 'Enter ray top'
   write(*, *)
   read(*,*) htop
else
   nx = 0.0
   ny = 0.0
   nz = 0.0
   rfict0 = 0.0
   ds = 0.0
   htop = 0.0
endif

! increment key and set all private data for this observation
call set_gpsro_ref(gpskey, nx, ny, nz, rfict0, ds, htop, subset0)

write(*, *)
write(*, *) 'End of specialized section for gps observation data.'
write(*, *) 'You will now have to enter the regular obs information.'
write(*, *)

end subroutine interactive_gpsro_ref

 subroutine get_expected_gpsro_ref(state_vector, location, gpskey, ro_ref, istatus)
!------------------------------------------------------------------------------
!
! Purpose: Calculate GPS RO local refractivity or non_local (integrated)
!          refractivity (excess phase, Sergey Sokolovskiy et al., 2005)
!------------------------------------------------------------------------------
!
! inputs:
!    state_vector:    DART state vector
!
! output parameters:
!    ro_ref: modeled local refractivity (N-1)*1.0e6 or non_local
!            refractivity (excess phase, m)
!            (according to the input data parameter subset)
!    istatus:  =0 normal; =1 outside of domain.
!------------------------------------------------------------------------------
!  Author: Hui Liu
!  Version 1.1: June 15, 2004: Initial version CAM
!
!  Version 1.2: July 29, 2005: revised for new obs_def and WRF
!------------------------------------------------------------------------------
implicit none

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: gpskey
real(r8),            intent(out) :: ro_ref
integer,             intent(out) :: istatus

! local variables

real(r8) :: nx, ny, nz       ! unit tangent direction of ray at perigee
real(r8) :: xo, yo, zo       ! perigee location in Cartesian coordinate

real(r8) :: ref_perigee, ref00, ref1, ref2, dist_to_perigee
real(r8) :: phase
real(r8) :: xx, yy, zz, height1, lat1, lon1, delta_phase1, delta_phase2

integer  :: iter, istatus0
real(r8) :: lon, lat, height, obsloc(3)

if ( .not. module_initialized ) call initialize_module

if ( .not. vert_is_height(location)) then
   write(string1, *) 'vertical location must be height; gps obs key ', gpskey
   call error_handler(E_ERR,'get_expected_gpsro_ref', string1, &
                      source, revision, revdate)
endif

obsloc   = get_location(location)


lon      = obsloc(1)                       ! degree: 0 to 360
lat      = obsloc(2)                       ! degree: -90 to 90
height   = obsloc(3)                       ! (m)

! calculate refractivity at perigee

call ref_local(state_vector, location, height, lat, lon, ref_perigee, istatus0)
! if istatus > 0, the interpolation failed and we should return failure now.
if(istatus0 > 0) then
   istatus = istatus0
   ro_ref = missing_r8
   return
endif

choose: if(gps_data(gpskey)%gpsro_ref_form == 'GPSREF') then
    ! use local refractivity

    ro_ref = ref_perigee * 1.0e6      ! in (N-1)*1.0e6, same with obs

else  ! gps_data(gpskey)%gpsro_ref_form == 'GPSEXC'

    ! otherwise, use non_local refractivity(excess phase delay)

    ! Initialization
    phase = 0.0_r8
    dist_to_perigee =  0.0_r8   ! distance to perigee from a point of the ray

    nx = gps_data(gpskey)%ray_direction(1)
    ny = gps_data(gpskey)%ray_direction(2)
    nz = gps_data(gpskey)%ray_direction(3)

    ! convert location of the perigee from geodetic to Cartesian coordinate

    call geo2carte (height, lat, lon, xo, yo, zo, gps_data(gpskey)%rfict )

    ! currently, use a straight line passing the perigee point as ray model.
    ! later, more sophisticated ray models can be used.
    !
    ! Start the horizontal integrate of the model refractivity along a
    ! straight line path in cartesian coordinate
    !
    ! (x-xo)/a = (y-yo)/b = (z-zo)/c,  (a,b,c) is the line direction

    ref1 = ref_perigee
    ref2 = ref_perigee

    iter = 0
    do

       iter = iter + 1
       dist_to_perigee = dist_to_perigee + gps_data(gpskey)%step_size

       !  integrate to one direction of the ray for one step
       xx = xo + dist_to_perigee * nx
       yy = yo + dist_to_perigee * ny
       zz = zo + dist_to_perigee * nz

       ! convert the location of the point to geodetic coordinates
       ! height(m), lat, lon(deg)

       call carte2geo(xx, yy, zz, height1, lat1, lon1, gps_data(gpskey)%rfict )
       if (height1 >= gps_data(gpskey)%ray_top) exit

       ! get the refractivity at this ray point(ref00)
       call ref_local(state_vector, location, height1, lat1, lon1, ref00, istatus0)
       ! when any point of the ray is problematic, return failure
       if(istatus0 > 0) then
         istatus = istatus0
         ro_ref = missing_r8
         return
       endif

       ! get the excess phase due to this ray interval
       delta_phase1 = (ref1 + ref00) * gps_data(gpskey)%step_size * 0.5_r8

       ! save the refractivity for integration of next ray interval
       ref1 = ref00

       ! integrate to the other direction of the ray
       xx = xo - dist_to_perigee * nx
       yy = yo - dist_to_perigee * ny
       zz = zo - dist_to_perigee * nz

       call carte2geo (xx, yy, zz, height1, lat1, lon1, gps_data(gpskey)%rfict )

       ! get the refractivity at this ray point(ref00)
       call ref_local(state_vector, location, height1, lat1, lon1, ref00, istatus0)
       ! when any point of the ray is problematic, return failure
       if(istatus0 > 0) then
         istatus = istatus0
         ro_ref = missing_r8
         return
       endif

       ! get the excess phase due to this ray interval
       delta_phase2 = (ref2 + ref00) * gps_data(gpskey)%step_size * 0.5_r8

       ! save the refractivity for integration of next ray interval
       ref2 = ref00

       phase = phase + delta_phase1 + delta_phase2
       ! print*, 'phase= ',  phase, delta_phase1, delta_phase2

    end do

    ! finish the integration of the excess phase along the ray

    ro_ref = phase    ! in m

    ! print*, 'xx = ', lon, lat, height, ro_ref

endif choose

! if the original height was too high, for example.  do not return a
! negative or 0 excess phase or refractivity.
if (ro_ref == missing_r8 .or. ro_ref <= 0.0_r8) then
   istatus = 5
   ro_ref = missing_r8
   return
endif

! ended ok, return local refractivity or non-local excess phase accumulated value
istatus = 0

end subroutine get_expected_gpsro_ref



 subroutine ref_local(state_vector, location, height, lat, lon, ref00, istatus0)
!------------------------------------------------------------------------------
!
! Calculate local refractivity at any GPS ray point (height, lat, lon)
!
! inputs:
!    height, lat, lon:  GPS observation location (units: m, degree)
!
! output:
!    ref00: modeled local refractivity at ray point(unit: N-1, ~1.0e-4 to e-6)
!
!------------------------------------------------------------------------------
implicit none

real(r8), intent(in) :: state_vector(:)
real(r8), intent(in) :: lon, lat, height

real(r8), intent(out) :: ref00
integer,  intent(out) :: istatus0

real(r8), parameter::  rd = 287.05_r8, rv = 461.51_r8, c1 = 77.6d-6 , &
                       c2 = 3.73d-1,  rdorv = rd/rv
real(r8) :: lon2, t, q, p, tv, ew
type(location_type) :: location, location2
integer :: which_vert

if ( .not. module_initialized ) call initialize_module

! for integration of GPS ray path beyond the wraparound point
lon2 = lon
if(lon > 360.0_r8 ) lon2 = lon - 360.0_r8
if(lon <   0.0_r8 ) lon2 = lon + 360.0_r8

which_vert = VERTISHEIGHT
location2 = set_location(lon2, lat, height,  which_vert)

! set return values assuming failure, so we can simply return if any
! of the interpolation calls below fail.
istatus0 = 3
ref00 = missing_r8

call interpolate(state_vector, location2,  KIND_TEMPERATURE,       t, istatus0)
if (istatus0 > 0) return
call interpolate(state_vector, location2,  KIND_SPECIFIC_HUMIDITY, q, istatus0)
if (istatus0 > 0) return
call interpolate(state_vector, location2,  KIND_PRESSURE,          p, istatus0)
if (istatus0 > 0) return

!  required variable units for calculation of GPS refractivity
!   t :  Kelvin, from top to bottom
!   q :  kg/kg, from top to bottom
!   p :  mb

p     = p * 0.01_r8      ! to mb

tv    = t * (1.0_r8+(rv/rd - 1.0_r8)*q)         ! virtual temperature
ew    = q * p/(rdorv + (1.0_r8-rdorv)*q )
ref00 = c1*p/t + c2*ew/(t**2)              ! (N-1)

! now we have succeeded, set istatus to good
istatus0 = 0

end subroutine ref_local


 subroutine geo2carte (s1, s2, s3, x1, x2, x3, rfict0)
!------------------------------------------------------------------------------
!
!  Converts geodetical coordinates to cartesian with a reference sphere
!------------------------------------------------------------------------------
!  input parameters:
!   s - geodetical coordinates
!        (height (m), latitude (degree), longitude (degree))
!                     -90 to 90           0 to 360
!  output parameters:
!   x - cartesian coordinates (m) connected with the earth(x, y, z-coordinate)
!------------------------------------------------------------------------------
implicit none
real(r8), intent(in)  :: s1, s2, s3, rfict0    ! units: m
real(r8), intent(out) ::   x1, x2 ,x3
real(r8) :: g3, g4

if ( .not. module_initialized ) call initialize_module

g3 = s1 + rfict0
g4 = g3 * cos(s2*DEG2RAD)
x1 = g4 * cos(s3*DEG2RAD)
x2 = g4 * sin(s3*DEG2RAD)
x3 = g3 * sin(s2*DEG2RAD)

end subroutine geo2carte


 subroutine carte2geo (x1, x2, x3, s1, s2, s3, rfict0)
!------------------------------------------------------------------------------
!
!  Converts cartesian coordinates to geodetical.
!
!   input parameters:
!        x - cartesian coordinates (x, y, z-coordinate, unit: m)
!
!   output parameters:
!        s - geodetical coordinates
!            (height (m), latitude (deg), longitude (deg))
!                          -90 to 90         0 to 360
!------------------------------------------------------------------------------
implicit none
real(r8), intent(in)  :: x1, x2, x3, rfict0
real(r8), intent(out) :: s1, s2, s3

real(r8), parameter :: crcl  = 2.0_r8 * PI, &
                       crcl2 = 4.0_r8 * PI

real(r8) :: rho, sphi, azmth

if ( .not. module_initialized ) call initialize_module

rho   = sqrt (x1**2 + x2**2 + x3**2 )
sphi  = x3/rho
s1    = rho - rfict0
s2    = asin (sphi)
azmth = atan2 (x2, x1)
s3    = mod((azmth + crcl2), crcl)

s2    = s2 * RAD2DEG
s3    = s3 * RAD2DEG

end  subroutine carte2geo

end module obs_def_gps_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_gps_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_vortex_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_vortex_mod

use        types_mod, only : r8, missing_r8, ps0, PI, gravity
use    utilities_mod, only : register_module, error_handler, E_ERR
use     location_mod, only : location_type
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_U_WIND_COMPONENT, KIND_V_WIND_COMPONENT, &
                             KIND_TEMPERATURE, KIND_VERTICAL_VELOCITY, &
                             KIND_RAINWATER_MIXING_RATIO, KIND_DENSITY, &
                             KIND_VORTEX_LAT, KIND_VORTEX_LON, KIND_VORTEX_PMIN, &
                             KIND_VORTEX_WMAX

implicit none
private

public :: get_expected_vortex_info

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module

!----------------------------------------------------------------------

subroutine get_expected_vortex_info(state_vector, location, vinfo, whichinfo, istatus)

!
! Return vortex info according to whichinfo
! whichinfo='lat', vinfo = center lat
! whichinfo='lon', vinfo = center lon
! whichinfo='pmi', vinfo =  minimum sea level pressure
!

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
character(len=3),    intent(in)  :: whichinfo
real(r8),            intent(out) :: vinfo
integer,             intent(out) :: istatus

if ( .not. module_initialized ) call initialize_module

if (whichinfo == 'lat') then
   call interpolate(state_vector, location, KIND_VORTEX_LAT, vinfo, istatus)
else if (whichinfo == 'lon') then
   call interpolate(state_vector, location, KIND_VORTEX_LON, vinfo, istatus)
else if (whichinfo == 'pmi') then
   call interpolate(state_vector, location, KIND_VORTEX_PMIN, vinfo, istatus)
else if (whichinfo == 'wma') then
   call interpolate(state_vector, location, KIND_VORTEX_WMAX, vinfo, istatus)
else
endif

if (istatus /= 0) then
   vinfo = missing_r8
   return
endif

end subroutine get_expected_vortex_info

end module obs_def_vortex_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_vortex_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_gts_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_gts_mod

use        types_mod, only : r8, missing_r8, gravity, gas_constant, gas_constant_v
use    utilities_mod, only : register_module
use     location_mod, only : location_type, set_location, get_location , &
                             VERTISSURFACE, VERTISPRESSURE, VERTISHEIGHT
use  assim_model_mod, only : interpolate
use     obs_kind_mod, only : KIND_TEMPERATURE, KIND_SPECIFIC_HUMIDITY, KIND_PRESSURE

implicit none
private

public :: get_expected_thickness

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains



subroutine initialize_module
!-----------------------------------------------------------------------------

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module



subroutine get_expected_thickness(state_vector, location, thickness, istatus)
!-----------------------------------------------------------------------------
! inputs:
!    state_vector:    DART state vector
!
! output parameters:
!    thickness: modeled satem thickness between the specified layers. (unit: m)
!    istatus:  =0 normal; =1 outside of domain.
!---------------------------------------------
! Hui Liu  NCAR/IMAGE  April 9, 2008
!---------------------------------------------
implicit none

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
real(r8),            intent(out) :: thickness
integer,             intent(out) :: istatus

! local variables

integer, parameter :: nlevel = 9, num_press_int = 10
integer  :: istatus0, istatus2,  k
real(r8) :: lon, lat, pressure, obsloc(3), obs_level(nlevel), press(num_press_int+1)
real(r8) :: press_top, press_bot, press_int

data  obs_level/85000.0, 70000.0, 50000.0, 40000.0, 30000.0, 25000.0, 20000.0, 15000.0, 10000.0/

real(r8), parameter::  rdrv1 = gas_constant_v/gas_constant - 1.0_r8

real(r8) :: lon2, t, q, tv, p
type(location_type) :: location2
integer :: which_vert

if ( .not. module_initialized ) call initialize_module

obsloc   = get_location(location)
lon      = obsloc(1)                       ! degree: 0 to 360
lat      = obsloc(2)                       ! degree: -90 to 90
pressure = obsloc(3)                       ! (Pa)

press_bot = -999.9_r8
press_top = -999.9_r8

! find the bottom and top of the layer -
! The 'bottom' is defined to be the incoming observation value.
! The 'top' is the next higher observation level.
! If the bottom is the highest observation level;
! there is no top, and it is an ERROR.

if(pressure > obs_level(1) ) then
   press_bot = pressure
   press_top = obs_level(1)
endif

do k = 1, nlevel-1
   if( abs(pressure - obs_level(k)) < 0.01_r8 ) then
      press_bot = obs_level(k)
      press_top = obs_level(k+1)
      exit
   endif
end do

!  define the vertical intervals for the integration of Tv. Use 10 sub_layers
!  for the vertical integration.

press_int = (press_bot - press_top)/num_press_int

press(1) = press_bot
do k=2, num_press_int+1
   press(k) =  press(1) - press_int * (k-1)
end do

!   define the location of the interpolated points.

lon2 = lon
if(lon > 360.0_r8 ) lon2 = lon - 360.0_r8
if(lon <   0.0_r8 ) lon2 = lon + 360.0_r8

which_vert = VERTISPRESSURE
istatus0  = 0
istatus2  = 0
thickness = 0.0_r8

do k=2, num_press_int+1, 2
   p = press(k)
   location2 = set_location(lon2, lat, p,  which_vert)

   call interpolate(state_vector, location2,  KIND_TEMPERATURE,       t, istatus0)
   call interpolate(state_vector, location2,  KIND_SPECIFIC_HUMIDITY, q, istatus2)

   if(istatus0 > 0 .or. istatus2 > 0  ) then
      istatus = 1
      thickness = missing_r8
   endif

   ! t :  Kelvin, from top to bottom
   ! q :  kg/kg, from top to bottom

   tv    = t * (1.0_r8 + rdrv1 * q )         ! virtual temperature
   thickness = thickness + gas_constant/gravity * tv * log(press(k-1)/press(k+1))

   ! expected values are around 1 KM; this is a check for
   ! wildly out of range values.
   if( abs(thickness) > 10000.0_r8 ) then
      istatus = 2
      thickness = missing_r8
   endif
end do

return
end subroutine get_expected_thickness


end module obs_def_gts_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_gts_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_monitor_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_monitor_mod

use        types_mod, only : r8, missing_r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                             nmlfileunit, check_namelist_read, &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, set_location, get_location , write_location, &
                             read_location

use  assim_model_mod, only : interpolate
use    obs_kind_mod,  only : KIND_SO2, KIND_NO2, KIND_CO, KIND_O3, KIND_BC1, KIND_BC2, KIND_OC1, KIND_OC2, &
                             KIND_DST01, KIND_DST02, KIND_DST03, KIND_DST04, &
                             KIND_DST05, KIND_SO4, KIND_SSLT01, KIND_SSLT02, KIND_SSLT03, &
                             KIND_SSLT04, KIND_PM25, KIND_PM10,KIND_PRESSURE, KIND_TEMPERATURE

implicit none
private

public :: write_monitor_so2,  read_monitor_so2, &
          write_monitor_no2,  read_monitor_no2, &
          write_monitor_co,   read_monitor_co, &
          write_monitor_o3,   read_monitor_o3, &
          write_monitor_pm10, read_monitor_pm10, &
          write_monitor_pm25, read_monitor_pm25, &
          interactive_monitor_so2,  get_expected_monitor_so2, &
          interactive_monitor_no2,  get_expected_monitor_no2, &
          interactive_monitor_co,   get_expected_monitor_co, &
          interactive_monitor_o3,   get_expected_monitor_o3, &
          interactive_monitor_pm10, get_expected_monitor_pm10, &
          interactive_monitor_pm25, get_expected_monitor_pm25

logical, parameter :: use_diag = .false.

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------
!>

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module


!----------------------------------------------------------------------
!>


subroutine read_monitor_so2(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_so2


!----------------------------------------------------------------------
!>


subroutine write_monitor_so2(key, ifile, fform)

integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_so2


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_so2(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_so2


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_so2(state_vector, location, key, so2, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: so2               ! so2 concentration(ug/m3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: mso2=64   ! molecular weight
                                 !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                 ! pressure (Pa)
real(r8) :: T_k                  ! temperature(K)

if ( .not. module_initialized ) call initialize_module

call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   so2 = missing_r8
   write(*,*) " KIND_PRESSURE very error, ",istatus
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   write(*,*) " KIND_TEMPERATURE very error, ",istatus
   so2 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_SO2, so2, istatus)! so2(ppmv)
if (istatus /= 0) then
   so2 = missing_r8
   write(*,*) " interpolation so2 very error, ",istatus
   return
endif
so2=so2*(mso2*p_pa)/(8.314*T_k) ! so2(ug/m3)


end subroutine get_expected_monitor_so2


!----------------------------------------------------------------------
!>


subroutine read_monitor_no2(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_no2


!----------------------------------------------------------------------
!>


subroutine write_monitor_no2(key, ifile, fform)


integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_no2


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_no2(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_no2


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_no2(state_vector, location, key, no2, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: no2               ! no2 concentration(ug/m3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: mno2=46   ! molecular weight
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: T_k                            ! tempreture(K)

if ( .not. module_initialized ) call initialize_module

call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   no2 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   no2 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_NO2, no2, istatus)! no2(ppmv)
if (istatus /= 0) then
   no2 = missing_r8
   return
endif
no2=no2*(mno2*p_pa)/(8.314*T_k) ! no2(ug/m3)

end subroutine get_expected_monitor_no2


!----------------------------------------------------------------------
!>


subroutine read_monitor_o3(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_o3


!----------------------------------------------------------------------
!>


subroutine write_monitor_o3(key, ifile, fform)

integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_o3


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_o3(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_o3


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_o3(state_vector, location, key, o3, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: o3               ! o3 concentration(ug/m3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: mo3=48   ! molecular weight
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: T_k                            ! tempreture(K)

if ( .not. module_initialized ) call initialize_module

call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   o3 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   o3 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_O3, o3, istatus)! o3(ppmv)
if (istatus /= 0) then
   o3 = missing_r8
   return
endif
o3=o3*(mo3*p_pa)/(8.314*T_k) ! o3(ug/m3)


end subroutine get_expected_monitor_o3


!----------------------------------------------------------------------
!>


subroutine read_monitor_co(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_co


!----------------------------------------------------------------------
!>


subroutine write_monitor_co(key, ifile, fform)

integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_co


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_co(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_co


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_co(state_vector, location, key, co, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: co               ! co concentration(mg/m3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: mco=28   ! molecular weight
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: T_k                            ! tempreture(K)

if ( .not. module_initialized ) call initialize_module

call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   co = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   co = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_CO, co, istatus)! co(ppmv)
if (istatus /= 0) then
   co = missing_r8
   return
endif
co=co*(mco*p_pa)/(1000*8.314*T_k) ! co(mg/m3)

end subroutine get_expected_monitor_co


!----------------------------------------------------------------------
!>


subroutine read_monitor_pm25(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_pm25


!----------------------------------------------------------------------
!>


subroutine write_monitor_pm25(key, ifile, fform)

integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_pm25


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_pm25(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_pm25


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_pm25(state_vector, location, key, ppm25, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: ppm25               ! pm2.5 concentration(ug/3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: m_dry_air=29   ! molecular weight
real(r8), PARAMETER :: mso4=96   ! molecular weight
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: T_k                            ! tempreture(K)
real(r8) :: PM25,BC1,BC2,DST01,DST02,SSLT01,SSLT02,SO4,OC1,OC2 !components
real(r8) :: alt_temp

if ( .not. module_initialized ) call initialize_module

ppm25=0.
call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_PM25, PM25, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+PM25
end if
call interpolate(state_vector, location, KIND_BC1, BC1, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+BC1
end if
call interpolate(state_vector, location, KIND_BC2, BC2, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+BC2
end if
call interpolate(state_vector, location, KIND_DST01, DST01, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+DST01
end if
call interpolate(state_vector, location, KIND_DST02, DST02, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+DST02*0.286
end if
call interpolate(state_vector, location, KIND_SSLT01, SSLT01, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+SSLT01
end if
call interpolate(state_vector, location, KIND_SSLT02, SSLT02, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+SSLT02*0.942
end if
call interpolate(state_vector, location, KIND_SO4, SO4, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+SO4*(mso4/m_dry_air)*1000.0*1.375
end if
call interpolate(state_vector, location, KIND_OC1, OC1, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+OC1*1.8
end if
call interpolate(state_vector, location, KIND_OC2, OC2, istatus)
if (istatus /= 0) then
   ppm25 = missing_r8
   return
else
   ppm25=ppm25+OC2*1.8 ! ug/kg
end if
alt_temp=1.0/(m_dry_air*p_Pa/(1000.0*8.314*T_k))
ppm25=ppm25/alt_temp ! pm25(ug/m3)


end subroutine get_expected_monitor_pm25


!----------------------------------------------------------------------
!>


subroutine read_monitor_pm10(key, ifile, fform)

integer, intent(out)            :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional    :: fform

continue

end subroutine read_monitor_pm10


!----------------------------------------------------------------------
!>


subroutine write_monitor_pm10(key, ifile, fform)

integer, intent(in)             :: key
integer, intent(in)             :: ifile
character(len=*), intent(in), optional :: fform

continue

end subroutine write_monitor_pm10


!----------------------------------------------------------------------
!>


subroutine interactive_monitor_pm10(key)

integer, intent(out) :: key

continue

end subroutine interactive_monitor_pm10


!----------------------------------------------------------------------
!>


subroutine get_expected_monitor_pm10(state_vector, location, key, ppm10, istatus)

real(r8),            intent(in)  :: state_vector(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: ppm10               ! pm10 concentration(ug/3)
integer,             intent(out) :: istatus

real(r8), PARAMETER :: m_dry_air=29   ! molecular weight
real(r8), PARAMETER :: mso4=96   ! molecular weight
                                          !   to avoid problems near zero in Bolton's equation
real(r8) :: p_Pa                          ! pressure (Pa)
real(r8) :: T_k                            ! tempreture(K)
real(r8) :: PM25,BC1,BC2,DST01,DST02,DST03,DST04,SSLT01,SSLT02,SSLT03,SO4,OC1,OC2,PM10 !components
real(r8) :: alt_temp

if ( .not. module_initialized ) call initialize_module

ppm10=0.
call interpolate(state_vector, location, KIND_PRESSURE, p_Pa, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_TEMPERATURE, T_k, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
endif
call interpolate(state_vector, location, KIND_PM25, PM25, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+PM25
end if
call interpolate(state_vector, location, KIND_BC1, BC1, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+BC1
end if
call interpolate(state_vector, location, KIND_BC2, BC2, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+BC2
end if
call interpolate(state_vector, location, KIND_DST01, DST01, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+DST01
end if
call interpolate(state_vector, location, KIND_DST02, DST02, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+DST02
end if
call interpolate(state_vector, location, KIND_DST03, DST03, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+DST03
end if
call interpolate(state_vector, location, KIND_DST04, DST04, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+DST04*0.87
end if
call interpolate(state_vector, location, KIND_SSLT01, SSLT01, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+SSLT01
end if
call interpolate(state_vector, location, KIND_SSLT02, SSLT02, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+SSLT02
end if
call interpolate(state_vector, location, KIND_SSLT03, SSLT03, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+SSLT03
end if
call interpolate(state_vector, location, KIND_SO4, SO4, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+SO4*(mso4/m_dry_air)*1000.0*1.375
end if
call interpolate(state_vector, location, KIND_OC1, OC1, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+OC1*1.8
end if
call interpolate(state_vector, location, KIND_OC2, OC2, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+OC2*1.8
end if
call interpolate(state_vector, location, KIND_PM10, PM10, istatus)
if (istatus /= 0) then
   ppm10 = missing_r8
   return
else
   ppm10=ppm10+PM10 ! ug/kg
end if
alt_temp=1.0/(m_dry_air*p_Pa/(1000.0*8.314*T_k))
ppm10=ppm10/alt_temp ! pm10(ug/m3)


end subroutine get_expected_monitor_pm10


end module obs_def_monitor_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_monitor_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
!No module code needed for ../../../obs_def/obs_def_AIRNOW_OBS_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
!No module code needed for ../../../obs_def/obs_def_PANDA_OBS_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_OMI_NO2_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_omi_mod

use        types_mod, only : r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, set_location, get_location, VERTISPRESSURE, VERTISSURFACE, VERTISLEVEL

use  assim_model_mod, only : interpolate
use    obs_kind_mod, only  : KIND_NO2, KIND_SURFACE_PRESSURE

implicit none
private

public :: write_omi_no2, &
          read_omi_no2, &
          interactive_omi_no2, &
          get_expected_omi_no2, &
          set_obs_def_omi_no2

! Storage for the special information required for observations of this type
integer, parameter               :: MAX_OMI_NO2_OBS = 10000000
integer, parameter               :: OMI_DIM = 35
integer                          :: num_omi_no2_obs = 0
! lxl:real(r8), dimension(MAX_OMI_NO2_OBS) :: mopitt_prior
real(r8)   :: omi_pressure(OMI_DIM) =(/ &
        102000., 101000., 100000., 99000., 97500., 96000., 94500., &
         92500.,  90000.,  87500., 85000., 82500., 80000., 77000., &
         74000.,  70000.,  66000., 61000., 56000., 50000., 45000., &
         40000.,  35000.,  28000., 20000., 12000.,  6000.,  3500., &
          2000.,   1200.,    800.,   500.,   300.,   150.,     80. /)
real(r8), allocatable, dimension(:,:) :: avg_kernel
real(r8), allocatable, dimension(:)   :: omi_psurf
real(r8), allocatable, dimension(:)   :: omi_ptrop
integer,  allocatable, dimension(:)   :: omi_nlevels

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

character(len=512) :: string1, string2, string3

logical, save :: module_initialized = .false.
integer  :: counts1 = 0

contains

!----------------------------------------------------------------------
!>

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

allocate(avg_kernel( MAX_OMI_NO2_OBS,OMI_DIM))
allocate(omi_psurf(  MAX_OMI_NO2_OBS))
allocate(omi_ptrop(  MAX_OMI_NO2_OBS))
allocate(omi_nlevels(MAX_OMI_NO2_OBS))

end subroutine initialize_module

!----------------------------------------------------------------------
!>

subroutine read_omi_no2(key, ifile, fform)

integer,          intent(out)          :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32) :: fileformat
integer           :: omi_nlevels_1
! lxl:real(r8):: mopitt_prior_1
real(r8)          :: omi_psurf_1
real(r8)          :: omi_ptrop_1
real(r8), dimension(OMI_DIM):: avg_kernels_1
integer           :: keyin

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading

avg_kernels_1(:) = 0.0_r8

SELECT CASE (fileformat)

   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   omi_nlevels_1 = read_omi_nlevels(ifile, fileformat)
!lxl   omi_prior_1 = read_mopitt_prior(ifile, fileformat)
   omi_psurf_1 = read_omi_psurf(ifile, fileformat)
   omi_ptrop_1 = read_omi_ptrop(ifile, fileformat)
   avg_kernels_1(1:omi_nlevels_1)  = read_omi_avg_kernels(ifile, omi_nlevels_1, fileformat)
   read(ifile) keyin

   CASE DEFAULT
   omi_nlevels_1 = read_omi_nlevels(ifile, fileformat)
!lxl   mopitt_prior_1 = read_mopitt_prior(ifile, fileformat)
   omi_psurf_1 = read_omi_psurf(ifile, fileformat)
   omi_ptrop_1 = read_omi_ptrop(ifile, fileformat)
   avg_kernels_1(1:omi_nlevels_1)  = read_omi_avg_kernels(ifile, omi_nlevels_1, fileformat)
   read(ifile, *) keyin
END SELECT

counts1 = counts1 + 1
key = counts1
call set_obs_def_omi_no2(key, avg_kernels_1, omi_psurf_1, omi_ptrop_1, omi_nlevels_1)

end subroutine read_omi_no2


!----------------------------------------------------------------------
!>

subroutine write_omi_no2(key, ifile, fform)

integer,          intent(in)           :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32) :: fileformat
real(r8), dimension(OMI_DIM) :: avg_kernels_temp

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading

avg_kernels_temp=avg_kernel(key,:)

SELECT CASE (fileformat)

   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   call write_omi_nlevels(ifile, omi_nlevels(key), fileformat)
!lxl   call write_mopitt_prior(ifile, mopitt_prior(key), fileformat)
   call write_omi_psurf(ifile, omi_psurf(key), fileformat)
   call write_omi_ptrop(ifile, omi_ptrop(key), fileformat)
   call write_omi_avg_kernels(ifile, avg_kernels_temp, omi_nlevels(key), fileformat)
   write(ifile) key

   CASE DEFAULT
   call write_omi_nlevels(ifile, omi_nlevels(key), fileformat)
!lxl   call write_mopitt_prior(ifile, mopitt_prior(key), fileformat)
   call write_omi_psurf(ifile, omi_psurf(key), fileformat)
   call write_omi_ptrop(ifile, omi_ptrop(key), fileformat)
   call write_omi_avg_kernels(ifile, avg_kernels_temp, omi_nlevels(key), fileformat)
   write(ifile, *) key
END SELECT

end subroutine write_omi_no2


!----------------------------------------------------------------------
!> Initializes the specialized part of a MOPITT observation
!> Passes back up the key for this one

subroutine interactive_omi_no2(key)

integer, intent(out) :: key

if ( .not. module_initialized ) call initialize_module

! Make sure there's enough space, if not die for now (clean later)
if(num_omi_no2_obs >= MAX_OMI_NO2_OBS) then
   write(string1, *)'Not enough space for a omi NO2 obs.'
   write(string2, *)'Can only have MAX_OMI_NO2_OBS (currently ',MAX_OMI_NO2_OBS,')'
   call error_handler(E_ERR,'interactive_omi_no2',string1,source,revision,revdate,text2=string2)
endif

! Increment the index
num_omi_no2_obs = num_omi_no2_obs + 1
key = num_omi_no2_obs

! Otherwise, prompt for input for the three required beasts
write(*, *) 'Creating an interactive_omi_no2 observation'
!write(*, *) 'Input the MOPITT Prior '
!read(*, *) mopitt_prior
write(*, *) 'Input OMI Surface Pressure '
read(*, *) omi_psurf(num_omi_no2_obs)
write(*, *) 'Input OMI Tropopause Pressure '
read(*, *) omi_ptrop(num_omi_no2_obs)
write(*, *) 'Input the 35 Averaging Kernel Weights '
read(*, *) avg_kernel(num_omi_no2_obs,:)

end subroutine interactive_omi_no2


!----------------------------------------------------------------------
!>

subroutine get_expected_omi_no2(state, location, key, val, istatus)

!subroutine get_expected_omi_no2(state, location, key, val, istatus)
!
   real(r8), intent(in)            :: state(:)
   type(location_type), intent(in) :: location
   integer, intent(in)             :: key
   real(r8), intent(out)           :: val
   integer, intent(out)            :: istatus
!
   integer :: i,kstr,kend
   type(location_type) :: loc2
   real(r8)            :: mloc(3)
   real(r8)	       :: obs_val,wrf_psf,level,missing
   real(r8)            :: no2_min,omi_psf,omi_ptrp,omi_psf_save,mg !,mopitt_prs_mid
   real(r8), dimension(OMI_DIM) :: no2_vmr
!
   integer             :: nlevels,nnlevels
!
! Initialize DART
   if ( .not. module_initialized ) call initialize_module
!
! 1ppt unit:mixing ratio !1.e-4 LXL: i THINK UNIT IS ppmv
! (mg  = (28.97/6.02E23)*1E-3    *   9.8      *     1E4;
   no2_min=1.e-6
   missing=-1.2676506e30
   mg=4.716046511627907e-21
   level   = 1.0_r8
!
! Get omi data
   nlevels = omi_nlevels(key)
   omi_psf = omi_psurf(key)
   omi_ptrp = omi_ptrop(key)
!
! Get location infomation
   mloc = get_location(location)
   if (mloc(2)>90.0_r8) then
       mloc(2)=90.0_r8
   elseif (mloc(2)<-90.0_r8) then
       mloc(2)=-90.0_r8
   endif
!
! Get wrf surface pressure
   wrf_psf = 0.0_r8
   istatus = 0
   loc2 = set_location(mloc(1), mloc(2), 0.0_r8, VERTISSURFACE)
   call interpolate(state, loc2, KIND_SURFACE_PRESSURE, wrf_psf, istatus)
!
! Correct omi surface pressure
   print *, 'APM: istatus ',istatus
   print *, 'APM: omi_psf ',omi_psf
   print *, 'APM: wrf_psf ',wrf_psf
   if (omi_psf .gt. wrf_psf) then
      omi_psf=wrf_psf
   endif
   omi_psf_save=omi_psf
!
! Find kstr - the surface level index
   kstr=0
   do i=1,OMI_DIM
      if (i .eq. 1 .and. omi_psf .gt. omi_pressure(2)) then
         kstr=i
         exit
      endif
      if (i .ne. 1 .and. i .ne. OMI_DIM .and. omi_psf .le. omi_pressure(i) .and. &
      omi_psf .gt. omi_pressure(i+1)) then
         kstr=i
         exit
      endif
   enddo
!
! Find kend - index for the first OMI level above omi_ptrop
   kend=0
   do i=1,OMI_DIM-1
      if (omi_ptrp .lt. omi_pressure(i) .and. omi_ptrp .ge. omi_pressure(i+1)) then
         kend=i+1
         exit
      endif
   enddo
!
   if (kstr .eq. 0) then
      write(string1, *)'APM: ERROR in OMI obs def kstr=0: omi_psf=',omi_psf
      call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      print *, 'APM: omi_psf ',omi_psf
      print *, 'APM: wrf_psf ',wrf_psf
      print *, 'APM: omi_pressure ',omi_pressure


      call abort
   elseif (kstr .gt. 20) then
      write(string1, *)'APM: ERROR surface pressure is unrealistic: omi_psf=',omi_psf
      call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      call abort
   endif
   if (kend .eq. 0) then
      write(string1, *)'APM: ERROR in OMI obs def kend=0: omi_ptrp=',omi_ptrp
      call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      call abort
   endif
!
! Reject ob when number of OMI levels from WRF cannot equal actual number of OMI levels
   nnlevels=OMI_DIM-kstr+1-(OMI_DIM-kend)
   if (nnlevels .ne. nlevels) then
      istatus=2
      obs_val=missing
      write(string1, *)'APM: NOTICE reject ob - # of WRF OMI levels .ne. # of OMI levels  '
      call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      return
   endif
!
! Find the lowest pressure level midpoint
! lxl: omi_prs=(mopitt_psf+omi_pressure(kstr+1))/2.
!
! Migliorini forward operators assimilation A*x_t
! Apply MOPITT Averaging kernel A and MOPITT Prior (I-A)xa
! x = Axm + (I-A)xa , where x is a 10 element vector
!
   no2_vmr(:)=0.
   do i=1,nlevels
!
! APM: remove the if test to use layer average data
      if (i .eq. 1) then
         loc2 = set_location(mloc(1),mloc(2),level, VERTISLEVEL)
!         write(string1, *)'APM NOTICE: Location for surface '
!         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      else if (i .eq. nlevels) then
         omi_psf=omi_ptrp
         loc2 = set_location(mloc(1),mloc(2),omi_psf, VERTISPRESSURE)
!         write(string1, *)'APM NOTICE: Location for tropopause '
!         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      else
         omi_psf=omi_pressure(kstr+i-1)
         loc2 = set_location(mloc(1),mloc(2),omi_psf, VERTISPRESSURE)
!         write(string1, *)'APM NOTICE: Location for free atm '
!         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      endif
!
! APM: check whether OMI pressure is less than omi_ptrop
! APM: Note = omi_pressure(nlevels) is first OMI pressure level above omi_ptrp
      if (i .ne. nlevels .and. omi_pressure(kstr+i-1) .lt. omi_ptrp) then
         write(string1, *)'APM ERROR: OMI pressure is less than ptrop ',omi_pressure(kstr+i-1),omi_ptrp
         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      endif
!
! Interpolate WRF NO2 data to OMI pressure level midpoint
      obs_val = 0.0_r8
      istatus = 0
      call interpolate(state, loc2, KIND_NO2, obs_val, istatus)
      if (istatus .ne. 0 .and. istatus .ne. 2) then
         write(string1, *)'APM ERROR: istatus,kstr,obs_val ',istatus,kstr,obs_val
         write(string2, *)'APM ERROR: wrf_psf,omi_psurf,omi_psf ', wrf_psf,omi_psurf(key),omi_psf
         write(string3, *)'APM ERROR: i, nlevels ',i,nlevels
         call error_handler(E_MSG, 'set_obs_def_omi_no2', string1, source, revision, revdate, &
                                   text2=string2, text3=string3)
         call abort
      endif
      if (istatus .eq. 2 .and. kstr+i-1 .ge. nlevels-2) then
         istatus=0
         obs_val=no2_min
!         write(string1, *)'APM NOTICE: obs_def_omi - NEED NO2 ABOVE MODEL TOP lev_idx ',kstr+i-1
!         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
      endif
      if (istatus .eq. 2 .and. i .lt. 3) then
         write(string1, *)'APM NOTICE: NO2 MODEL SURF - reject ob ',kstr,kstr+i-1,omi_psf_save,omi_pressure(kstr+i-1)
         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
         istatus=2
         obs_val=missing
         return
      endif
!
! Check for WRF CO lower bound
      if (obs_val .lt. no2_min) then
         write(string1, *)'APM NOTICE: RESETTING NO2 ',istatus,kstr+i-1,omi_pressure(kstr+i-1),obs_val
         call error_handler(E_MSG,'set_obs_def_omi_no2',string1,source,revision,revdate)
         obs_val=no2_min
      endif
!
! Convert from ppmv to no unit
      no2_vmr(i)=obs_val*1.e-6
   enddo
   val = 0.0_r8
   do i=1,nlevels-1
!
! apply averaging kernel onto vmr to calculate subcol
      if (i .eq. 1) then
         val = val + 0.5*(avg_kernel(key,i)*no2_vmr(i)+avg_kernel(key,i+1)*no2_vmr(i+1))*(omi_psf_save-omi_pressure(kstr+i))/mg
      else
         val = val + 0.5*(avg_kernel(key,i)*no2_vmr(i)+avg_kernel(key,i+1)*no2_vmr(i+1))*(omi_pressure(kstr+i-1)-omi_pressure(kstr+i))/mg
      endif
   enddo
!
end subroutine get_expected_omi_no2


!----------------------------------------------------------------------
!> Allows passing of obs_def special information


subroutine set_obs_def_omi_no2(key, no2_avgker, no2_psurf, no2_ptrop, no2_nlevels)

integer,  intent(in) :: key, no2_nlevels
real(r8), intent(in) :: no2_avgker(35)
!real(r8),intent(in) :: co_prior
real(r8), intent(in) :: no2_psurf
real(r8), intent(in) :: no2_ptrop

if ( .not. module_initialized ) call initialize_module

if(num_omi_no2_obs >= MAX_OMI_NO2_OBS) then
   write(string1, *)'Not enough space for a omi NO2 obs.'
   write(string2, *)'Can only have MAX_OMI_NO2_OBS (currently ',MAX_OMI_NO2_OBS,')'
   call error_handler(E_ERR,'set_obs_def_omi_no2',string1,source,revision,revdate,text2=string2)
endif

avg_kernel( key,:) = no2_avgker(:)
omi_psurf(  key)   = no2_psurf
omi_ptrop(  key)   = no2_ptrop
omi_nlevels(key)   = no2_nlevels

end subroutine set_obs_def_omi_no2


!----------------------------------------------------------------------
!>


function read_mopitt_prior(ifile, fform)

integer,                    intent(in) :: ifile
character(len=*), optional, intent(in) :: fform
real(r8)                               :: read_mopitt_prior

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_mopitt_prior
   CASE DEFAULT
      read(ifile, *) read_mopitt_prior
END SELECT

end function read_mopitt_prior


!----------------------------------------------------------------------
!>


function read_omi_nlevels(ifile, fform)

integer,                    intent(in) :: ifile
character(len=*), optional, intent(in) :: fform
integer                                :: read_omi_nlevels

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_omi_nlevels
   CASE DEFAULT
      read(ifile, *) read_omi_nlevels
END SELECT

end function read_omi_nlevels


!----------------------------------------------------------------------
!>


subroutine write_mopitt_prior(ifile, mopitt_prior_temp, fform)

integer,          intent(in) :: ifile
real(r8),         intent(in) :: mopitt_prior_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) mopitt_prior_temp
   CASE DEFAULT
      write(ifile, *) mopitt_prior_temp
END SELECT

end subroutine write_mopitt_prior


!----------------------------------------------------------------------
!>


subroutine write_omi_nlevels(ifile, omi_nlevels_temp, fform)

integer,          intent(in) :: ifile
integer,          intent(in) :: omi_nlevels_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) omi_nlevels_temp
   CASE DEFAULT
      write(ifile, *) omi_nlevels_temp
END SELECT

end subroutine write_omi_nlevels


!----------------------------------------------------------------------
!>


function read_omi_psurf(ifile, fform)

integer,                    intent(in) :: ifile
character(len=*), optional, intent(in) :: fform
real(r8)                               :: read_omi_psurf

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_omi_psurf
   CASE DEFAULT
      read(ifile, *) read_omi_psurf
END SELECT

end function read_omi_psurf


!----------------------------------------------------------------------
!>


subroutine write_omi_psurf(ifile, omi_psurf_temp, fform)

integer,          intent(in) :: ifile
real(r8),         intent(in) :: omi_psurf_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) omi_psurf_temp
   CASE DEFAULT
      write(ifile, *) omi_psurf_temp
END SELECT

end subroutine write_omi_psurf


!----------------------------------------------------------------------
!>


function read_omi_ptrop(ifile, fform)

integer,                    intent(in) :: ifile
character(len=*), optional, intent(in) :: fform
real(r8)                               :: read_omi_ptrop

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_omi_ptrop
   CASE DEFAULT
      read(ifile, *) read_omi_ptrop
END SELECT

end function read_omi_ptrop


!----------------------------------------------------------------------
!>


subroutine write_omi_ptrop(ifile, omi_ptrop_temp, fform)

integer,          intent(in) :: ifile
real(r8),         intent(in) :: omi_ptrop_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) omi_ptrop_temp
   CASE DEFAULT
      write(ifile, *) omi_ptrop_temp
END SELECT

end subroutine write_omi_ptrop


!----------------------------------------------------------------------
!>


function read_omi_avg_kernels(ifile, nlevels, fform)

integer,                    intent(in) :: ifile, nlevels
character(len=*), optional, intent(in) :: fform
real(r8)                               :: read_omi_avg_kernels(35)

character(len=32)  :: fileformat

!>@todo perhaps this should go after the initialize call
read_omi_avg_kernels(:) = 0.0_r8

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_omi_avg_kernels(1:nlevels)
   CASE DEFAULT
      read(ifile, *) read_omi_avg_kernels(1:nlevels)
END SELECT

end function read_omi_avg_kernels


!----------------------------------------------------------------------
!>


subroutine write_omi_avg_kernels(ifile, avg_kernels_temp, nlevels_temp, fform)

integer,          intent(in) :: ifile, nlevels_temp
real(r8),         intent(in) :: avg_kernels_temp(35)
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) avg_kernels_temp(1:nlevels_temp)
   CASE DEFAULT
      write(ifile, *) avg_kernels_temp(1:nlevels_temp)
END SELECT

end subroutine write_omi_avg_kernels


end module obs_def_omi_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_OMI_NO2_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_MODIS_AOD_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_modis_mod

use        types_mod, only : r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG
use     location_mod, only : location_type, set_location, get_location, VERTISPRESSURE, VERTISUNDEF

use  assim_model_mod, only : interpolate
use    obs_kind_mod, only  : KIND_AOD

implicit none
private

public :: write_modis_aod, &
          read_modis_aod, &
          interactive_modis_aod, &
          get_expected_modis_aod, &
          set_obs_def_modis_aod

! Storage for the special information required for observations of this type
integer, parameter               :: max_modis_aod_obs = 10000000
integer                          :: num_modis_aod_obs = 0

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

character(len=512) :: string1, string2

logical, save :: module_initialized = .false.
integer  :: counts1 = 0

contains

!----------------------------------------------------------------------
!>

subroutine initialize_module

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

end subroutine initialize_module

!----------------------------------------------------------------------
!>

subroutine read_modis_aod(key, ifile, fform)

integer,                    intent(out) :: key
integer,                    intent(in)  :: ifile
character(len=*), optional, intent(in)  :: fform

character(len=32) :: fileformat

integer :: keyin

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = adjustl(fform)

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading

SELECT CASE (trim(fileformat))
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) keyin

   CASE DEFAULT
   read(ifile, *) keyin
END SELECT

counts1 = counts1 + 1
key = counts1
call set_obs_def_modis_aod(key)

end subroutine read_modis_aod

!----------------------------------------------------------------------
!>

subroutine write_modis_aod(key, ifile, fform)

integer,                    intent(in) :: key
integer,                    intent(in) :: ifile
character(len=*), optional, intent(in) :: fform

character(len=32) :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = adjustl(fform)

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading

SELECT CASE (trim(fileformat))
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) key

   CASE DEFAULT
   write(ifile, *) key
END SELECT

end subroutine write_modis_aod

!----------------------------------------------------------------------
!>

subroutine interactive_modis_aod(key)

! Initializes the specialized part of a MODIS observation
! Passes back up the key for this one

integer, intent(out) :: key

if ( .not. module_initialized ) call initialize_module

! Make sure there's enough space, if not die for now (clean later)
if(num_modis_aod_obs >= max_modis_aod_obs) then
   write(string1, *)'Not enough space for a modis AOD obs.'
   write(string2, *)'Can only have max_modis_aod_obs (currently ',max_modis_aod_obs,')'
   call error_handler(E_ERR, 'interactive_modis_aod', string1, &
              source, revision, revdate, text2=string2)
endif

! Increment the index
num_modis_aod_obs = num_modis_aod_obs + 1
key = num_modis_aod_obs

! Otherwise, prompt for input for the three required beasts
write(*, *) 'Creating an interactive_modis_aod observation'

end subroutine interactive_modis_aod

!----------------------------------------------------------------------
!>

subroutine get_expected_modis_aod(state, location, key, val, istatus)

real(r8),            intent(in)  :: state(:)
type(location_type), intent(in)  :: location
integer,             intent(in)  :: key
real(r8),            intent(out) :: val
integer,             intent(out) :: istatus

type(location_type) :: loc2
real(r8)            :: mloc(3)
real(r8)    :: obs_val

if ( .not. module_initialized ) call initialize_module

mloc = get_location(location)

val = 0.0_r8
if (mloc(2)>90.0_r8) then
    mloc(2)=90.0_r8
elseif (mloc(2)<-90.0_r8) then
    mloc(2)=-90.0_r8
endif
!print *, 'APM in obs_def call interpolate '
loc2 = set_location(mloc(1),mloc(2),mloc(3), VERTISUNDEF)
call interpolate(state, loc2, KIND_AOD, obs_val, istatus)
if (istatus /= 0) then
    val = 0
    return
endif
val = obs_val
!print *, 'AFAJ DEBUG AOD VAL ', val, istatus

end subroutine get_expected_modis_aod

!----------------------------------------------------------------------
!> Allows passing of obs_def special information

subroutine set_obs_def_modis_aod(key)

integer, intent(in) :: key

if ( .not. module_initialized ) call initialize_module

if(num_modis_aod_obs >= max_modis_aod_obs) then
   write(string1, *)'Not enough space for a modis AOD obs.'
   write(string2, *)'Can only have max_modis_aod_obs (currently ',max_modis_aod_obs,')'
   call error_handler(E_ERR, 'set_obs_def_modis_aod', string1, &
              source, revision, revdate, text2=string2)
endif

end subroutine set_obs_def_modis_aod


end module obs_def_modis_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_MODIS_AOD_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_MOPITT_CO_mod.f90
!---------------------------------------------------------------------------  
                                                                              
module obs_def_mopitt_mod

use        types_mod, only : r8, missing_r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                             nmlfileunit, check_namelist_read, &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, set_location, get_location, VERTISPRESSURE, VERTISLEVEL, VERTISSURFACE, VERTISUNDEF

use  assim_model_mod, only : interpolate
use    obs_kind_mod, only  : KIND_CO, KIND_SURFACE_PRESSURE, KIND_PRESSURE, KIND_LANDMASK

implicit none
private

public :: write_mopitt_co, &
          read_mopitt_co, &
          interactive_mopitt_co, &
          get_expected_mopitt_co, &
          set_obs_def_mopitt_co

! Storage for the special information required for observations of this type
integer, parameter               :: MAX_MOPITT_CO_OBS = 10000000
integer, parameter               :: MOPITT_DIM = 10
integer                          :: num_mopitt_co_obs = 0
!
! MOPITT pressures (level 1 is place holder for surface pressure)
real(r8)   :: mopitt_pressure(MOPITT_DIM) =(/ &
                              100000.,90000.,80000.,70000.,60000.,50000.,40000.,30000.,20000.,1000. /)
real(r8)   :: mopitt_pressure_mid(MOPITT_DIM) =(/ &
                              100000.,85000.,75000.,65000.,55000.,45000.,35000.,25000.,15000.,7500. /)

real(r8), allocatable, dimension(:,:) :: avg_kernel
real(r8), allocatable, dimension(:) :: mopitt_prior
real(r8), allocatable, dimension(:) :: mopitt_psurf
integer,  allocatable, dimension(:) :: mopitt_nlevels

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

character(len=512) :: string1, string2

logical, save :: module_initialized = .false.
integer  :: counts1 = 0

character(len=129)  :: MOPITT_CO_retrieval_type
logical             :: use_log_co
!
! MOPITT_CO_retrieval_type:
!     RAWR - retrievals in VMR (ppb) units
!     RETR - retrievals in log10(VMR ([ ])) units
!     QOR  - quasi-optimal retrievals
!     CPSR - compact phase space retrievals
    namelist /obs_def_MOPITT_CO_nml/ MOPITT_CO_retrieval_type, use_log_co

contains

!----------------------------------------------------------------------

subroutine initialize_module

integer :: iunit, rc

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

allocate (avg_kernel(    MAX_MOPITT_CO_OBS,MOPITT_DIM))
allocate (mopitt_prior(  MAX_MOPITT_CO_OBS))
allocate (mopitt_psurf(  MAX_MOPITT_CO_OBS))
allocate (mopitt_nlevels(MAX_MOPITT_CO_OBS))

! Read the namelist entry.
MOPITT_CO_retrieval_type='RETR'
use_log_co=.false.
call find_namelist_in_file("input.nml", "obs_def_MOPITT_CO_nml", iunit)
read(iunit, nml = obs_def_MOPITT_CO_nml, iostat = rc)
call check_namelist_read(iunit, rc, "obs_def_MOPITT_CO_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_MOPITT_CO_nml)
if (do_nml_term()) write(     *     , nml=obs_def_MOPITT_CO_nml)

end subroutine initialize_module

subroutine read_mopitt_co(key, ifile, fform)
!----------------------------------------------------------------------
!subroutine read_mopitt_co(key, ifile, fform)

integer,          intent(out)          :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32)               :: fileformat

integer                         :: mopitt_nlevels_1
real(r8)                        :: mopitt_prior_1
real(r8)                        :: mopitt_psurf_1
real(r8), dimension(MOPITT_DIM) :: avg_kernels_1
integer                         :: keyin

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading
avg_kernels_1(:) = 0.0_r8
SELECT CASE (fileformat)
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   mopitt_nlevels_1 = read_mopitt_nlevels(ifile, fileformat)
   mopitt_prior_1 = read_mopitt_prior(ifile, fileformat)
   mopitt_psurf_1 = read_mopitt_psurf(ifile, fileformat)
   avg_kernels_1(1:mopitt_nlevels_1)  = read_mopitt_avg_kernels(ifile, mopitt_nlevels_1, fileformat)
   read(ifile) keyin
   CASE DEFAULT
   mopitt_nlevels_1 = read_mopitt_nlevels(ifile, fileformat)
   mopitt_prior_1 = read_mopitt_prior(ifile, fileformat)
   mopitt_psurf_1 = read_mopitt_psurf(ifile, fileformat)
   avg_kernels_1(1:mopitt_nlevels_1)  = read_mopitt_avg_kernels(ifile, mopitt_nlevels_1, fileformat)
   read(ifile, *) keyin
END SELECT

counts1 = counts1 + 1
key = counts1
call set_obs_def_mopitt_co(key, avg_kernels_1, mopitt_prior_1, mopitt_psurf_1, &
                           mopitt_nlevels_1)
end subroutine read_mopitt_co

 subroutine write_mopitt_co(key, ifile, fform)
!----------------------------------------------------------------------
!subroutine write_mopitt_co(key, ifile, fform)

integer,          intent(in)           :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32) :: fileformat
real(r8), dimension(MOPITT_DIM) :: avg_kernels_temp

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading

avg_kernels_temp=avg_kernel(key,:)

SELECT CASE (fileformat)

   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   call write_mopitt_nlevels(ifile, mopitt_nlevels(key), fileformat)
   call write_mopitt_prior(ifile, mopitt_prior(key), fileformat)
   call write_mopitt_psurf(ifile, mopitt_psurf(key), fileformat)
   call write_mopitt_avg_kernels(ifile, avg_kernels_temp, mopitt_nlevels(key), fileformat)
   write(ifile) key

   CASE DEFAULT
   call write_mopitt_nlevels(ifile, mopitt_nlevels(key), fileformat)
   call write_mopitt_prior(ifile, mopitt_prior(key), fileformat)
   call write_mopitt_psurf(ifile, mopitt_psurf(key), fileformat)
   call write_mopitt_avg_kernels(ifile, avg_kernels_temp, mopitt_nlevels(key), fileformat)
   write(ifile, *) key
END SELECT
end subroutine write_mopitt_co
!
subroutine interactive_mopitt_co(key)
!----------------------------------------------------------------------
!subroutine interactive_mopitt_co(key)
!
! Initializes the specialized part of a MOPITT observation
! Passes back up the key for this one

integer, intent(out) :: key

if ( .not. module_initialized ) call initialize_module

! Make sure there's enough space, if not die for now (clean later)
if(num_mopitt_co_obs >= MAX_MOPITT_CO_OBS) then
   write(string1, *)'Not enough space for a mopitt CO obs.'
   write(string2, *)'Can only have MAX_MOPITT_CO_OBS (currently ',MAX_MOPITT_CO_OBS,')'
   call error_handler(E_ERR,'interactive_mopitt_co',string1,source,revision,revdate, text2=string2)
endif

! Increment the index
num_mopitt_co_obs = num_mopitt_co_obs + 1
key = num_mopitt_co_obs

! Otherwise, prompt for input for the three required beasts
write(*, *) 'Creating an interactive_mopitt_co observation'
write(*, *) 'Input the MOPITT Prior '
read(*, *) mopitt_prior
write(*, *) 'Input MOPITT Surface Pressure '
read(*, *) mopitt_psurf(num_mopitt_co_obs)
write(*, *) 'Input the 10 Averaging Kernel Weights '
read(*, *) avg_kernel(num_mopitt_co_obs,:)
end subroutine interactive_mopitt_co
!
subroutine get_expected_mopitt_co(state, location, key, val, istatus)
!----------------------------------------------------------------------
!subroutine get_expected_mopitt_co(state, location, key, val, istatus)
   real(r8),            intent(in)  :: state(:)
   type(location_type), intent(in)  :: location
   integer,             intent(in)  :: key
   real(r8),            intent(out) :: val
   integer,             intent(out) :: istatus
!
   integer,parameter   :: wrf_nlev=33
   integer             :: i, kstr, ilev
   type(location_type) :: loc2
   real(r8)            :: mloc(3), prs_wrf(wrf_nlev)
   real(r8)            :: obs_val, co_min, co_min_log, level, missing
   real(r8)            :: prs_wrf_sfc, co_wrf_sfc
   real(r8)            :: prs_wrf_1, prs_wrf_2, co_wrf_1, co_wrf_2, prs_wrf_nlev
   real(r8)            :: prs_mopitt_sfc, prs_mopitt
   integer             :: nlevels,nlevelsp

   real(r8)            :: vert_mode_filt

   character(len=*), parameter :: routine = 'get_expected_mopitt_co'
!
! Initialize DART
   if ( .not. module_initialized ) call initialize_module
!
! Initialize variables (MOPITT is ppbv; WRF CO is ppmv)
   co_min      = 1.e-2
   co_min_log  = log(co_min)
   missing     = -888888.0_r8
   nlevels     = mopitt_nlevels(key)
   if ( use_log_co ) then
      co_min=co_min_log
   endif
!
! Get location infomation
   mloc = get_location(location)
   if (mloc(2)>90.0_r8) then
      mloc(2)=90.0_r8
   elseif (mloc(2)<-90.0_r8) then
      mloc(2)=-90.0_r8
   endif
!
! MOPITT surface pressure
   prs_mopitt_sfc = mopitt_psurf(key)
   mopitt_pressure(1)=mopitt_psurf(key)
!
! WRF surface pressure
   level=0.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISSURFACE)
   istatus=0
   call interpolate(state, loc2, KIND_SURFACE_PRESSURE, prs_wrf_sfc, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_sfc is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF pressure first level
   level=1.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus = 0
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_1, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_1 is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF pressure second level
   level=2.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus = 0
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_2, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_2 is bad ',istatus,prs_wrf_2
      call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF carbon monoxide at first level
   level=1.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus=0
   call interpolate(state, loc2, KIND_co, co_wrf_1, istatus)
   co_wrf_sfc=co_wrf_1
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF co_wrf_1 is bad ',istatus,prs_wrf_1,co_wrf_1
      call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! Apply MOPITT Averaging kernel A and MOPITT Prior (I-A)xa
! x = Axm + (I-A)xa , where x is a 10 element vector
!
! loop through MOPITT levels
   val = 0.0_r8
   do ilev = 1, nlevels
!
! get location of obs
      if (ilev.eq.1) then
         prs_mopitt=(prs_mopitt_sfc+mopitt_pressure(ilev))/2.
         loc2 = set_location(mloc(1),mloc(2),prs_mopitt, VERTISPRESSURE)
      else
         prs_mopitt=(mopitt_pressure(ilev-1)+mopitt_pressure(ilev))/2.
         loc2 = set_location(mloc(1),mloc(2),prs_mopitt, VERTISPRESSURE)
      endif
!
      if(prs_mopitt .ge. prs_wrf_1) then
         istatus=0
         obs_val=co_wrf_1
      else
         istatus=0
         call interpolate(state, loc2, KIND_CO, obs_val, istatus)
         if(istatus/=0) then
            write(string1, *)'APM NOTICE: WRF co_wrf is bad ',prs_mopitt,istatus
            call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
            val=missing
            return
         endif
      endif
!
! check for lower bound
      if (obs_val.lt.co_min) then
         write(string1, *)'APM: NOTICE resetting minimum MOPITT CO value ',ilev
         call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
         obs_val = co_min
      endif
!
! apply averaging kernel
      if( use_log_co ) then
         val = val + avg_kernel(key,ilev) * log10(exp(obs_val) * 1.e3)
!         print *, 'ilev,value, incr ', ilev, val, avg_kernel(key,ilev)*log10(exp(obs_val)/1.e6)
!         print *, 'ilev,obs_val,exp ', ilev, obs_val, exp(obs_val)/1.e6
!         print *, 'ilev,avg_ker,obs ', ilev, avg_kernel(key,ilev), log10(exp(obs_val)/1.e6)
!         print *, ' '
      else
         val = val + avg_kernel(key,ilev) * log10(obs_val * 1.e3)
      endif
   enddo
   if (trim(MOPITT_CO_retrieval_type).eq.'RETR' .or. trim(MOPITT_CO_retrieval_type).eq.'QOR' &
   .or. trim(MOPITT_CO_retrieval_type).eq.'CPSR') then
!      val = val + mopitt_prior(key)
!         print *, 'prior term       ',mopitt_prior(key)
!         print *, ' '
   elseif (trim(MOPITT_CO_retrieval_type).eq.'RAWR') then
!      val = val + mopitt_prior(key)
      val = (10.**val) * 1.e-3
   endif
!
end subroutine get_expected_mopitt_co
!
!----------------------------------------------------------------------

 subroutine set_obs_def_mopitt_co(key, co_avgker, co_prior, co_psurf, co_nlevels)
!----------------------------------------------------------------------
! Allows passing of obs_def special information

integer,                 intent(in) :: key, co_nlevels
real(r8), dimension(10), intent(in) :: co_avgker
real(r8),                intent(in) :: co_prior
real(r8),                intent(in) :: co_psurf

if ( .not. module_initialized ) call initialize_module

if(num_mopitt_co_obs >= MAX_MOPITT_CO_OBS) then

   write(string1, *)'Not enough space for a mopitt CO obs.'
   call error_handler(E_MSG,'set_obs_def_mopitt_co',string1,source,revision,revdate)
   write(string1, *)'Can only have MAX_MOPITT_CO_OBS (currently ',MAX_MOPITT_CO_OBS,')'
   call error_handler(E_ERR,'set_obs_def_mopitt_co',string1,source,revision,revdate)
endif

avg_kernel(key,:)   = co_avgker(:)
mopitt_prior(key)   = co_prior
mopitt_psurf(key)   = co_psurf
mopitt_nlevels(key) = co_nlevels

end subroutine set_obs_def_mopitt_co


function read_mopitt_prior(ifile, fform)

integer,                    intent(in) :: ifile
real(r8)                               :: read_mopitt_prior
character(len=*), intent(in), optional :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_mopitt_prior
   CASE DEFAULT
      read(ifile, *) read_mopitt_prior
END SELECT

end function read_mopitt_prior

function read_mopitt_nlevels(ifile, fform)

integer,                    intent(in) :: ifile
integer                               :: read_mopitt_nlevels
character(len=*), intent(in), optional :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_mopitt_nlevels
   CASE DEFAULT
      read(ifile, *) read_mopitt_nlevels
END SELECT

end function read_mopitt_nlevels



subroutine write_mopitt_prior(ifile, mopitt_prior_temp, fform)

integer,           intent(in) :: ifile
real(r8),          intent(in) :: mopitt_prior_temp
character(len=32), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) mopitt_prior_temp
   CASE DEFAULT
      write(ifile, *) mopitt_prior_temp
END SELECT

end subroutine write_mopitt_prior

subroutine write_mopitt_nlevels(ifile, mopitt_nlevels_temp, fform)

integer,                    intent(in) :: ifile
integer,                    intent(in) :: mopitt_nlevels_temp
character(len=32),          intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) mopitt_nlevels_temp
   CASE DEFAULT
      write(ifile, *) mopitt_nlevels_temp
END SELECT

end subroutine write_mopitt_nlevels



function read_mopitt_psurf(ifile, fform)

integer,                    intent(in) :: ifile
real(r8)                               :: read_mopitt_psurf
character(len=*), intent(in), optional :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_mopitt_psurf
   CASE DEFAULT
      read(ifile, *) read_mopitt_psurf
END SELECT

end function read_mopitt_psurf

subroutine write_mopitt_psurf(ifile, mopitt_psurf_temp, fform)

integer,           intent(in) :: ifile
real(r8),          intent(in) :: mopitt_psurf_temp
character(len=32), intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) mopitt_psurf_temp
   CASE DEFAULT
      write(ifile, *) mopitt_psurf_temp
END SELECT

end subroutine write_mopitt_psurf

function read_mopitt_avg_kernels(ifile, nlevels, fform)

integer,                    intent(in) :: ifile, nlevels
real(r8), dimension(10)        :: read_mopitt_avg_kernels
character(len=*), intent(in), optional :: fform

character(len=32)  :: fileformat

read_mopitt_avg_kernels(:) = 0.0_r8

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_mopitt_avg_kernels(1:nlevels)
   CASE DEFAULT
      read(ifile, *) read_mopitt_avg_kernels(1:nlevels)
END SELECT

end function read_mopitt_avg_kernels

subroutine write_mopitt_avg_kernels(ifile, avg_kernels_temp, nlevels_temp, fform)

integer,                    intent(in) :: ifile, nlevels_temp
real(r8), dimension(10), intent(in)  :: avg_kernels_temp
character(len=32),          intent(in) :: fform

character(len=32)  :: fileformat

if ( .not. module_initialized ) call initialize_module

fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) avg_kernels_temp(1:nlevels_temp)
   CASE DEFAULT
      write(ifile, *) avg_kernels_temp(1:nlevels_temp)
END SELECT

end subroutine write_mopitt_avg_kernels



end module obs_def_mopitt_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_MOPITT_CO_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_IASI_CO_mod.f90
!---------------------------------------------------------------------------  
                                                                              

module obs_def_iasi_CO_mod

use        types_mod, only : r8, missing_r8
use    utilities_mod, only : register_module, error_handler, E_ERR, E_MSG, &
                             nmlfileunit, check_namelist_read, &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use     location_mod, only : location_type, set_location, get_location, VERTISPRESSURE, VERTISLEVEL, VERTISSURFACE, VERTISUNDEF
use  assim_model_mod, only : interpolate
use    obs_kind_mod, only  : KIND_CO, KIND_SURFACE_PRESSURE, KIND_PRESSURE, KIND_LANDMASK

implicit none
private

public :: write_iasi_co, &
          read_iasi_co, &
          interactive_iasi_co, &
          get_expected_iasi_co, &
          set_obs_def_iasi_co

! Storage for the special information required for observations of this type
integer, parameter               :: MAX_IASI_CO_OBS = 10000000
integer, parameter               :: IASI_DIM = 19
integer, parameter               :: IASI_DIMP = 20
integer                          :: num_iasi_co_obs = 0

real(r8), allocatable, dimension(:,:) :: avg_kernel
real(r8), allocatable, dimension(:,:) :: pressure
real(r8), allocatable, dimension(:) :: iasi_prior
real(r8), allocatable, dimension(:) :: iasi_psurf
integer,  allocatable, dimension(:) :: iasi_nlevels
integer,  allocatable, dimension(:) :: iasi_nlevelsp

! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

character(len=512) :: string1, string2

logical, save :: module_initialized = .false.
integer  :: counts1 = 0

character(len=129)  :: IASI_CO_retrieval_type
logical             :: use_log_co
!
! IASI_CO_retrieval_type:
!     RAWR - retrievals in VMR (ppb) units
!     RETR - retrievals in log10(VMR ([ ])) units
!     QOR  - quasi-optimal retrievals
!     CPSR - compact phase space retrievals
    namelist /obs_def_IASI_CO_nml/ IASI_CO_retrieval_type, use_log_co

contains

!----------------------------------------------------------------------
!>

subroutine initialize_module

integer :: iunit, rc

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

allocate(avg_kernel(   MAX_IASI_CO_OBS, IASI_DIM))
allocate(pressure(     MAX_IASI_CO_OBS, IASI_DIMP))
allocate(iasi_prior(   MAX_IASI_CO_OBS))
allocate(iasi_psurf(   MAX_IASI_CO_OBS))
allocate(iasi_nlevels( MAX_IASI_CO_OBS))
allocate(iasi_nlevelsp(MAX_IASI_CO_OBS))

! Read the namelist entry.
IASI_CO_retrieval_type='RAWR'
use_log_co=.false.
call find_namelist_in_file("input.nml", "obs_def_IASI_CO_nml", iunit)
read(iunit, nml = obs_def_IASI_CO_nml, iostat = rc)
call check_namelist_read(iunit, rc, "obs_def_IASI_CO_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_IASI_CO_nml)
if (do_nml_term()) write(     *     , nml=obs_def_IASI_CO_nml)

end subroutine initialize_module

subroutine read_iasi_co(key, ifile, fform)
!----------------------------------------------------------------------
!subroutine read_iasi_co(key, ifile, fform)

integer,          intent(out)          :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32)              :: fileformat

integer                        :: iasi_nlevels_1
integer                        :: iasi_nlevelsp_1
real(r8)                       :: iasi_prior_1
real(r8)                       :: iasi_psurf_1
real(r8), dimension(IASI_DIM)  :: avg_kernels_1
real(r8), dimension(IASI_DIMP) :: pressure_1
integer                        :: keyin

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))

! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading
avg_kernels_1(:) = 0.0_r8
pressure_1(:) = 0.0_r8
SELECT CASE (fileformat)
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   iasi_nlevels_1 = read_iasi_nlevels(ifile, fileformat)
   iasi_nlevelsp_1 = iasi_nlevels_1+1
   iasi_prior_1 = read_iasi_prior(ifile, fileformat)
   iasi_psurf_1 = read_iasi_psurf(ifile, fileformat)
   avg_kernels_1(:) = read_iasi_avg_kernels(ifile, iasi_nlevels_1, fileformat)
   pressure_1(:) = read_iasi_pressure(ifile, iasi_nlevelsp_1, fileformat)
   read(ifile) keyin
   CASE DEFAULT
   iasi_nlevels_1 = read_iasi_nlevels(ifile, fileformat)
   iasi_nlevelsp_1 = iasi_nlevels_1+1
   iasi_prior_1 = read_iasi_prior(ifile, fileformat)
   iasi_psurf_1 = read_iasi_psurf(ifile, fileformat)
   avg_kernels_1(:) = read_iasi_avg_kernels(ifile, iasi_nlevels_1, fileformat)
   pressure_1(:) = read_iasi_pressure(ifile, iasi_nlevelsp_1, fileformat)
   read(ifile, *) keyin
END SELECT

counts1 = counts1 + 1
key = counts1
call set_obs_def_iasi_co(key, avg_kernels_1, pressure_1, iasi_prior_1, iasi_psurf_1, &
                           iasi_nlevels_1, iasi_nlevelsp_1)
end subroutine read_iasi_co

subroutine write_iasi_co(key, ifile, fform)
!----------------------------------------------------------------------
!subroutine write_iasi_co(key, ifile, fform)

integer,          intent(in)           :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

character(len=32) :: fileformat
real(r8), dimension(IASI_DIM)   :: avg_kernels_temp
real(r8), dimension(IASI_DIMP)  :: pressure_temp
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading
avg_kernels_temp=avg_kernel(key,:)
pressure_temp=pressure(key,:)
SELECT CASE (fileformat)
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   call write_iasi_nlevels(ifile, iasi_nlevels(key), fileformat)
   call write_iasi_prior(ifile, iasi_prior(key), fileformat)
   call write_iasi_psurf(ifile, iasi_psurf(key), fileformat)
   call write_iasi_avg_kernels(ifile, avg_kernels_temp, iasi_nlevels(key), fileformat)
   call write_iasi_pressure(ifile, pressure_temp, iasi_nlevelsp(key), fileformat)
   write(ifile) key
   CASE DEFAULT
   call write_iasi_nlevels(ifile, iasi_nlevels(key), fileformat)
   call write_iasi_prior(ifile, iasi_prior(key), fileformat)
   call write_iasi_psurf(ifile, iasi_psurf(key), fileformat)
   call write_iasi_avg_kernels(ifile, avg_kernels_temp, iasi_nlevels(key), fileformat)
   call write_iasi_pressure(ifile, pressure_temp, iasi_nlevelsp(key), fileformat)
   write(ifile, *) key
END SELECT
end subroutine write_iasi_co
!
subroutine interactive_iasi_co(key)
!----------------------------------------------------------------------
!subroutine interactive_iasi_co(key)
!
! Initializes the specialized part of a IASI observation
! Passes back up the key for this one
integer, intent(out) :: key

if ( .not. module_initialized ) call initialize_module
!
! Make sure there's enough space, if not die for now (clean later)
if(num_iasi_co_obs >= MAX_IASI_CO_OBS) then
   write(string1, *)'Not enough space for a iasi CO obs.'
   write(string2, *)'Can only have max_iasi_co obs (currently ',MAX_IASI_CO_OBS,')'
   call error_handler(E_ERR,'interactive_iasi_co',string1,source,revision,revdate,text2=string2)
endif
!
! Increment the index
num_iasi_co_obs = num_iasi_co_obs + 1
key = num_iasi_co_obs
!
! Otherwise, prompt for input for the three required beasts
write(*, *) 'Creating an interactive_iasi_co observation'
write(*, *) 'Input the IASI Prior '
read(*, *) iasi_prior
write(*, *) 'Input IASI Surface Pressure '
read(*, *) iasi_psurf(num_iasi_co_obs)
write(*, *) 'Input the 19 Averaging Kernel Weights '
read(*, *) avg_kernel(num_iasi_co_obs,:)
write(*, *) 'Input the 20 Averaging Pressure Levels '
read(*, *) pressure(num_iasi_co_obs,:)
end subroutine interactive_iasi_co
!
subroutine get_expected_iasi_co(state, location, key, val, istatus)
!----------------------------------------------------------------------
!subroutine get_expected_iasi_co(state, location, key, val, istatus)
   real(r8),            intent(in)  :: state(:)
   type(location_type), intent(in)  :: location
   integer,             intent(in)  :: key
   real(r8),            intent(out) :: val
   integer,             intent(out) :: istatus

   integer,parameter   :: wrf_nlev=32
   integer             :: i, kstr, ilev
   type(location_type) :: loc2
   real(r8)            :: mloc(3), prs_wrf(wrf_nlev)
   real(r8)            :: obs_val, co_min, co_min_log, level, missing
   real(r8)            :: prs_wrf_sfc, co_wrf_sfc
   real(r8)            :: prs_wrf_1, prs_wrf_2, co_wrf_1, co_wrf_2, prs_wrf_nlev
   real(r8)            :: prs_iasi_sfc, prs_iasi
   integer             :: nlevels,nlevelsp

   real(r8)            :: vert_mode_filt

   character(len=*), parameter :: routine = 'get_expected_iasi_co'
!
! Initialize DART
   if ( .not. module_initialized ) call initialize_module
!
! Initialize variables (IASI is ppbv; WRF CO is ppmv)
   co_min      = 1.e-2
   co_min_log  = log(co_min)
   missing     = -888888.0_r8
   nlevels     = iasi_nlevels(key)
   nlevelsp    = iasi_nlevelsp(key)
   if ( use_log_co ) then
      co_min=co_min_log
   endif
!
! Get location infomation
   mloc = get_location(location)
   if (mloc(2)>90.0_r8) then
      mloc(2)=90.0_r8
   elseif (mloc(2)<-90.0_r8) then
      mloc(2)=-90.0_r8
   endif
!
! IASI surface pressure
   prs_iasi_sfc=iasi_psurf(key)
!   pressure(1)=iasi_psurf(key)
!
! WRF surface pressure
   level=0.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISSURFACE)
   istatus = 0
   call interpolate(state, loc2, KIND_SURFACE_PRESSURE, prs_wrf_sfc, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_sfc is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF pressure first level
   level=1.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus = 0
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_1, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_1 is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF pressure second level
   level=2.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus=0
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_2, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF prs_wrf_2 is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! WRF carbon monoxide at first level
   level=1.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   istatus=0
   call interpolate(state, loc2, KIND_co, co_wrf_1, istatus)
   co_wrf_sfc=co_wrf_1
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF co_wrf_1 is bad ',istatus,prs_wrf_1,co_wrf_1
      call error_handler(E_MSG,'set_obs_def_iasi_co',string1,source,revision,revdate)
      val=missing
      return
   endif
!
! Apply IASI Averaging kernel A and IASI Prior (I-A)xa
! x = Axm + (I-A)xa , where x is a 10 element vector
!
! loop through IASI levels
   val = 0.0_r8
   do ilev = 1, nlevels
!
! get location of obs
      if (ilev.eq.1) then
         prs_iasi=(prs_iasi_sfc+pressure(key,ilev))/2.
         loc2 = set_location(mloc(1),mloc(2),prs_iasi, VERTISPRESSURE)
      else
         prs_iasi=(pressure(key,ilev-1)+pressure(key,ilev))/2.
         loc2 = set_location(mloc(1),mloc(2),prs_iasi, VERTISPRESSURE)
      endif
!
      if(prs_iasi.ge.prs_wrf_1) then
         istatus=0
         obs_val=co_wrf_1
      else
         istatus=0
         call interpolate(state, loc2, KIND_CO, obs_val, istatus)
         if(istatus/=0) then
            write(string1, *)'APM NOTICE: WRF co_wrf is bad ',prs_iasi,istatus
            call error_handler(E_MSG,'set_obs_def_iasi_co',string1,source,revision,revdate)
            val=missing
            return
         endif
      endif
!
! check for lower bound
      if (obs_val.lt.co_min) then
         write(string1, *)'APM: NOTICE resetting minimum IASI CO value ',ilev
         call error_handler(E_MSG,routine,string1,source,revision,revdate)
         obs_val = co_min
      endif
!
! apply averaging kernel
      if ( use_log_co ) then
         val = val + avg_kernel(key,ilev) * exp(obs_val) * 1.e3
      else
         val = val + avg_kernel(key,ilev) * obs_val * 1.e3
      endif
   enddo
   if (trim(IASI_CO_retrieval_type).eq.'RETR') then
!      val = val + iasi_prior(key)
      val = log10(val)
!         print *, 'prior term       ',iasi_prior(key)
!         print *, ' '
   elseif (trim(IASI_CO_retrieval_type).eq.'RAWR' .or. trim(IASI_CO_retrieval_type).eq.'QOR' &
   .or. trim(IASI_CO_retrieval_type).eq.'CPSR') then
!      val = val + iasi_prior(key)
   endif
!
end subroutine get_expected_iasi_co

!----------------------------------------------------------------------

subroutine set_obs_def_iasi_co(key, co_avgker, co_press, co_prior, co_psurf, co_nlevels, co_nlevelsp)

! Allows passing of obs_def special information

integer,                 intent(in) :: key, co_nlevels, co_nlevelsp
real(r8), dimension(IASI_DIM),  intent(in) :: co_avgker
real(r8), dimension(IASI_DIMP), intent(in) :: co_press
real(r8),                intent(in) :: co_prior
real(r8),                intent(in) :: co_psurf

character(len=*), parameter :: routine = 'set_obs_def_iasi_co'

if ( .not. module_initialized ) call initialize_module

if(num_iasi_co_obs >= MAX_IASI_CO_OBS) then
   write(string1, *)'Not enough space for a iasi CO obs.'
   write(string2, *)'Can only have MAX_IASI_CO_OBS (currently ',MAX_IASI_CO_OBS,')'
   call error_handler(E_ERR,routine,string1,source,revision,revdate,text2=string2)
endif

avg_kernel(   key,1:co_nlevels)  = co_avgker(1:co_nlevels)
pressure(     key,1:co_nlevelsp) = co_press(1:co_nlevelsp)
iasi_prior(   key)   = co_prior
iasi_psurf(   key)   = co_psurf
iasi_nlevels( key)   = co_nlevels
iasi_nlevelsp(key)   = co_nlevelsp

end subroutine set_obs_def_iasi_co



function read_iasi_prior(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
real(r8)                               :: read_iasi_prior

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_prior
   CASE DEFAULT
      read(ifile, *) read_iasi_prior
END SELECT
end function read_iasi_prior



function read_iasi_nlevels(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
integer                                :: read_iasi_nlevels

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_nlevels
   CASE DEFAULT
      read(ifile, *) read_iasi_nlevels
END SELECT
end function read_iasi_nlevels



function read_iasi_nlevelsp(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
integer                                :: read_iasi_nlevelsp

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_nlevelsp
   CASE DEFAULT
      read(ifile, *) read_iasi_nlevelsp
END SELECT
end function read_iasi_nlevelsp



subroutine write_iasi_prior(ifile, iasi_prior_temp, fform)
integer,          intent(in) :: ifile
real(r8),         intent(in) :: iasi_prior_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))

SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) iasi_prior_temp
   CASE DEFAULT
      write(ifile, *) iasi_prior_temp
END SELECT
end subroutine write_iasi_prior



subroutine write_iasi_nlevels(ifile, iasi_nlevels_temp, fform)
integer,          intent(in) :: ifile
integer,          intent(in) :: iasi_nlevels_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) iasi_nlevels_temp
   CASE DEFAULT
      write(ifile, *) iasi_nlevels_temp
END SELECT
end subroutine write_iasi_nlevels
!

subroutine write_iasi_nlevelsp(ifile, iasi_nlevelsp_temp, fform)
integer,          intent(in) :: ifile
integer,          intent(in) :: iasi_nlevelsp_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) iasi_nlevelsp_temp
   CASE DEFAULT
      write(ifile, *) iasi_nlevelsp_temp
END SELECT
end subroutine write_iasi_nlevelsp
!
function read_iasi_psurf(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
real(r8)                               :: read_iasi_psurf

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_psurf
   CASE DEFAULT
      read(ifile, *) read_iasi_psurf
END SELECT
end function read_iasi_psurf
!
subroutine write_iasi_psurf(ifile, iasi_psurf_temp, fform)
integer,          intent(in) :: ifile
real(r8),         intent(in) :: iasi_psurf_temp
character(len=*), intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) iasi_psurf_temp
   CASE DEFAULT
      write(ifile, *) iasi_psurf_temp
END SELECT
end subroutine write_iasi_psurf
!
function read_iasi_avg_kernels(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(IASI_DIM)           :: read_iasi_avg_kernels

character(len=32)  :: fileformat
read_iasi_avg_kernels(:) = 0.0_r8
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_avg_kernels(1:nlevels)
   CASE DEFAULT
      read(ifile, *) read_iasi_avg_kernels(1:nlevels)
END SELECT
end function read_iasi_avg_kernels
!
subroutine write_iasi_avg_kernels(ifile, avg_kernels_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(:), intent(in) :: avg_kernels_temp
character(len=*),        intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) avg_kernels_temp(1:nlevels_temp)
   CASE DEFAULT
      write(ifile, *) avg_kernels_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_avg_kernels
!
function read_iasi_pressure(ifile, nlevelsp, fform)
integer,          intent(in)           :: ifile, nlevelsp
character(len=*), intent(in), optional :: fform
real(r8), dimension(IASI_DIMP)         :: read_iasi_pressure

character(len=32) :: fileformat
read_iasi_pressure(:) = 0.0_r8
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      read(ifile) read_iasi_pressure(1:nlevelsp)
   CASE DEFAULT
      read(ifile, *) read_iasi_pressure(1:nlevelsp)
END SELECT
end function read_iasi_pressure
!
subroutine write_iasi_pressure(ifile, pressure_temp, nlevelsp_temp, fform)
integer,                 intent(in) :: ifile, nlevelsp_temp
real(r8), dimension(IASI_DIMP), intent(in)  :: pressure_temp
character(len=32),       intent(in) :: fform

character(len=32)  :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
      write(ifile) pressure_temp(1:nlevelsp_temp)
   CASE DEFAULT
      write(ifile, *) pressure_temp(1:nlevelsp_temp)
END SELECT
end subroutine write_iasi_pressure
!
end module obs_def_iasi_CO_mod
                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_IASI_CO_mod.f90
!---------------------------------------------------------------------------  
!---------------------------------------------------------------------------  
! Start of code inserted from ../../../obs_def/obs_def_IASI_O3_mod.f90
!---------------------------------------------------------------------------  
                                                                              

module obs_def_iasi_O3_mod

use types_mod,only          : r8
use utilities_mod,only      : register_module, error_handler, E_ERR, E_MSG, &
                             nmlfileunit, check_namelist_read, &
                             find_namelist_in_file, do_nml_file, do_nml_term, &
                             ascii_file_format
use location_mod,only       : location_type, set_location, get_location, VERTISHEIGHT,&
                              VERTISPRESSURE, VERTISLEVEL, VERTISSURFACE
use assim_model_mod,only    : interpolate
use obs_kind_mod,only       : KIND_O3, KIND_SURFACE_PRESSURE, KIND_PRESSURE
use mpi_utilities_mod,only  : my_task_id

implicit none
private

public :: write_iasi_o3,        &
          read_iasi_o3,         &
          interactive_iasi_o3,  &
          get_expected_iasi_o3, &
          set_obs_def_iasi_o3
!
! Storage for the special information required for observations of this type
integer, parameter          :: MAX_IASI_O3_OBS = 6000000
integer, parameter          :: IASI_DIM = 41
integer                     :: num_iasi_o3_obs = 0

real(r8), allocatable, dimension(:,:)  :: avg_kernel
real(r8), allocatable, dimension(:,:)  :: pressure
real(r8), allocatable, dimension(:)    :: iasi_prior_trm
real(r8), allocatable, dimension(:)    :: iasi_psurf
real(r8), allocatable, dimension(:,:)  :: iasi_altitude
real(r8), allocatable, dimension(:,:)  :: iasi_air_column
real(r8), allocatable, dimension(:,:)  :: iasi_prior
integer, allocatable, dimension(:)     :: iasi_nlevels
!
! nominal iasi height levels in m
real(r8)                    :: iasi_altitude_ref(IASI_DIM) =(/ &
                               0.,1000.,2000.,3000.,4000., &
                               5000.,6000.,7000.,8000.,9000., &
                               10000.,11000.,12000.,13000.,14000., &
                               15000.,16000.,17000.,18000.,19000., &
                               20000.,21000.,22000.,23000.,24000., &
                               25000.,26000.,27000.,28000.,29000., &
                               30000.,31000.,32000.,33000.,34000., &
                               35000.,36000.,37000.,38000.,39000., &
                               40000. /)
!
! version controlled file description for error handling, do not edit
character(len=*), parameter :: source   = &
   "$URL$"
character(len=*), parameter :: revision = "$Revision$"
character(len=*), parameter :: revdate  = "$Date$"

character(len=512) :: string1, string2

logical, save       :: module_initialized = .false.
integer             :: counts1 = 0

character(len=129)  :: IASI_O3_retrieval_type
logical             :: use_log_o3 =.false.
!
! IASI_O3_retrieval_type:
!     RAWR - retrievals in VMR (ppb) units
!     QOR  - quasi-optimal retrievals
!     CPSR - compact phase space retrievals
namelist /obs_def_IASI_O3_nml/ IASI_O3_retrieval_type, use_log_o3

contains

!----------------------------------------------------------------------

subroutine initialize_module

integer :: iunit, rc

! Prevent multiple calls from executing this code more than once.
if (module_initialized) return

call register_module(source, revision, revdate)
module_initialized = .true.

allocate(avg_kernel(     MAX_IASI_O3_OBS,IASI_DIM))
allocate(pressure(       MAX_IASI_O3_OBS,IASI_DIM))
allocate(iasi_prior_trm( MAX_IASI_O3_OBS))
allocate(iasi_psurf(     MAX_IASI_O3_OBS))
allocate(iasi_altitude(  MAX_IASI_O3_OBS,IASI_DIM))
allocate(iasi_air_column(MAX_IASI_O3_OBS,IASI_DIM))
allocate(iasi_prior     (MAX_IASI_O3_OBS,IASI_DIM))
allocate(iasi_nlevels(   MAX_IASI_O3_OBS))

! Read the namelist entry.
IASI_O3_retrieval_type='RAWR'
use_log_o3=.false.
call find_namelist_in_file("input.nml", "obs_def_IASI_O3_nml", iunit)
read(iunit, nml = obs_def_IASI_O3_nml, iostat = rc)
call check_namelist_read(iunit, rc, "obs_def_IASI_O3_nml")

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_def_IASI_O3_nml)
if (do_nml_term()) write(     *     , nml=obs_def_IASI_O3_nml)

end subroutine initialize_module

!----------------------------------------------------------------------
!>

subroutine read_iasi_o3(key, ifile, fform)

integer,                    intent(out) :: key
integer,                    intent(in)  :: ifile
character(len=*), optional, intent(in)  :: fform

character(len=32)               :: fileformat
integer                         :: iasi_nlevels_1
real(r8)                        :: iasi_prior_trm_1
real(r8)                        :: iasi_psurf_1
real(r8),  dimension(IASI_DIM)  :: iasi_altitude_1
real(r8),  dimension(IASI_DIM)  :: iasi_air_column_1
real(r8),  dimension(IASI_DIM)  :: iasi_prior_1
real(r8),  dimension(IASI_DIM)  :: avg_kernel_1
real(r8),  dimension(IASI_DIM)  :: pressure_1
integer                         :: keyin

if ( .not. module_initialized ) call initialize_module

fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading
!
iasi_altitude_1(:) = 0.0_r8
iasi_air_column_1(:) = 0.0_r8
iasi_prior_1(:) = 0.0_r8
avg_kernel_1(:) = 0.0_r8
pressure_1(:) = 0.0_r8

SELECT CASE (fileformat)
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   iasi_nlevels_1 = read_iasi_nlevels(ifile, fileformat)
   iasi_prior_trm_1  = read_iasi_prior_trm(ifile, fileformat)
   iasi_psurf_1  = read_iasi_psurf(ifile, fileformat)
   iasi_altitude_1 = read_iasi_altitude(ifile, iasi_nlevels_1, fileformat)
   iasi_air_column_1  = read_iasi_air_column(ifile, iasi_nlevels_1, fileformat)
   iasi_prior_1  = read_iasi_prior(ifile, iasi_nlevels_1, fileformat)
   avg_kernel_1 = read_iasi_avg_kernel(ifile, iasi_nlevels_1, fileformat)
   pressure_1 = read_iasi_pressure(ifile, iasi_nlevels_1, fileformat)
   read(ifile) keyin
   CASE DEFAULT
   iasi_nlevels_1 = read_iasi_nlevels(ifile, fileformat)
   iasi_prior_trm_1  = read_iasi_prior_trm(ifile, fileformat)
   iasi_psurf_1  = read_iasi_psurf(ifile, fileformat)
   iasi_altitude_1 = read_iasi_altitude(ifile, iasi_nlevels_1, fileformat)
   iasi_air_column_1  = read_iasi_air_column(ifile, iasi_nlevels_1, fileformat)
   iasi_prior_1  = read_iasi_prior(ifile, iasi_nlevels_1, fileformat)
   avg_kernel_1 = read_iasi_avg_kernel(ifile, iasi_nlevels_1, fileformat)
   pressure_1 = read_iasi_pressure(ifile, iasi_nlevels_1, fileformat)
   read(ifile, *) keyin
END SELECT
counts1 = counts1 + 1
key = counts1
call set_obs_def_iasi_o3(key, avg_kernel_1, pressure_1, iasi_prior_trm_1, &
   iasi_psurf_1, iasi_altitude_1, iasi_air_column_1, iasi_prior_1, iasi_nlevels_1)

end subroutine read_iasi_o3

!----------------------------------------------------------------------

subroutine write_iasi_o3(key, ifile, fform)

integer,          intent(in)           :: key
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform

real(r8),  dimension(IASI_DIM)  :: altitude_temp
real(r8),  dimension(IASI_DIM)  :: air_column_temp
real(r8),  dimension(IASI_DIM)  :: prior_temp
real(r8),  dimension(IASI_DIM)  :: avg_kernel_temp
real(r8),  dimension(IASI_DIM)  :: pressure_temp

character(len=32)               :: fileformat
if ( .not. module_initialized ) call initialize_module
fileformat = "ascii"   ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
! Philosophy, read ALL information about this special obs_type at once???
! For now, this means you can only read ONCE (that's all we're doing 3 June 05)
! Toggle the flag to control this reading
!
altitude_temp=iasi_altitude(key,:)
air_column_temp=iasi_air_column(key,:)
prior_temp=iasi_prior(key,:)
avg_kernel_temp=avg_kernel(key,:)
pressure_temp=pressure(key,:)
!
SELECT CASE (fileformat)
   CASE ("unf", "UNF", "unformatted", "UNFORMATTED")
   call write_iasi_nlevels(ifile, iasi_nlevels(key), fileformat)
   call write_iasi_prior_trm(ifile, iasi_prior_trm(key), fileformat)
   call write_iasi_psurf(ifile, iasi_psurf(key), fileformat)
   call write_iasi_altitude(ifile, altitude_temp, iasi_nlevels(key), fileformat)
   call write_iasi_air_column(ifile, air_column_temp, iasi_nlevels(key), fileformat)
   call write_iasi_prior(ifile, prior_temp, iasi_nlevels(key), fileformat)
   call write_iasi_avg_kernel(ifile, avg_kernel_temp, iasi_nlevels(key), fileformat)
   call write_iasi_pressure(ifile, pressure_temp, iasi_nlevels(key), fileformat)
   write(ifile) key
   CASE DEFAULT
   call write_iasi_nlevels(ifile, iasi_nlevels(key), fileformat)
   call write_iasi_prior_trm(ifile, iasi_prior_trm(key), fileformat)
   call write_iasi_psurf(ifile, iasi_psurf(key), fileformat)
   call write_iasi_altitude(ifile, altitude_temp, iasi_nlevels(key), fileformat)
   call write_iasi_air_column(ifile, air_column_temp, iasi_nlevels(key), fileformat)
   call write_iasi_prior(ifile, prior_temp, iasi_nlevels(key), fileformat)
   call write_iasi_avg_kernel(ifile, avg_kernel_temp, iasi_nlevels(key), fileformat)
   call write_iasi_pressure(ifile, pressure_temp, iasi_nlevels(key), fileformat)
   write(ifile, *) key
END SELECT
end subroutine write_iasi_o3
!
subroutine interactive_iasi_o3(key)
!----------------------------------------------------------------------
! subroutine interactive_iasi_o3(key)
!
! Initializes the specialized part of a IASI observation
! Passes back up the key for this one
!
integer, intent(out) :: key
!
if ( .not. module_initialized ) call initialize_module
!
! Make sure there's enough space, if not die for now (clean later)
if(num_iasi_o3_obs >= MAX_IASI_O3_OBS) then
   write(string1, *)'Not enough space for a iasi O3 obs.'
   write(string2, *)'Can only have MAX_IASI_O3_OBS (currently ',MAX_IASI_O3_OBS,')'
   call error_handler(E_ERR,'interactive_iasi_o3',string1,source,revision,revdate,text2=string2)
endif
!
! Increment the index
num_iasi_o3_obs = num_iasi_o3_obs + 1
key = num_iasi_o3_obs
!
! Otherwise, prompt for input for the three required beasts
write(*, *) 'Creating an interactive_iasi_o3 observation'
write(*, *) 'Input the IASI nlevels '
read(*, *) iasi_nlevels
write(*, *) 'Input the IASI O3 Prior Term '
read(*, *) iasi_prior_trm
write(*, *) 'Input the IASI O3 Surface Pressure '
read(*, *) iasi_psurf
write(*, *) 'Input IASI O3 41 Altitudes '
read(*, *) iasi_altitude(num_iasi_o3_obs,:)
write(*, *) 'Input IASI O3 41 Air Columns '
read(*, *) iasi_air_column(num_iasi_o3_obs,:)
write(*, *) 'Input IASI O3 41 Priors '
read(*, *) iasi_prior(num_iasi_o3_obs,:)
write(*, *) 'Input IASI O3 41 Averaging Kernel '
read(*, *) avg_kernel(num_iasi_o3_obs,:)
write(*, *) 'Input IASI O3 41 Pressure '
read(*, *) pressure(num_iasi_o3_obs,:)
end subroutine interactive_iasi_o3
!
!----------------------------------------------------------------------
subroutine get_expected_iasi_o3(state, location, key, val, istatus)

   real(r8),            intent(in)  :: state(:)
   type(location_type), intent(in)  :: location
   integer,             intent(in)  :: key
   real(r8),            intent(out) :: val
   integer,             intent(out) :: istatus
!
   integer, parameter  :: wrf_nlev=32
   integer             :: i, kstr, ilev, istrat
   integer             :: apm_dom, apm_mm
   type(location_type) :: loc2
   real(r8)            :: mloc(3), prs_wrf(wrf_nlev)
   real(r8)            :: obs_val, obs_val_fnl, o3_min, o3_min_str
   real(r8)            :: o3_min_log, o3_min_str_log, level, missing
   real(r8)            :: o3_wrf_sfc, o3_wrf_1, o3_wrf_top
   real(r8)            :: prs_wrf_sfc, prs_wrf_1, prs_wrf_nlev
   real(r8)            :: prs_iasi_sfc

   real(r8)            :: ylon, ylat, ubv_obs_val, ubv_delt_prs
   real(r8)            :: prs_top, prs_bot, wt_dw, wt_up
   real(r8)            :: term, prior_term
   integer             :: nlevels
   integer             :: icnt=0
   character(len=130)  :: apm_spec

   real(r8)            :: vert_mode_filt
!
! Initialize DART
   if ( .not. module_initialized ) call initialize_module
!
! Initialize variables
   prs_bot         = 150.*1.e2
   prs_top         = 50*1.e2
   o3_min          = 0.004 * 1.e-3
   o3_min_log      = log(o3_min)
   o3_min_str      = 0.00414 * 1.e-3
   o3_min_str_log  = log(o3_min_str)
   missing         = -888888.0_r8
   nlevels         = iasi_nlevels(key)
   if ( use_log_o3 ) then
      o3_min=o3_min_log
      o3_min_str=o3_min_str_log
   endif
!
! Get location information
   mloc=get_location(location)
   if (mloc(2) .gt. 90.0_r8) then
      mloc(2)=90.0_r8
   elseif (mloc(2) .lt. -90.0_r8) then
      mloc(2)=-90.0_r8
   endif
!
! IASI surface pressure
   prs_iasi_sfc=iasi_psurf(key)
!
! WRF surface pressure
   istatus=0
   level=0.0_r8
   loc2 = set_location(mloc(1), mloc(2), level, VERTISSURFACE)
   call interpolate(state, loc2, KIND_SURFACE_PRESSURE, prs_wrf_sfc, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF surface pressure is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
      stop
   endif
!
! WRF pressure first level
   istatus=0
   level=real(1)
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_1, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF first level pressure is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
      stop
   endif
!
! WRF pressure top level
   istatus=0
   level=real(wrf_nlev)
   loc2 = set_location(mloc(1), mloc(2), level, VERTISLEVEL)
   call interpolate(state, loc2, KIND_PRESSURE, prs_wrf_nlev, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF top level pressure is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
      stop
   endif
!
! WRF ozone at surface
!   istatus = 0
!   loc2 = set_location(mloc(1), mloc(2), prs_wrf_sfc, VERTISSURFACE)
!   call interpolate(state, loc2, KIND_O3, o3_wrf_sfc, istatus)
!   if(istatus/=0) then
!      write(string1, *)'APM NOTICE: WRF o3 at surface is bad ',istatus
!      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
!      stop
!   endif
!
! WRF ozone at first level
   istatus = 0
   loc2 = set_location(mloc(1), mloc(2), prs_wrf_1, VERTISPRESSURE)
   call interpolate(state, loc2, KIND_O3, o3_wrf_1, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF o3 at first level is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
      stop
   endif
!
! WRF ozone at top
   istatus = 0
   loc2 = set_location(mloc(1), mloc(2), prs_wrf_nlev, VERTISPRESSURE)
   call interpolate(state, loc2, KIND_O3, o3_wrf_top, istatus)
   if(istatus/=0) then
      write(string1, *)'APM NOTICE: WRF o3 at top is bad ',istatus
      call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
      stop
   endif
!
! Apply IASI Averaging kernel A and IASI Prior (I-A)xa
! x = Axm + (I-A)xa , where x is a 41-element vector !
!
! loop through IASI levels
   val = 0.0_r8
   do ilev = 1, nlevels
!
! get location of obs
      istrat=0
!
! point at model surface
!      if(pressure(key,ilev).ge.prs_wrf_sfc) then
!         obs_val=o3_wrf_sfc
!      endif
! point between surface and first level
      if(pressure(key,ilev).ge.prs_wrf_1) then
         obs_val=o3_wrf_1
      endif
!
! point in model interior
      if(pressure(key,ilev).lt.prs_wrf_1 .and. pressure(key,ilev).ge.prs_wrf_nlev) then
         istatus = 0
         loc2 = set_location(mloc(1),mloc(2), pressure(key,ilev), VERTISPRESSURE)
         call interpolate(state, loc2, KIND_O3, obs_val, istatus)
         if(istatus.ne.0) then
            write(string1, *) 'ilev obs_val,ias_pr ',ilev,obs_val,pressure(key,ilev)/100.
            call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
            write(string1, *)  'key, ilev ',key,ilev,pressure(key,ilev),prs_wrf_1
            call error_handler(E_MSG,'set_obs_def_iasi_o3',string1,source,revision,revdate)
            stop
         endif
      endif
!
! point above model top
      if(pressure(key,ilev).lt.prs_wrf_nlev) then
         istrat=1
         obs_val=iasi_prior(key,ilev)
      endif
!
! scale to ppb
      if (istrat.eq.0) then
         if ( use_log_o3 ) then
            obs_val=obs_val + 2.303 * 3.0
         else
            obs_val = obs_val * 1.e3
         endif
      endif
!
! blend upper tropospnere with the prior (WRF O3 biased relative to IASI).
      obs_val_fnl=obs_val
      if(pressure(key,ilev).le.prs_bot .and. pressure(key,ilev).ge.prs_top) then
         wt_dw=pressure(key,ilev)-prs_top
         wt_up=prs_bot-pressure(key,ilev)
         obs_val_fnl=(wt_dw*obs_val + wt_up*iasi_prior(key,ilev))/(wt_dw+wt_up)
      endif
      if(pressure(key,ilev).lt.prs_top) then
         obs_val_fnl=iasi_prior(key,ilev)
      endif
!
! apply averaging kernel
      if( use_log_o3 ) then
         val = val + avg_kernel(key,ilev) * exp(obs_val_fnl)
      else
         val = val + avg_kernel(key,ilev) * obs_val_fnl
      endif
   enddo
!
   val = val + iasi_prior_trm(key)
!
   if (trim(IASI_O3_retrieval_type).eq.'RETR') then
      val = log10(val)
   endif
   if(val.lt.0.) then
      icnt=icnt+1
      print *, 'APM: Expected O3 is negative ',mloc(3),val
   endif
end subroutine get_expected_iasi_o3

!----------------------------------------------------------------------

subroutine set_obs_def_iasi_o3(key, o3_avgker, o3_press, o3_prior_trm, o3_psurf, o3_altitude, &
   o3_air_column, o3_prior, o3_nlevels)

!> Allows passing of obs_def special information


integer,                 intent(in) :: key
integer,                 intent(in) :: o3_nlevels
real(r8), dimension(41), intent(in) :: o3_avgker
real(r8), dimension(41), intent(in) :: o3_press
real(r8),                intent(in) :: o3_prior_trm
real(r8),                intent(in) :: o3_psurf
real(r8), dimension(41), intent(in) :: o3_altitude
real(r8), dimension(41), intent(in) :: o3_air_column
real(r8), dimension(41), intent(in) :: o3_prior

if ( .not. module_initialized ) call initialize_module

! Check for sufficient space
if(num_iasi_o3_obs >= MAX_IASI_O3_OBS) then
   write(string1, *)'Not enough space for a iasi O3 obs.'
   write(string2, *)'Can only have MAX_IASI_O3_OBS (currently ',MAX_IASI_O3_OBS,')'
   call error_handler(E_ERR,'set_obs_def_iasi_o3',string1,source,revision,revdate,text2=string2)
endif

avg_kernel(key,:)         = o3_avgker(:)
pressure(key,:)           = o3_press(:)
iasi_prior_trm(key)       = o3_prior_trm
iasi_psurf(key)           = o3_psurf
iasi_altitude(key,:)      = o3_altitude(:)
iasi_air_column(key,:)    = o3_air_column(:)
iasi_prior(key,:)         = o3_prior(:)
iasi_nlevels(key)         = o3_nlevels

end subroutine set_obs_def_iasi_o3

!=================================
! other functions and subroutines
!=================================
!
function read_iasi_prior_trm(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
real(r8)                               :: read_iasi_prior_trm
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_prior_trm
   CASE DEFAULT
   read(ifile, *) read_iasi_prior_trm
END SELECT
end function read_iasi_prior_trm
!
subroutine write_iasi_prior_trm(ifile, iasi_prior_trm_temp, fform)
integer,          intent(in) :: ifile
real(r8),         intent(in) :: iasi_prior_trm_temp
character(len=*), intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) iasi_prior_trm_temp
   CASE DEFAULT
   write(ifile, *) iasi_prior_trm_temp
END SELECT
end subroutine write_iasi_prior_trm
!
function read_iasi_psurf(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
real(r8)                               :: read_iasi_psurf
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_psurf
   CASE DEFAULT
   read(ifile, *) read_iasi_psurf
END SELECT
end function read_iasi_psurf
!
subroutine write_iasi_psurf(ifile, iasi_psurf_temp, fform)
integer,          intent(in) :: ifile
real(r8),         intent(in) :: iasi_psurf_temp
character(len=*), intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) iasi_psurf_temp
   CASE DEFAULT
   write(ifile, *) iasi_psurf_temp
END SELECT
end subroutine write_iasi_psurf
!
function read_iasi_nlevels(ifile, fform)
integer,          intent(in)           :: ifile
character(len=*), intent(in), optional :: fform
integer                                :: read_iasi_nlevels
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
!
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_nlevels
   CASE DEFAULT
   read(ifile, *) read_iasi_nlevels
END SELECT
end function read_iasi_nlevels
!
subroutine write_iasi_nlevels(ifile, iasi_nlevels_temp, fform)
integer,          intent(in) :: ifile
integer,          intent(in) :: iasi_nlevels_temp
character(len=*), intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) iasi_nlevels_temp
   CASE DEFAULT
   write(ifile, *) iasi_nlevels_temp
END SELECT
end subroutine write_iasi_nlevels
!
function read_iasi_avg_kernel(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(41)                :: read_iasi_avg_kernel
!
character(len=32)  :: fileformat
read_iasi_avg_kernel(:) = 0.0_r8
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_avg_kernel(1:nlevels)
   CASE DEFAULT
   read(ifile, *) read_iasi_avg_kernel(1:nlevels)
END SELECT
end function read_iasi_avg_kernel
!
function read_iasi_altitude(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(41)                :: read_iasi_altitude
!
character(len=32)  :: fileformat
read_iasi_altitude(:) = 0.0_r8
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_altitude(1:nlevels)
   CASE DEFAULT
   read(ifile, *) read_iasi_altitude(1:nlevels)
END SELECT
end function read_iasi_altitude
!
function read_iasi_pressure(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(41)                :: read_iasi_pressure
!
character(len=32)  :: fileformat
read_iasi_pressure(:) = 0.0_r8
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_pressure(1:nlevels)
   CASE DEFAULT
   read(ifile, *) read_iasi_pressure(1:nlevels)
END SELECT
end function read_iasi_pressure
!
function read_iasi_air_column(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(41)                :: read_iasi_air_column
!
character(len=32)  :: fileformat
read_iasi_air_column(:) = 0.0_r8
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_air_column(1:nlevels)
   CASE DEFAULT
   read(ifile, *) read_iasi_air_column(1:nlevels)
END SELECT
end function read_iasi_air_column
!
function read_iasi_prior(ifile, nlevels, fform)
integer,          intent(in)           :: ifile, nlevels
character(len=*), intent(in), optional :: fform
real(r8), dimension(41)                :: read_iasi_prior
!
character(len=32)  :: fileformat
read_iasi_prior(:) = 0.0_r8
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = "ascii"    ! supply default
if(present(fform)) fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   read(ifile) read_iasi_prior(1:nlevels)
   CASE DEFAULT
   read(ifile, *) read_iasi_prior(1:nlevels)
END SELECT
end function read_iasi_prior
!
subroutine write_iasi_avg_kernel(ifile, avg_kernel_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(41), intent(in) :: avg_kernel_temp
character(len=*),        intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) avg_kernel_temp(1:nlevels_temp)
   CASE DEFAULT
   write(ifile, *) avg_kernel_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_avg_kernel
!
subroutine write_iasi_altitude(ifile, altitude_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(41), intent(in) :: altitude_temp
character(len=*),        intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) altitude_temp(1:nlevels_temp)
   CASE DEFAULT
   write(ifile, *) altitude_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_altitude
!
subroutine write_iasi_pressure(ifile, pressure_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(41), intent(in) :: pressure_temp
character(len=*),        intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) pressure_temp(1:nlevels_temp)
   CASE DEFAULT
   write(ifile, *) pressure_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_pressure
!
subroutine write_iasi_air_column(ifile, air_column_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(41), intent(in) :: air_column_temp
character(len=*),        intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) air_column_temp(1:nlevels_temp)
   CASE DEFAULT
   write(ifile, *) air_column_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_air_column
!
subroutine write_iasi_prior(ifile, prior_temp, nlevels_temp, fform)
integer,                 intent(in) :: ifile, nlevels_temp
real(r8), dimension(41), intent(in) :: prior_temp
character(len=*),        intent(in) :: fform
!
character(len=32)  :: fileformat
!
if ( .not. module_initialized ) call initialize_module
!
fileformat = trim(adjustl(fform))
SELECT CASE (fileformat)
   CASE("unf", "UNF", "unformatted", "UNFORMATTED")
   write(ifile) prior_temp(1:nlevels_temp)
   CASE DEFAULT
   write(ifile, *) prior_temp(1:nlevels_temp)
END SELECT
end subroutine write_iasi_prior
!
subroutine wrf_dart_ubval_interp(obs_val,del_prs,domain,species,lon,lat,lev,im2,istatus)
   use netcdf
   implicit none
   integer,parameter                                 :: nx1=2,ny1=96,nz1=38,nm1=12,nmspc1=8,nchr1=20
   integer,parameter                                 :: nx2=100,ny2=40,nz2=66,nm2=12
   integer                                           :: fid1,fid2,domain,rc,im2
   integer                                           :: i,j,k,imn1,istatus
   character(len=20)                                 :: species
   character(len=180)                                :: file_nam,file_in1,file_in2,path
   real(r8)                                          :: lon,lat,lev,del_lon1
   real(r8)                                          :: obs_val,del_prs
   real,dimension(nx1,ny1)                           :: xlon1,xlat1
   real,dimension(ny1)                               :: xlat_tmp1
   real,dimension(nz1)                               :: xlev1,prs_tmp1
   real,dimension(ny1,nz1)                           :: fld1,fld_tmp1
   real,dimension(nx1,ny1,nz1)                       :: fldd1
   real,dimension(nx2,ny2)                           :: xlat2,xlon2
   real,dimension(nz2)                               :: xlev2,prs_tmp2
   real,dimension(nm2)                               :: ddoyr
   real,dimension(nx2,ny2,nz2,nm2)                   :: o3_col_dens
   real,dimension(nx2,ny2,nz2)                       :: fld_tmp2
   logical                                           :: use_interp_1
!
! decide with upper boundary data to use
   use_interp_1=.true.
   del_lon1=2.
!
! assign upper boundary profile files
   path='./'
!
! this file has OX NOX HNO3 CH4 CO N2X N2O5 H20
   file_in1='ubvals_b40.20th.track1_1996-2005.nc'
!
! this file has o3 only
   file_in2='exo_coldens_d01'
   if(domain.eq.2) then
      file_in2='exo_coldens_d02'
   endif
!
! open upper boundary profile files
   if (use_interp_1) then
      file_nam=trim(path)//trim(file_in1)
      rc = nf90_open(trim(file_nam),NF90_NOWRITE,fid1)
      if(rc.ne.0) then
         print *, 'APM: nc_open error file=',trim(file_nam)
         call abort
      endif
!      print *, 'opened ',trim(file_nam)
   else
      file_nam=trim(path)//trim(file_in2)
      rc = nf90_open(trim(file_nam),NF90_NOWRITE,fid2)
      if(rc.ne.0) then
         print *, 'APM: nc_open error file=',trim(file_nam)
         call abort
      endif
!      print *, 'opened ',trim(file_nam)
   endif
!
! select upper boundary data from ubvals_b40.20th.track1_1996-2005.nc
   if (use_interp_1) then
      imn1=6
      call apm_get_ubvals(fid1,species,imn1,fld1,xlat_tmp1,xlev1)
      rc=nf90_close(fid1)
   else
!
! select upper boundary data from exo_coldens_dxx
      call apm_get_exo_coldens(fid2,'XLAT',xlat2,nx2,ny2,1,1)
!      print *, 'XLAT',xlat2(1,1),xlat2(nx2,ny2)
      call apm_get_exo_coldens(fid2,'XLONG',xlon2,nx2,ny2,1,1)
!      print *, 'XLON',xlon2(1,1),xlon2(nx2,ny2)
      call apm_get_exo_coldens(fid2,'coldens_levs',xlev2,nz2,1,1,1)
!      print *, 'coldens_levs',xlev2(:)
      call apm_get_exo_coldens(fid2,'days_of_year',ddoyr,nm2,1,1,1)
!      print *, 'ddoyr',ddoyr(1),ddoyr(nm2)
      call apm_get_exo_coldens(fid2,'o3_column_density',o3_col_dens,nx2,ny2,nz2,nm2)
!      print *, 'o3_coldens',o3_col_dens(1,1,1,1),o3_col_dens(nx2,ny2,nz2,nm2)
      rc=nf90_close(fid2)
   endif
!   print *, 'ny1,nz1 ',ny1,nz1
!   print *, 'fld1 ',fld1
!   print *, 'xlat1 ',xlat1
!   print *, 'xlev1 ',xlev1
!
! convert longitude to 0 - 360
   if (.not.  use_interp_1) then
      do i=1,nx2
         do j=1,ny2
            if(xlon2(i,j).lt.0.) then
               xlon2(i,j)=xlon2(i,j)+360.
            endif
         enddo
      enddo
   endif
!
! invert the pressure grid and data
   if (use_interp_1) then
      do k=1,nz1
         prs_tmp1(nz1-k+1)=xlev1(k)
         do j=1,ny1
            fld_tmp1(j,nz1-k+1)=fld1(j,k)
         enddo
      enddo
      xlev1(1:nz1)=prs_tmp1(1:nz1)*100.
      fldd1(1,1:ny1,1:nz1)=fld_tmp1(1:ny1,1:nz1)
      fldd1(2,1:ny1,1:nz1)=fld_tmp1(1:ny1,1:nz1)
!
! interpolate data1 to (lat,lev) point
      do j=1,ny1
         xlon1(1,j)=lon-del_lon1
         xlon1(2,j)=lon+del_lon1
         if(lon.lt.0.) then
            xlon1(1,j)=lon+360.-del_lon1
            xlon1(2,j)=lon+360.+del_lon1
         endif
         do i=1,nx1
            xlat1(i,j)=xlat_tmp1(j)
         enddo
      enddo
!      print *, 'IN UBVAL SUB: lon,lat,lev ',lon,lat,lev
!      print *, 'IN UBVAL SUB: xlon,xlat,xlev ',xlon1(1,48),xlat1(1,48)
!      do j=1,nz1
!        print *, 'IN UBVAL SUB: fldd1 ',j,xlev1(j),fldd1(1,48,j)
!      enddo
      call apm_interpolate(obs_val,del_prs,lon,lat,lev,xlon1,xlat1,xlev1, &
      fldd1,nx1,ny1,nz1,istatus)
!      print *, 'IN UBVAL SUB: obs_val,del_prs ',obs_val,del_prs
   else
      do k=1,nz2
         prs_tmp2(nz2-k+1)=xlev2(k)
         do i=1,nx2
            do j=1,ny2
               fld_tmp2(i,j,nz2-k+1)=o3_col_dens(i,j,k,im2)
            enddo
         enddo
      enddo
      xlev2(1:nz2)=prs_tmp2(1:nz2)
      o3_col_dens(1:nx2,1:ny2,1:nz2,im2)=fld_tmp2(1:nx2,1:ny2,1:nz2)
!
! interpolate data2 to (lat,lon,lev) point
      call apm_interpolate(obs_val,del_prs,lon,lat,lev,xlon2,xlat2,xlev2, &
      o3_col_dens(1,1,1,im2),nx2,ny2,nz2,istatus)
   endif
end subroutine wrf_dart_ubval_interp
!
subroutine apm_get_exo_coldens(fid,fldname,dataf,nx,ny,nz,nm)
   use netcdf
   implicit none
   integer,parameter                      :: maxdim=4
   integer                                :: nx,ny,nz,nm
   integer                                :: i,rc,v_ndim,natts,fid
   integer                                :: v_id,typ
   integer,dimension(maxdim)              :: v_dimid,v_dim,one
   character(len=*)                       :: fldname
   character(len=180)                     :: vnam
   real,dimension(nx,ny,nz,nm)            :: dataf
!
! get variables identifiers
   rc = nf90_inq_varid(fid,trim(fldname),v_id)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error'
      call abort
   endif
!
! get dimension identifiers
   v_dimid=0
   rc = nf90_inquire_variable(fid,v_id,vnam,typ,v_ndim,v_dimid,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error'
      call abort
   endif
   if(maxdim.lt.v_ndim) then
      print *, 'ERROR: maxdim is too small ',maxdim,v_ndim
      call abort
   endif
!
! get dimensions
   v_dim(:)=1
   do i=1,v_ndim
      rc = nf90_inquire_dimension(fid,v_dimid(i),len=v_dim(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error'
         call abort
      endif
   enddo
!
! check dimensions
   if(nx.ne.v_dim(1)) then
      print *, 'ERROR: nx dimension conflict ',nx,v_dim(1)
      call abort
   else if(ny.ne.v_dim(2)) then
      print *, 'ERROR: ny dimension conflict ',ny,v_dim(2)
      call abort
   else if(nz.ne.v_dim(3)) then
      print *, 'ERROR: nz dimension conflict ',nz,v_dim(3)
      call abort
   else if(nm.ne.v_dim(4)) then
      print *, 'ERROR: nm dimension conflict ',nm,v_dim(4)
      call abort
   endif
!
! get data
   one(:)=1
   rc = nf90_get_var(fid,v_id,dataf,one,v_dim)
end subroutine apm_get_exo_coldens
!
subroutine apm_get_ubvals(fid,species,imn,dataf,lats,levs)
   use netcdf
   implicit none
   integer,parameter                                 :: maxdim=4
   integer,parameter                                 :: ny1=96,nz1=38,nm1=12,nmspc1=8,nmchr1=20
   integer                                           :: i,j,idx,fid,rc,typ,natts,imn
   integer                                           :: vid1,vid2,vid3,vid4,vid5
   integer                                           :: vndim1,vndim2,vndim3,vndim4,vndim5
   integer,dimension(maxdim)                         :: vdimid1,vdimid2,vdimid3,vdimid4,vdimid5
   integer,dimension(maxdim)                         :: one,vdim1,vdim2,vdim3,vdim4,vdim5
   integer,dimension(nm1)                            :: mths
   character(len=20)                                 :: species
   character(len=nmchr1),dimension(nmchr1,nmspc1)    :: spcs
   character(len=180)                                :: vnam1,vnam2,vnam3,vnam4,vnam5
   real,dimension(ny1)                               :: lats
   real,dimension(nz1)                               :: levs
   real,dimension(ny1,nmspc1,nm1,nz1)                :: vmrs
   real,dimension(ny1,nz1)                           :: dataf
!
! get variables identifiers
   rc = nf90_inq_varid(fid,'lat',vid1)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error_1'
      call abort
   endif
   rc = nf90_inq_varid(fid,'lev',vid2)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error_2'
      call abort
   endif
   rc = nf90_inq_varid(fid,'month',vid3)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error_3'
      call abort
   endif
   rc = nf90_inq_varid(fid,'specname',vid4)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error_4'
      call abort
   endif
   rc = nf90_inq_varid(fid,'vmr',vid5)
   if(rc.ne.0) then
      print *, 'APM: nf_inq_varid error_5'
      call abort
   endif
!
! get dimension identifiers
   vdimid1=0
   rc = nf90_inquire_variable(fid,vid1,vnam1,typ,vndim1,vdimid1,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error_1'
      call abort
   endif
   vdimid2=0
   rc = nf90_inquire_variable(fid,vid2,vnam2,typ,vndim2,vdimid2,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error_2'
      call abort
   endif
   vdimid3=0
   rc = nf90_inquire_variable(fid,vid3,vnam3,typ,vndim3,vdimid3,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error_3'
      call abort
   endif
   vdimid4=0
   rc = nf90_inquire_variable(fid,vid4,vnam4,typ,vndim4,vdimid4,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error_4'
      call abort
   endif
   vdimid5=0
   rc = nf90_inquire_variable(fid,vid5,vnam5,typ,vndim5,vdimid5,natts)
   if(rc.ne.0) then
      print *, 'APM: nc_inq_var error_5'
      call abort
   endif
!
! test the number of dimensions
   if(1.lt.vndim1) then
      print *, 'ERROR: maxdim is too small 1 ',1,vndim1
      call abort
   endif
   if(1.lt.vndim2) then
      print *, 'ERROR: maxdim is too small 2 ',1,vndim2
      call abort
   endif
   if(1.lt.vndim3) then
      print *, 'ERROR: maxdim is too small 3 ',1,vndim3
      call abort
   endif
   if(2.lt.vndim4) then
      print *, 'ERROR: maxdim is too small 4',1,vndim4
      call abort
   endif
   if(4.lt.vndim5) then
      print *, 'ERROR: maxdim is too small 5',1,vndim5
      call abort
   endif
!
! get dimensions
   vdim1(:)=1
   do i=1,vndim1
      rc = nf90_inquire_dimension(fid,vdimid1(i),len=vdim1(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error_1'
         call abort
      endif
   enddo
   vdim2(:)=1
   do i=1,vndim2
      rc = nf90_inquire_dimension(fid,vdimid2(i),len=vdim2(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error_2'
         call abort
      endif
   enddo
   vdim3(:)=1
   do i=1,vndim3
      rc = nf90_inquire_dimension(fid,vdimid3(i),len=vdim3(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error_3'
         call abort
      endif
   enddo
   vdim4(:)=1
   do i=1,vndim4
      rc = nf90_inquire_dimension(fid,vdimid4(i),len=vdim4(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error_4'
         call abort
      endif
   enddo
   vdim5(:)=1
   do i=1,vndim5
      rc = nf90_inquire_dimension(fid,vdimid5(i),len=vdim5(i))
      if(rc.ne.0) then
         print *, 'APM: nf_inq_dimlen error_5'
         call abort
      endif
   enddo
!
! check dimensions
   if(ny1.ne.vdim1(1)) then
      print *, 'ERROR: ny1 dimension conflict 1 ',ny1,vdim1(1)
      call abort
   else if(nz1.ne.vdim2(1)) then
      print *, 'ERROR: nz1 dimension conflict 2 ',nz1,vdim2(1)
      call abort
   else if(nm1.ne.vdim3(1)) then
      print *, 'ERROR: nm1 dimension conflict 3 ',nm1,vdim3(1)
      call abort
   endif
   if(nmchr1.ne.vdim4(1)) then
      print *, 'ERROR: nmchr1 dimension conflict 4 ',nmchr1,vdim4(1)
      call abort
   else if(nmspc1.ne.vdim4(2)) then
      print *, 'ERROR: nmspc1 dimension conflict 4 ',nmspc1,vdim4(2)
      call abort
   endif
   if(ny1.ne.vdim5(1)) then
      print *, 'ERROR: ny1 dimension conflict 5 ',ny1,vdim5(1)
      call abort
   else if(nmspc1.ne.vdim5(2)) then
      print *, 'ERROR: nmspc1 dimension conflict 5 ',nmspc1,vdim5(2)
      call abort
   else if(nm1.ne.vdim5(3)) then
      print *, 'ERROR: nm1 dimension conflict 5 ',nm1,vdim5(3)
      call abort
   else if(nz1.ne.vdim5(4)) then
      print *, 'ERROR: nz1 dimension conflict 5 ',nz1,vdim5(4)
      call abort
   endif
!
! get data
   one(:)=1
   rc = nf90_get_var(fid,vid1,lats,one,vdim1)
   if(rc.ne.0) then
      print *, 'APM: get_var error_1'
      call abort
   endif
!   print *, 'lats ',lats
   one(:)=1
   rc = nf90_get_var(fid,vid2,levs,one,vdim2)
   if(rc.ne.0) then
      print *, 'APM: get_var error_2'
      call abort
   endif
!   print *, 'levs ',levs
   one(:)=1
   rc = nf90_get_var(fid,vid3,mths,one,vdim3)
   if(rc.ne.0) then
      print *, 'APM: get_var error_3'
      call abort
   endif
!   print *, 'mths ',mths
   one(:)=1
   rc = nf90_get_var(fid,vid4,spcs,one,vdim4)
   if(rc.ne.0) then
      print *, 'APM: get_var error_4'
      call abort
   endif
!   print *, 'spcs ',spcs
   one(:)=1
   rc = nf90_get_var(fid,vid5,vmrs,one,vdim5)
   if(rc.ne.0) then
      print *, 'APM: get_var error_5'
      call abort
   endif
!   print *, 'vmrs ',vmrs
!
! locate requested field
  do i=1,nmspc1
     if(trim(species).eq.trim(spcs(i,1))) then
        idx=i
        exit
     endif
  enddo
   do i=1,ny1
      do j=1,nz1
         dataf(i,j)=vmrs(i,idx,imn,j)
      enddo
   enddo
end subroutine apm_get_ubvals
!
subroutine apm_interpolate(obs_val,del_prs,lon,lat,lev,xlon,xlat,xlev,dataf,nx,ny,nz,istatus)
!
! longitude and latitude must be in degrees
! pressure grid must be in hPa and go from bottom to top
!
   implicit none
   integer                                :: nx,ny,nz,nzm,istatus
   integer                                :: i,j,k,im,ip,jm,jp,quad
   integer                                :: k_lw,k_up,i_min,j_min
   real(r8)                               :: obs_val,del_prs
   real(r8)                               :: lon,lat,lev
   real                                   :: l_lon,l_lat,l_lev
   real                                   :: fld_lw,fld_up
   real                                   :: xlnp_lw,xlnp_up,xlnp_pt
   real                                   :: dz_lw,dz_up
   real                                   :: mop_x,mop_y
   real                                   :: re,pi,rad2deg
   real                                   :: rad,rad_crit,rad_min,mod_x,mod_y
   real                                   :: dx_dis,dy_dis
   real                                   :: w_q1,w_q2,w_q3,w_q4,wt
   real,dimension(nz)                     :: xlev
   real,dimension(nx,ny)                  :: xlon,xlat
   real,dimension(nx,ny,nz)               :: dataf
!
! set constants
   pi=4.*atan(1.)
   rad2deg=360./(2.*pi)
   re=6371000.
   rad_crit=200000.
   quad=0
!
! find the closest point
   rad_min=1.e10
   l_lon=lon
   l_lat=lat
   l_lev=lev
   if(l_lon.lt.0.) l_lon=l_lon+360.
!   print *, 'lon,lat,lev ',l_lon,l_lat,l_lev
!
   do i=1,nx
      do j=1,ny
         mod_x=(xlon(i,j))/rad2deg
         if(xlon(i,j).lt.0.) mod_x=(360.+xlon(i,j))/rad2deg
         mod_y=xlat(i,j)/rad2deg
         mop_x=l_lon/rad2deg
         mop_y=l_lat/rad2deg
         dx_dis=abs(mop_x-mod_x)*cos((mop_y+mod_y)/2.)*re
         dy_dis=abs(mop_y-mod_y)*re
         rad=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
         rad_min=min(rad_min,rad)
         if(rad.eq.rad_min) then
            i_min=i
            j_min=j
         endif
      enddo
   enddo
   if(rad_min.gt.rad_crit) then
      print *, 'APM: ERROR in intrp - min dist exceeds threshold ',rad_min, rad_crit
      print *, 'grid ',i_min,j_min,xlon(i_min,j_min),xlat(i_min,j_min)
      print *, 'point ',l_lon,l_lat
      istatus=2
      return
!      call abort
   endif
!
! do interpolation
   im=i_min-1
   if(im.eq.0) im=1
   ip=i_min+1
   if(ip.eq.nx+1) ip=nx
   jm=j_min-1
   if(jm.eq.0) jm=1
   jp=j_min+1
   if(jp.eq.ny+1) jp=ny
!
! find quadrant and interpolation weights
   quad=0
   mod_x=xlon(i_min,j_min)
   if(xlon(i_min,j_min).lt.0.) mod_x=xlon(i_min,j_min)+360.
   mod_y=xlat(i_min,j_min)
   if(mod_x.ge.l_lon.and.mod_y.ge.l_lat) quad=1
   if(mod_x.le.l_lon.and.mod_y.ge.l_lat) quad=2
   if(mod_x.le.l_lon.and.mod_y.le.l_lat) quad=3
   if(mod_x.ge.l_lon.and.mod_y.le.l_lat) quad=4
   if(quad.eq.0) then
      print *, 'APM: ERROR IN INTERPOLATE quad = 0 '
      call abort
   endif
!
! Quad 1
   if (quad.eq.1) then
      mod_x=xlon(i_min,j_min)
      if(xlon(i_min,j_min).lt.0.) mod_x=360.+xlon(i_min,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,j_min))/rad2deg*re
      w_q1=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(im,j_min)
      if(xlon(im,j_min).lt.0.) mod_x=360.+xlon(im,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(im,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(im,j_min))/rad2deg*re
      w_q2=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(im,jm)
      if(xlon(im,jm).lt.0.) mod_x=360.+xlon(im,jm)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(im,jm))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(im,jm))/rad2deg*re
      w_q3=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,jm)
      if(xlon(i_min,jm).lt.0.) mod_x=360.+xlon(i_min,jm)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,jm))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,jm))/rad2deg*re
      w_q4=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
! Quad 2
   else if (quad.eq.2) then
      mod_x=xlon(ip,j_min)
      if(xlon(ip,j_min).lt.0.) mod_x=360.+xlon(ip,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(ip,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(ip,j_min))/rad2deg*re
      w_q1=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,j_min)
      if(xlon(i_min,j_min).lt.0.) mod_x=360.+xlon(i_min,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,j_min))/rad2deg*re
      w_q2=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,jm)
      if(xlon(i_min,jm).lt.0.) mod_x=360.+xlon(i_min,jm)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,jm))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,jm))/rad2deg*re
      w_q3=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(ip,jm)
      if(xlon(ip,jm).lt.0.) mod_x=360.+xlon(ip,jm)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(ip,jm))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(ip,jm))/rad2deg*re
      w_q4=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
! Quad 3
   else if (quad.eq.3) then
      mod_x=xlon(ip,jp)
      if(xlon(ip,jp).lt.0.) mod_x=360.+xlon(ip,jp)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(ip,jp))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(ip,jp))/rad2deg*re
      w_q1=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,jp)
      if(xlon(i_min,jp).lt.0.) mod_x=360.+xlon(i_min,jp)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,jp))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,jp))/rad2deg*re
      w_q2=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,j_min)
      if(xlon(i_min,j_min).lt.0.) mod_x=360.+xlon(i_min,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,j_min))/rad2deg*re
      w_q3=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(ip,j_min)
      if(xlon(ip,j_min).lt.0.) mod_x=360.+xlon(ip,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(ip,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(ip,j_min))/rad2deg*re
      w_q4=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
! Quad 4
   else if (quad.eq.4) then
      mod_x=xlon(i_min,jp)
      if(xlon(i_min,jp).lt.0.) mod_x=360.+xlon(i_min,jp)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,jp))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,jp))/rad2deg*re
      w_q1=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(im,jp)
      if(xlon(im,jp).lt.0.) mod_x=360.+xlon(im,jp)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(im,jp))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(im,jp))/rad2deg*re
      w_q2=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(im,jm)
      if(xlon(im,jm).lt.0.) mod_x=360.+xlon(im,jm)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(im,jm))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(im,jm))/rad2deg*re
      w_q3=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
      mod_x=xlon(i_min,j_min)
      if(xlon(i_min,j_min).lt.0.) mod_x=360.+xlon(i_min,j_min)
      dx_dis=abs(l_lon-mod_x)/rad2deg*cos((l_lat+xlat(i_min,j_min))/rad2deg/2.)*re
      dy_dis=abs(l_lat-xlat(i_min,j_min))/rad2deg*re
      w_q4=sqrt(dx_dis*dx_dis + dy_dis*dy_dis)
   endif
   if(l_lon.ne.xlon(i_min,j_min).or.l_lat.ne.xlat(i_min,j_min)) then
      wt=1./w_q1+1./w_q2+1./w_q3+1./w_q4
   endif
!
! find vertical indexes
   nzm=nz-1
   k_lw=-1
   k_up=-1
   do k=1,nzm
      if(k.eq.1 .and. l_lev.gt.xlev(k)) then
         k_lw=k
         k_up=k
         exit
      endif
      if(l_lev.le.xlev(k) .and. l_lev.gt.xlev(k+1)) then
         k_lw=k
         k_up=k+1
         exit
      endif
      if(k.eq.nzm .and. l_lev.ge.xlev(k+1)) then
         k_lw=k+1
         k_up=k+1
         exit
      endif
   enddo
   if(k_lw.le.0 .or. k_up.le.0) then
      print *, 'APM: ERROR IN K_LW OR K_UP ',k_lw,k_up
      call abort
   endif
!
! horizontal interpolation
   fld_lw=0.
   fld_up=0.
   if(l_lon.eq.xlon(i_min,j_min).and.l_lat.eq.xlat(i_min,j_min)) then
      fld_lw=dataf(i_min,j_min,k_lw)
      fld_up=dataf(i_min,j_min,k_up)
   else if(quad.eq.1) then
      fld_lw=(1./w_q1*dataf(i_min,j_min,k_lw)+1./w_q2*dataf(im,j_min,k_lw)+ &
      1./w_q3*dataf(im,jm,k_lw)+1./w_q4*dataf(i_min,jm,k_lw))/wt
      fld_up=(1./w_q1*dataf(i_min,j_min,k_up)+1./w_q2*dataf(im,j_min,k_up)+ &
      1./w_q3*dataf(im,jm,k_up)+1./w_q4*dataf(i_min,jm,k_up))/wt
   else if(quad.eq.2) then
      fld_lw=(1./w_q1*dataf(ip,j_min,k_lw)+1./w_q2*dataf(i_min,j_min,k_lw)+ &
      1./w_q3*dataf(i_min,jm,k_lw)+1./w_q4*dataf(ip,jm,k_lw))/wt
      fld_up=(1./w_q1*dataf(ip,j_min,k_up)+1./w_q2*dataf(i_min,j_min,k_up)+ &
      1./w_q3*dataf(i_min,jm,k_up)+1./w_q4*dataf(ip,jm,k_up))/wt
   else if(quad.eq.3) then
      fld_lw=(1./w_q1*dataf(ip,jp,k_lw)+1./w_q2*dataf(i_min,jp,k_lw)+ &
      1./w_q3*dataf(i_min,j_min,k_lw)+1./w_q4*dataf(ip,j_min,k_lw))/wt
      fld_up=(1./w_q1*dataf(ip,jp,k_up)+1./w_q2*dataf(i_min,jp,k_up)+ &
      1./w_q3*dataf(i_min,j_min,k_up)+1./w_q4*dataf(ip,j_min,k_up))/wt
   else if(quad.eq.4) then
      fld_lw=(1./w_q1*dataf(i_min,jp,k_lw)+1./w_q2*dataf(im,jp,k_lw)+ &
      1./w_q3*dataf(im,j_min,k_lw)+1./w_q4*dataf(i_min,j_min,k_lw))/wt
      fld_up=(1./w_q1*dataf(i_min,jp,k_up)+1./w_q2*dataf(im,jp,k_up)+ &
      1./w_q3*dataf(im,j_min,k_up)+1./w_q4*dataf(i_min,j_min,k_up))/wt
   endif
!   print *,'fld_lw ',fld_lw
!   print *,'fld_up ',fld_up
!
! vertical interpolation
!   print *,'p_lw,p_up,p ',xlev(k_lw),xlev(k_up),l_lev

   xlnp_lw=log(xlev(k_lw))
   xlnp_up=log(xlev(k_up))
   xlnp_pt=log(l_lev)
   dz_lw=xlnp_lw-xlnp_pt
   dz_up=xlnp_pt-xlnp_up
   if(dz_lw.eq.0.) then
      obs_val=fld_lw
   else if(dz_up.eq.0.) then
      obs_val=fld_up
   else if(dz_lw.ne.0. .and. dz_up.ne.0.) then
      obs_val=(1./dz_lw*fld_lw+1./dz_up*fld_up)/(1./dz_lw+1./dz_up)
   endif
   del_prs=xlev(k_lw)-xlev(k_up)
end subroutine apm_interpolate


end module obs_def_iasi_O3_mod

                                                                              
!---------------------------------------------------------------------------  
! End of code inserted from ../../../obs_def/obs_def_IASI_O3_mod.f90
!---------------------------------------------------------------------------  

!----------------------------------------------------------------------
! End of any user-defined executable module code
!----------------------------------------------------------------------
!----------------------------------------------------------------------

!----------------------------------------------------------------------
!----------------------------------------------------------------------
! Start of main obs_def_mod module code
!----------------------------------------------------------------------

module obs_def_mod

! Contains the basic parts of a module for defining and evaluating observation
! definitions. Can evaluate identity observations as is. The DART preprocess
! program is used to add in extra observation kinds at the indicated spots in
! the code.

use        types_mod, only : r8, missing_i, missing_r8
use    utilities_mod, only : register_module, error_handler, E_ERR, &
                             ascii_file_format
use     location_mod, only : location_type, read_location, write_location, &
                             interactive_location, set_location_missing
use time_manager_mod, only : time_type, read_time, write_time, &
                             set_time_missing, interactive_time
use  assim_model_mod, only : get_state_meta_data, interpolate
use     obs_kind_mod, only : assimilate_this_obs_kind, evaluate_this_obs_kind, &
                             get_obs_kind_name, map_def_index, &
                             get_kind_from_menu

!----------------------------------------------------------------------
! This list is autogenerated by the 'preprocess' program.  To add types
! or kinds, edit the obs_def_xxx_mod.f90 files, and then add/remove them
! from the 'input_files' variable of the &preprocess_nml namelist
! in the model-specific work/input.nml file.
!
! Start of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!---------------------------------------------------------------------------  
                                                                              
use obs_kind_mod, only : RADIOSONDE_U_WIND_COMPONENT
use obs_kind_mod, only : RADIOSONDE_V_WIND_COMPONENT
use obs_kind_mod, only : RADIOSONDE_GEOPOTENTIAL_HGT
use obs_kind_mod, only : RADIOSONDE_SURFACE_PRESSURE
use obs_kind_mod, only : RADIOSONDE_TEMPERATURE
use obs_kind_mod, only : RADIOSONDE_SPECIFIC_HUMIDITY
use obs_kind_mod, only : DROPSONDE_U_WIND_COMPONENT
use obs_kind_mod, only : DROPSONDE_V_WIND_COMPONENT
use obs_kind_mod, only : DROPSONDE_SURFACE_PRESSURE
use obs_kind_mod, only : DROPSONDE_TEMPERATURE
use obs_kind_mod, only : DROPSONDE_SPECIFIC_HUMIDITY
use obs_kind_mod, only : AIRCRAFT_U_WIND_COMPONENT
use obs_kind_mod, only : AIRCRAFT_V_WIND_COMPONENT
use obs_kind_mod, only : AIRCRAFT_TEMPERATURE
use obs_kind_mod, only : AIRCRAFT_SPECIFIC_HUMIDITY
use obs_kind_mod, only : ACARS_U_WIND_COMPONENT
use obs_kind_mod, only : ACARS_V_WIND_COMPONENT
use obs_kind_mod, only : ACARS_TEMPERATURE
use obs_kind_mod, only : ACARS_SPECIFIC_HUMIDITY
use obs_kind_mod, only : MARINE_SFC_U_WIND_COMPONENT
use obs_kind_mod, only : MARINE_SFC_V_WIND_COMPONENT
use obs_kind_mod, only : MARINE_SFC_TEMPERATURE
use obs_kind_mod, only : MARINE_SFC_SPECIFIC_HUMIDITY
use obs_kind_mod, only : MARINE_SFC_PRESSURE
use obs_kind_mod, only : LAND_SFC_U_WIND_COMPONENT
use obs_kind_mod, only : LAND_SFC_V_WIND_COMPONENT
use obs_kind_mod, only : LAND_SFC_TEMPERATURE
use obs_kind_mod, only : LAND_SFC_SPECIFIC_HUMIDITY
use obs_kind_mod, only : LAND_SFC_PRESSURE
use obs_kind_mod, only : SAT_U_WIND_COMPONENT
use obs_kind_mod, only : SAT_V_WIND_COMPONENT
use obs_kind_mod, only : ATOV_TEMPERATURE
use obs_kind_mod, only : AIRS_TEMPERATURE
use obs_kind_mod, only : AIRS_SPECIFIC_HUMIDITY
use obs_kind_mod, only : GPS_PRECIPITABLE_WATER
use obs_kind_mod, only : DOPPLER_RADIAL_VELOCITY
use obs_kind_mod, only : RADAR_REFLECTIVITY
use obs_kind_mod, only : RADAR_CLEARAIR_REFLECTIVITY
use obs_kind_mod, only : PRECIPITATION_FALL_SPEED
use obs_kind_mod, only : METAR_U_10_METER_WIND
use obs_kind_mod, only : METAR_V_10_METER_WIND
use obs_kind_mod, only : METAR_TEMPERATURE_2_METER
use obs_kind_mod, only : METAR_SPECIFIC_HUMIDITY_2_METER
use obs_kind_mod, only : METAR_SURFACE_PRESSURE
use obs_kind_mod, only : METAR_POT_TEMP_2_METER
use obs_kind_mod, only : DEWPOINT
use obs_kind_mod, only : DEWPOINT_2_METER
use obs_kind_mod, only : BUOY_DEWPOINT
use obs_kind_mod, only : SHIP_DEWPOINT
use obs_kind_mod, only : SYNOP_DEWPOINT
use obs_kind_mod, only : AIREP_DEWPOINT
use obs_kind_mod, only : AMDAR_DEWPOINT
use obs_kind_mod, only : PILOT_DEWPOINT
use obs_kind_mod, only : BOGUS_DEWPOINT
use obs_kind_mod, only : AIRS_DEWPOINT
use obs_kind_mod, only : METAR_DEWPOINT_2_METER
use obs_kind_mod, only : RADIOSONDE_DEWPOINT
use obs_kind_mod, only : DROPSONDE_DEWPOINT
use obs_kind_mod, only : AIRCRAFT_DEWPOINT
use obs_kind_mod, only : ACARS_DEWPOINT
use obs_kind_mod, only : MARINE_SFC_DEWPOINT
use obs_kind_mod, only : LAND_SFC_DEWPOINT
use obs_kind_mod, only : RADIOSONDE_RELATIVE_HUMIDITY
use obs_kind_mod, only : DROPSONDE_RELATIVE_HUMIDITY
use obs_kind_mod, only : AIRCRAFT_RELATIVE_HUMIDITY
use obs_kind_mod, only : ACARS_RELATIVE_HUMIDITY
use obs_kind_mod, only : MARINE_SFC_RELATIVE_HUMIDITY
use obs_kind_mod, only : LAND_SFC_RELATIVE_HUMIDITY
use obs_kind_mod, only : METAR_RELATIVE_HUMIDITY_2_METER
use obs_kind_mod, only : AIRS_RELATIVE_HUMIDITY
use obs_kind_mod, only : RADIOSONDE_SURFACE_ALTIMETER
use obs_kind_mod, only : DROPSONDE_SURFACE_ALTIMETER
use obs_kind_mod, only : MARINE_SFC_ALTIMETER
use obs_kind_mod, only : LAND_SFC_ALTIMETER
use obs_kind_mod, only : METAR_ALTIMETER
use obs_kind_mod, only : TEMPERATURE
use obs_kind_mod, only : SPECIFIC_HUMIDITY
use obs_kind_mod, only : PRESSURE
use obs_kind_mod, only : GPSRO_REFRACTIVITY
use obs_kind_mod, only : COSMIC_ELECTRON_DENSITY
use obs_kind_mod, only : VORTEX_LAT
use obs_kind_mod, only : VORTEX_LON
use obs_kind_mod, only : VORTEX_PMIN
use obs_kind_mod, only : VORTEX_WMAX
use obs_kind_mod, only : BUOY_U_WIND_COMPONENT
use obs_kind_mod, only : BUOY_V_WIND_COMPONENT
use obs_kind_mod, only : BUOY_SURFACE_PRESSURE
use obs_kind_mod, only : BUOY_TEMPERATURE
use obs_kind_mod, only : SHIP_U_WIND_COMPONENT
use obs_kind_mod, only : SHIP_V_WIND_COMPONENT
use obs_kind_mod, only : SHIP_SURFACE_PRESSURE
use obs_kind_mod, only : SHIP_TEMPERATURE
use obs_kind_mod, only : SYNOP_U_WIND_COMPONENT
use obs_kind_mod, only : SYNOP_V_WIND_COMPONENT
use obs_kind_mod, only : SYNOP_SURFACE_PRESSURE
use obs_kind_mod, only : SYNOP_SPECIFIC_HUMIDITY
use obs_kind_mod, only : SYNOP_TEMPERATURE
use obs_kind_mod, only : AIREP_U_WIND_COMPONENT
use obs_kind_mod, only : AIREP_V_WIND_COMPONENT
use obs_kind_mod, only : AIREP_PRESSURE
use obs_kind_mod, only : AIREP_TEMPERATURE
use obs_kind_mod, only : AMDAR_U_WIND_COMPONENT
use obs_kind_mod, only : AMDAR_V_WIND_COMPONENT
use obs_kind_mod, only : AMDAR_PRESSURE
use obs_kind_mod, only : AMDAR_TEMPERATURE
use obs_kind_mod, only : PILOT_U_WIND_COMPONENT
use obs_kind_mod, only : PILOT_V_WIND_COMPONENT
use obs_kind_mod, only : PILOT_PRESSURE
use obs_kind_mod, only : PILOT_TEMPERATURE
use obs_kind_mod, only : BOGUS_U_WIND_COMPONENT
use obs_kind_mod, only : BOGUS_V_WIND_COMPONENT
use obs_kind_mod, only : BOGUS_PRESSURE
use obs_kind_mod, only : BOGUS_TEMPERATURE
use obs_kind_mod, only : PROFILER_U_WIND_COMPONENT
use obs_kind_mod, only : PROFILER_V_WIND_COMPONENT
use obs_kind_mod, only : PROFILER_PRESSURE
use obs_kind_mod, only : SATEM_THICKNESS
use obs_kind_mod, only : MONITOR_SO2
use obs_kind_mod, only : MONITOR_NO2
use obs_kind_mod, only : MONITOR_PM10
use obs_kind_mod, only : MONITOR_CO
use obs_kind_mod, only : MONITOR_O3
use obs_kind_mod, only : MONITOR_PM25
use obs_kind_mod, only : AIRNOW_CO
use obs_kind_mod, only : AIRNOW_SO2
use obs_kind_mod, only : AIRNOW_NO2
use obs_kind_mod, only : AIRNOW_NOy
use obs_kind_mod, only : AIRNOW_O3
use obs_kind_mod, only : AIRNOW_PM10
use obs_kind_mod, only : AIRNOW_PM25
use obs_kind_mod, only : AIRNOW_PB
use obs_kind_mod, only : AIRNOW_NMOC
use obs_kind_mod, only : AIRNOW_PRESSURE
use obs_kind_mod, only : AIRNOW_TEMPERATURE
use obs_kind_mod, only : AIRNOW_RELATIVE_HUMIDITY
use obs_kind_mod, only : AIRNOW_U_WIND_COMPONENT
use obs_kind_mod, only : AIRNOW_V_WIND_COMPONENT
use obs_kind_mod, only : PANDA_CO
use obs_kind_mod, only : PANDA_SO2
use obs_kind_mod, only : PANDA_NO2
use obs_kind_mod, only : PANDA_NOy
use obs_kind_mod, only : PANDA_O3
use obs_kind_mod, only : PANDA_PM10
use obs_kind_mod, only : PANDA_PM25
use obs_kind_mod, only : PANDA_PB
use obs_kind_mod, only : PANDA_NMOC
use obs_kind_mod, only : PANDA_PRESSURE
use obs_kind_mod, only : PANDA_TEMPERATURE
use obs_kind_mod, only : PANDA_RELATIVE_HUMIDITY
use obs_kind_mod, only : PANDA_U_WIND_COMPONENT
use obs_kind_mod, only : PANDA_V_WIND_COMPONENT
use obs_kind_mod, only : OMI_NO2_COLUMN
use obs_kind_mod, only : MODIS_AOD_RETRIEVAL
use obs_kind_mod, only : MOPITT_CO_RETRIEVAL
use obs_kind_mod, only : IASI_CO_RETRIEVAL
use obs_kind_mod, only : IASI_O3_RETRIEVAL
                                                                              
use obs_kind_mod, only : KIND_U_WIND_COMPONENT
use obs_kind_mod, only : KIND_V_WIND_COMPONENT
use obs_kind_mod, only : KIND_GEOPOTENTIAL_HEIGHT
use obs_kind_mod, only : KIND_SURFACE_PRESSURE
use obs_kind_mod, only : KIND_TEMPERATURE
use obs_kind_mod, only : KIND_SPECIFIC_HUMIDITY
use obs_kind_mod, only : KIND_PRECIPITABLE_WATER
use obs_kind_mod, only : KIND_VELOCITY
use obs_kind_mod, only : KIND_RADAR_REFLECTIVITY
use obs_kind_mod, only : KIND_POWER_WEIGHTED_FALL_SPEED
use obs_kind_mod, only : KIND_POTENTIAL_TEMPERATURE
use obs_kind_mod, only : KIND_DEWPOINT
use obs_kind_mod, only : KIND_RELATIVE_HUMIDITY
use obs_kind_mod, only : KIND_PRESSURE
use obs_kind_mod, only : KIND_GPSRO
use obs_kind_mod, only : KIND_ELECTRON_DENSITY
use obs_kind_mod, only : KIND_VORTEX_LAT
use obs_kind_mod, only : KIND_VORTEX_LON
use obs_kind_mod, only : KIND_VORTEX_PMIN
use obs_kind_mod, only : KIND_VORTEX_WMAX
use obs_kind_mod, only : KIND_SO2
use obs_kind_mod, only : KIND_NO2
use obs_kind_mod, only : KIND_PM10
use obs_kind_mod, only : KIND_CO
use obs_kind_mod, only : KIND_O3
use obs_kind_mod, only : KIND_PM25
use obs_kind_mod, only : KIND_NOy
use obs_kind_mod, only : KIND_PB
use obs_kind_mod, only : KIND_NMOC
use obs_kind_mod, only : KIND_AOD
                                                                              
!---------------------------------------------------------------------------  
                                                                              

!----------------------------------------------------------------------
! End of obs_def_xxx_mod specific types and kinds
!----------------------------------------------------------------------

!----------------------------------------------------------------------
! This section is autogenerated by the 'preprocess' program.
!
! Start of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------

! If any observation types required specialized code, the module code
! will have been added above, and now a use statement will be generated
! here so the generic obs_def_mod has access to the code.

  use obs_def_radar_mod, only : write_radial_vel, read_radial_vel,           &
                            interactive_radial_vel, get_expected_radial_vel, &
                            read_radar_ref, get_expected_radar_ref,          &
                            get_expected_fall_velocity
   use obs_def_dew_point_mod, only : get_expected_dew_point
   use obs_def_rel_humidity_mod, only : get_expected_relative_humidity
   use obs_def_altimeter_mod, only : get_expected_altimeter, compute_altimeter
  use obs_def_gps_mod, only : get_expected_gpsro_ref, interactive_gpsro_ref, &
                              read_gpsro_ref, write_gpsro_ref
   use obs_def_vortex_mod, only : get_expected_vortex_info
   use obs_def_gts_mod, only : get_expected_thickness
   use obs_def_monitor_mod, only : write_monitor_so2, read_monitor_so2, &
                                  interactive_monitor_so2, get_expected_monitor_so2

   use obs_def_monitor_mod, only : write_monitor_no2, read_monitor_no2, &
                                  interactive_monitor_no2, get_expected_monitor_no2

   use obs_def_monitor_mod, only : write_monitor_pm10, read_monitor_pm10, &
                                  interactive_monitor_pm10, get_expected_monitor_pm10

   use obs_def_monitor_mod, only : write_monitor_co, read_monitor_co, &
                                  interactive_monitor_co, get_expected_monitor_co

   use obs_def_monitor_mod, only : write_monitor_o3, read_monitor_o3, &
                                  interactive_monitor_o3, get_expected_monitor_o3

   use obs_def_monitor_mod, only : write_monitor_pm25, read_monitor_pm25, &
                                  interactive_monitor_pm25, get_expected_monitor_pm25

   use obs_def_omi_mod, only : write_omi_no2, read_omi_no2, &
                               interactive_omi_no2, get_expected_omi_no2, &
                               set_obs_def_omi_no2
   use obs_def_modis_mod, only : write_modis_aod, read_modis_aod, &
                                  interactive_modis_aod, get_expected_modis_aod, &
                                  set_obs_def_modis_aod
   use obs_def_mopitt_mod, only : write_mopitt_co, read_mopitt_co, &
                                  interactive_mopitt_co, get_expected_mopitt_co, &
                                  set_obs_def_mopitt_co
   use obs_def_iasi_co_mod, only : write_iasi_co, read_iasi_co, &
                                  interactive_iasi_co, get_expected_iasi_co, &
                                  set_obs_def_iasi_co
   use obs_def_iasi_O3_mod, only : write_iasi_o3, read_iasi_o3, &
                                  interactive_iasi_o3, get_expected_iasi_o3, &
                                  set_obs_def_iasi_o3

!----------------------------------------------------------------------
! End of any obs_def_xxx_mod specific use statements
!----------------------------------------------------------------------


implicit none
private

interface assignment(=)
   module procedure copy_obs_def
end interface

public :: init_obs_def, get_obs_def_key, get_obs_def_location, get_obs_kind, &
   get_obs_def_time, get_obs_def_error_variance, set_obs_def_location, &
   set_obs_def_kind, set_obs_def_time, set_obs_def_error_variance, &
   set_obs_def_key, interactive_obs_def, write_obs_def, read_obs_def, &
   obs_def_type, get_expected_obs_from_def, destroy_obs_def, copy_obs_def, &
   assignment(=), get_obs_name

! version controlled file description for error handling, do not edit
character(len=256), parameter :: source   = &
   "$URL$"
character(len=32 ), parameter :: revision = "$Revision$"
character(len=128), parameter :: revdate  = "$Date$"

type obs_def_type
! In revision, obs_kind module is responsible for taking care of
! identity obs kinds, too
   private
   type(location_type)   :: location   ! center of mass, so to speak
   integer               :: kind
   type(time_type)       :: time
   real(r8)              :: error_variance
   integer               :: key        ! Used by specialized observation types
end type obs_def_type

logical, save :: module_initialized = .false.

contains

!----------------------------------------------------------------------------

subroutine initialize_module

call register_module(source, revision, revdate)
module_initialized = .true.

! Note that there is no namelist for this module now that
! obs_kind has been revised

end subroutine initialize_module


!----------------------------------------------------------------------------

subroutine init_obs_def(obs_def, location, kind, time, error_variance)
! Need to add additional component arguments as optionals as needed

! Constructor for an obs_def

type(obs_def_type), intent(out) :: obs_def
type(location_type), intent(in) :: location
integer,             intent(in) :: kind
type(time_type),     intent(in) :: time
real(r8),            intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%location = location
obs_def%kind = kind
obs_def%time = time
obs_def%error_variance = error_variance
! No key assigned for standard observation defs
obs_def%key = -1

end subroutine init_obs_def

!---------------------------------------------------------------------

subroutine copy_obs_def(obs_def1, obs_def2)

! Copy function to be overloaded with '='

type(obs_def_type), intent(out) :: obs_def1
type(obs_def_type), intent(in) :: obs_def2

if ( .not. module_initialized ) call initialize_module

obs_def1%location       = obs_def2%location
obs_def1%kind           = obs_def2%kind
obs_def1%time           = obs_def2%time
obs_def1%error_variance = obs_def2%error_variance
obs_def1%key            = obs_def2%key
!deallocate(obs_def1%platform_qc)
!allocate(obs_def1%platform_qc(size(obs_def2%platform_qc))
! Should this be pointer assignment or regular
!obs_def1%platform_qc >= or == obs_def2%platform_qc
!obs_def1%aperture = obs_def2%aperture

end subroutine copy_obs_def

!----------------------------------------------------------------------------

function get_obs_def_key(obs_def)

type(obs_def_type), intent(in) :: obs_def
integer                        :: get_obs_def_key

if ( .not. module_initialized ) call initialize_module

get_obs_def_key = obs_def%key

end function get_obs_def_key

!----------------------------------------------------------------------------

function get_obs_def_error_variance(obs_def)

type(obs_def_type), intent(in) :: obs_def
real(r8)                       :: get_obs_def_error_variance

if ( .not. module_initialized ) call initialize_module

get_obs_def_error_variance = obs_def%error_variance

end function get_obs_def_error_variance

!----------------------------------------------------------------------------

function get_obs_def_location(obs_def)

! Returns observation location.

type(location_type)            :: get_obs_def_location
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_location = obs_def%location

end function get_obs_def_location

!----------------------------------------------------------------------------

function get_obs_kind(obs_def)

! Returns observation kind

integer                        :: get_obs_kind
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_kind = obs_def%kind

end function get_obs_kind

!----------------------------------------------------------------------------

function get_obs_def_time(obs_def)

! Returns observation time

type(time_type)                :: get_obs_def_time
type(obs_def_type), intent(in) :: obs_def

if ( .not. module_initialized ) call initialize_module

get_obs_def_time = obs_def%time

end function get_obs_def_time

!----------------------------------------------------------------------------

function get_obs_name(obs_kind_ind)

! Returns observation name

integer, intent(in) :: obs_kind_ind
character(len = 32) :: get_obs_name

if ( .not. module_initialized ) call initialize_module

get_obs_name = get_obs_kind_name(obs_kind_ind)

end function get_obs_name

!----------------------------------------------------------------------------

subroutine set_obs_def_location(obs_def, location)

! Sets the location of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(location_type),   intent(in) :: location

if ( .not. module_initialized ) call initialize_module

obs_def%location = location

end subroutine set_obs_def_location

!----------------------------------------------------------------------------

subroutine set_obs_def_error_variance(obs_def, error_variance)

! Sets the error variance of an obs_def

type(obs_def_type), intent(inout) :: obs_def
real(r8), intent(in) :: error_variance

if ( .not. module_initialized ) call initialize_module

obs_def%error_variance = error_variance

end subroutine set_obs_def_error_variance

!----------------------------------------------------------------------------

subroutine set_obs_def_key(obs_def, key)

! Sets the key of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,            intent(in)    :: key

if ( .not. module_initialized ) call initialize_module

obs_def%key = key

end subroutine set_obs_def_key

!----------------------------------------------------------------------------

subroutine set_obs_def_kind(obs_def, kind)

! Sets the kind of an obs_def

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: kind

if ( .not. module_initialized ) call initialize_module

obs_def%kind = kind

end subroutine set_obs_def_kind

!----------------------------------------------------------------------------

subroutine set_obs_def_time(obs_def, time)

! Sets the time of an obs_def

type(obs_def_type), intent(inout) :: obs_def
type(time_type), intent(in) :: time

if ( .not. module_initialized ) call initialize_module

obs_def%time = time

end subroutine set_obs_def_time

!----------------------------------------------------------------------------

subroutine get_expected_obs_from_def(key, obs_def, obs_kind_ind, ens_index, &
   state, state_time, isprior, obs_val, istatus, assimilate_this_ob, evaluate_this_ob)

! Compute forward operator for a particular obs_def
integer,            intent(in)  :: key
type(obs_def_type), intent(in)  :: obs_def
integer,            intent(in)  :: obs_kind_ind, ens_index
real(r8),           intent(in)  :: state(:)
type(time_type),    intent(in)  :: state_time
logical,            intent(in)  :: isprior
real(r8),           intent(out) :: obs_val
integer,            intent(out) :: istatus
logical,            intent(out) :: assimilate_this_ob, evaluate_this_ob

type(location_type) :: location
type(time_type)     :: obs_time
integer             :: obs_key
real(r8)            :: error_var

! Load up the assimilate and evaluate status for this observation kind
assimilate_this_ob = assimilate_this_obs_kind(obs_kind_ind)
evaluate_this_ob = evaluate_this_obs_kind(obs_kind_ind)

! If not being assimilated or evaluated return with missing_r8 and istatus 0
if(assimilate_this_ob .or. evaluate_this_ob) then
   ! for speed, access directly instead of using accessor functions
   location  = obs_def%location
   obs_time  = obs_def%time
   obs_key   = obs_def%key
   error_var = obs_def%error_variance

   ! Compute the forward operator.  In spite of the variable name,
   ! obs_kind_ind is in fact a 'type' index number.  use the function
   ! get_obs_kind_var_type from the obs_kind_mod if you want to map
   ! from a specific type to a generic kind.  the third argument of
   ! a call to the 'interpolate()' function must be a kind index and
   ! not a type.  normally the preprocess program does this for you.
   select case(obs_kind_ind)

      ! arguments available to an obs_def forward operator code are:
      !   state        -- the entire model state vector
      !   state_time   -- the time of the state vector data
      !   ens_index    -- the ensemble number
      !   location     -- observation location
      !   obs_kind_ind -- the index of the observation specific type
      !   obs_time     -- the time of the observation
      !   error_var    -- the observation error variance
      !   isprior      -- true for prior eval; false for posterior
      !
      ! the routine must return values for:
      !   obs_val -- the computed forward operator value
      !   istatus -- return code: 0=ok, >0 is error, <0 reserved for system use
      !
      ! to call interpolate() directly, the arg list MUST BE:
      !  interpolate(state, location, KIND_xxx, obs_val, istatus)
      !
      ! the preprocess program generates lines like this automatically,
      ! and this matches the interfaces in each model_mod.f90 file.
      !
      ! CASE statements and algorithms for specific observation kinds are
      ! inserted here by the DART preprocess program.

  case(DOPPLER_RADIAL_VELOCITY)
     call get_expected_radial_vel(state, location, obs_def%key, obs_val, istatus)
  case(RADAR_REFLECTIVITY)
     call get_expected_radar_ref(state, location, obs_val, istatus)
  case(RADAR_CLEARAIR_REFLECTIVITY)
     call get_expected_radar_ref(state, location, obs_val, istatus)
  case(PRECIPITATION_FALL_SPEED)
     call get_expected_fall_velocity(state, location, obs_val, istatus)
         case(DEWPOINT)
            call get_expected_dew_point(state, location, 1, obs_val, istatus)
         case(AIREP_DEWPOINT, AMDAR_DEWPOINT, PILOT_DEWPOINT, BOGUS_DEWPOINT, AIRS_DEWPOINT)
            call get_expected_dew_point(state, location, 1, obs_val, istatus)
         case(RADIOSONDE_DEWPOINT, AIRCRAFT_DEWPOINT, ACARS_DEWPOINT, DROPSONDE_DEWPOINT)
            call get_expected_dew_point(state, location, 1, obs_val, istatus)

         case(DEWPOINT_2_METER)
            call get_expected_dew_point(state, location, 2, obs_val, istatus)
         case(BUOY_DEWPOINT, SHIP_DEWPOINT, SYNOP_DEWPOINT)
            call get_expected_dew_point(state, location, 2, obs_val, istatus)
         case(MARINE_SFC_DEWPOINT, LAND_SFC_DEWPOINT)
            call get_expected_dew_point(state, location, 2, obs_val, istatus)
         case(METAR_DEWPOINT_2_METER)
            call get_expected_dew_point(state, location, 2, obs_val, istatus)
         case(RADIOSONDE_RELATIVE_HUMIDITY, DROPSONDE_RELATIVE_HUMIDITY, &
              AIRCRAFT_RELATIVE_HUMIDITY,   ACARS_RELATIVE_HUMIDITY,     &
              MARINE_SFC_RELATIVE_HUMIDITY, LAND_SFC_RELATIVE_HUMIDITY,  &
              METAR_RELATIVE_HUMIDITY_2_METER, AIRS_RELATIVE_HUMIDITY)
            call get_expected_relative_humidity(state, location, obs_val, istatus)
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            call get_expected_altimeter(state, location, obs_val, istatus)
         case(GPSRO_REFRACTIVITY)
            call get_expected_gpsro_ref(state, location, obs_def%key, obs_val, istatus)
         case(VORTEX_LAT)
            call get_expected_vortex_info(state, location, obs_val, 'lat',istatus)
         case(VORTEX_LON)
            call get_expected_vortex_info(state, location, obs_val, 'lon',istatus)
         case(VORTEX_PMIN)
            call get_expected_vortex_info(state, location, obs_val, 'pmi',istatus)
         case(VORTEX_WMAX)
            call get_expected_vortex_info(state, location, obs_val, 'wma',istatus)
         case(SATEM_THICKNESS)
            call get_expected_thickness(state, location, obs_val, istatus)
         case(MONITOR_SO2)
            call get_expected_monitor_so2(state, location, obs_def%key, obs_val, istatus)
         case(MONITOR_NO2)
            call get_expected_monitor_no2(state, location, obs_def%key, obs_val, istatus)
         case(MONITOR_PM10)
            call get_expected_monitor_pm10(state, location, obs_def%key, obs_val, istatus)
         case(MONITOR_CO)
            call get_expected_monitor_co(state, location, obs_def%key, obs_val, istatus)
         case(MONITOR_O3)
            call get_expected_monitor_o3(state, location, obs_def%key, obs_val, istatus)
         case(MONITOR_PM25)
            call get_expected_monitor_pm25(state, location, obs_def%key, obs_val, istatus)
         case(OMI_NO2_COLUMN)
            call get_expected_omi_no2(state, location, obs_def%key, obs_val, istatus)
         case(MODIS_AOD_RETRIEVAL)
            call get_expected_modis_aod(state, location, obs_def%key, obs_val, istatus)
         case(MOPITT_CO_RETRIEVAL)
            call get_expected_mopitt_co(state, location, obs_def%key, obs_val, istatus)
         case(IASI_CO_RETRIEVAL)
            call get_expected_iasi_co(state, location, obs_def%key, obs_val, istatus)
         case(IASI_O3_RETRIEVAL)
            call get_expected_iasi_o3(state, location, obs_def%key, obs_val, istatus)
      case(RADIOSONDE_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(RADIOSONDE_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(RADIOSONDE_GEOPOTENTIAL_HGT)
         call interpolate(state, location, KIND_GEOPOTENTIAL_HEIGHT, obs_val, istatus)
      case(RADIOSONDE_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(RADIOSONDE_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(RADIOSONDE_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(DROPSONDE_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(DROPSONDE_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(DROPSONDE_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(DROPSONDE_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(DROPSONDE_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(AIRCRAFT_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(AIRCRAFT_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(AIRCRAFT_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AIRCRAFT_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(ACARS_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(ACARS_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(ACARS_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(ACARS_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(MARINE_SFC_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(MARINE_SFC_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(MARINE_SFC_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(MARINE_SFC_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(MARINE_SFC_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(LAND_SFC_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(LAND_SFC_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(LAND_SFC_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(LAND_SFC_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(LAND_SFC_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(SAT_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(SAT_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(ATOV_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AIRS_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AIRS_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(GPS_PRECIPITABLE_WATER)
         call interpolate(state, location, KIND_PRECIPITABLE_WATER, obs_val, istatus)
      case(METAR_U_10_METER_WIND)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(METAR_V_10_METER_WIND)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(METAR_TEMPERATURE_2_METER)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(METAR_SPECIFIC_HUMIDITY_2_METER)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(METAR_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(METAR_POT_TEMP_2_METER)
         call interpolate(state, location, KIND_POTENTIAL_TEMPERATURE, obs_val, istatus)
      case(TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(COSMIC_ELECTRON_DENSITY)
         call interpolate(state, location, KIND_ELECTRON_DENSITY, obs_val, istatus)
      case(BUOY_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(BUOY_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(BUOY_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(BUOY_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(SHIP_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(SHIP_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(SHIP_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(SHIP_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(SYNOP_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(SYNOP_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(SYNOP_SURFACE_PRESSURE)
         call interpolate(state, location, KIND_SURFACE_PRESSURE, obs_val, istatus)
      case(SYNOP_SPECIFIC_HUMIDITY)
         call interpolate(state, location, KIND_SPECIFIC_HUMIDITY, obs_val, istatus)
      case(SYNOP_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AIREP_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(AIREP_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(AIREP_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(AIREP_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AMDAR_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(AMDAR_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(AMDAR_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(AMDAR_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(PILOT_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(PILOT_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(PILOT_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(PILOT_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(BOGUS_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(BOGUS_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(BOGUS_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(BOGUS_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(PROFILER_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(PROFILER_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(PROFILER_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(AIRNOW_CO)
         call interpolate(state, location, KIND_CO, obs_val, istatus)
      case(AIRNOW_SO2)
         call interpolate(state, location, KIND_SO2, obs_val, istatus)
      case(AIRNOW_NO2)
         call interpolate(state, location, KIND_NO2, obs_val, istatus)
      case(AIRNOW_NOy)
         call interpolate(state, location, KIND_NOy, obs_val, istatus)
      case(AIRNOW_O3)
         call interpolate(state, location, KIND_O3, obs_val, istatus)
      case(AIRNOW_PM10)
         call interpolate(state, location, KIND_PM10, obs_val, istatus)
      case(AIRNOW_PM25)
         call interpolate(state, location, KIND_PM25, obs_val, istatus)
      case(AIRNOW_PB)
         call interpolate(state, location, KIND_PB, obs_val, istatus)
      case(AIRNOW_NMOC)
         call interpolate(state, location, KIND_NMOC, obs_val, istatus)
      case(AIRNOW_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(AIRNOW_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(AIRNOW_RELATIVE_HUMIDITY)
         call interpolate(state, location, KIND_RELATIVE_HUMIDITY, obs_val, istatus)
      case(AIRNOW_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(AIRNOW_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)
      case(PANDA_CO)
         call interpolate(state, location, KIND_CO, obs_val, istatus)
      case(PANDA_SO2)
         call interpolate(state, location, KIND_SO2, obs_val, istatus)
      case(PANDA_NO2)
         call interpolate(state, location, KIND_NO2, obs_val, istatus)
      case(PANDA_NOy)
         call interpolate(state, location, KIND_NOy, obs_val, istatus)
      case(PANDA_O3)
         call interpolate(state, location, KIND_O3, obs_val, istatus)
      case(PANDA_PM10)
         call interpolate(state, location, KIND_PM10, obs_val, istatus)
      case(PANDA_PM25)
         call interpolate(state, location, KIND_PM25, obs_val, istatus)
      case(PANDA_PB)
         call interpolate(state, location, KIND_PB, obs_val, istatus)
      case(PANDA_NMOC)
         call interpolate(state, location, KIND_NMOC, obs_val, istatus)
      case(PANDA_PRESSURE)
         call interpolate(state, location, KIND_PRESSURE, obs_val, istatus)
      case(PANDA_TEMPERATURE)
         call interpolate(state, location, KIND_TEMPERATURE, obs_val, istatus)
      case(PANDA_RELATIVE_HUMIDITY)
         call interpolate(state, location, KIND_RELATIVE_HUMIDITY, obs_val, istatus)
      case(PANDA_U_WIND_COMPONENT)
         call interpolate(state, location, KIND_U_WIND_COMPONENT, obs_val, istatus)
      case(PANDA_V_WIND_COMPONENT)
         call interpolate(state, location, KIND_V_WIND_COMPONENT, obs_val, istatus)

      ! If the observation kind is not available, it is an error. The DART
      ! preprocess program should provide code for all available kinds.
      case DEFAULT
         call error_handler(E_ERR, 'get_expected_obs_from_def', &
            'Attempt to evaluate or assimilate undefined obs_kind type.', &
             source, revision, revdate)
   end select
else
   ! Not computing forward operator for this kind
   obs_val = missing_r8
   istatus = 0
endif

end subroutine get_expected_obs_from_def



  subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!----------------------------------------------------------------------------
! subroutine read_obs_def(ifile, obs_def, key, obs_val, fform)
!
! ifile
! obs_def
! key
! obs_val    needed if you want to perform operations based on value
! fform
!
! Reads an obs_def from file which is just an integer unit number in the
! current preliminary implementation.

integer,                    intent(in)    :: ifile
type(obs_def_type),         intent(inout) :: obs_def
integer,                    intent(in)    :: key
real(r8),                   intent(inout) :: obs_val
character(len=*), optional, intent(in)    :: fform

character(len=5)  :: header
integer           :: o_index
logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Begin by reading five character ascii header, then location, kind, error variance, index

! Need to add additional error checks on read
if (is_ascii) then
   read(ifile, '(a5)') header
   if(header /= 'obdef') then
      call error_handler(E_ERR,'read_obs_def', &
         'Expected header "obdef" in input file', source, revision, revdate)
   endif
endif

! Read the location, kind, time and error variance
obs_def%location = read_location(ifile, fform)
if (is_ascii) then
   read(ifile, '(a5)' ) header
   if(header /= 'kind ') then
      call error_handler(E_ERR,'read_kind', &
         'Expected kind header "kind " in input file', &
          source, revision, revdate)
   endif
   read(ifile, *) o_index
else
   read(ifile)    o_index
endif

! Negative value is identity obs, doesn't need mapped
! Positive value must use mapping to get to proper index in obs_kind
if(o_index < 0) then
   obs_def%kind = o_index
else
   obs_def%kind = map_def_index(o_index)
endif

! This kind may have its own module that needs to read more
select case(obs_def%kind)
   ! More complicated kinds may require reading additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

   case(DOPPLER_RADIAL_VELOCITY)
      call read_radial_vel(obs_def%key, ifile, fform)
   case(RADAR_REFLECTIVITY)
      call read_radar_ref(obs_val, obs_def%key)
  case(RADAR_CLEARAIR_REFLECTIVITY)
      call read_radar_ref(obs_val, obs_def%key)
   case(PRECIPITATION_FALL_SPEED)
      continue
         case(DEWPOINT, DEWPOINT_2_METER)
            continue
         case(METAR_DEWPOINT_2_METER)
            continue
         case(AIREP_DEWPOINT, AMDAR_DEWPOINT, PILOT_DEWPOINT, BOGUS_DEWPOINT)
            continue
         case(BUOY_DEWPOINT, SHIP_DEWPOINT, SYNOP_DEWPOINT, AIRS_DEWPOINT)
            continue
         case(RADIOSONDE_DEWPOINT, AIRCRAFT_DEWPOINT, ACARS_DEWPOINT, DROPSONDE_DEWPOINT)
            continue
         case(MARINE_SFC_DEWPOINT, LAND_SFC_DEWPOINT)
            continue
         case(RADIOSONDE_RELATIVE_HUMIDITY, DROPSONDE_RELATIVE_HUMIDITY, &
              AIRCRAFT_RELATIVE_HUMIDITY,   ACARS_RELATIVE_HUMIDITY,     &
              MARINE_SFC_RELATIVE_HUMIDITY, LAND_SFC_RELATIVE_HUMIDITY,  &
              METAR_RELATIVE_HUMIDITY_2_METER, AIRS_RELATIVE_HUMIDITY)
            continue
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
         case(GPSRO_REFRACTIVITY)
            call read_gpsro_ref(obs_def%key, ifile, fform)
      case(VORTEX_LAT)
         continue
      case(VORTEX_LON)
         continue
      case(VORTEX_PMIN)
         continue
      case(VORTEX_WMAX)
         continue
 case(SATEM_THICKNESS)
      continue
      case(MONITOR_SO2)
         call read_monitor_so2(obs_def%key, ifile, fileformat)
      case(MONITOR_NO2)
         call read_monitor_no2(obs_def%key, ifile, fileformat)
      case(MONITOR_PM10)
         call read_monitor_pm10(obs_def%key, ifile, fileformat)
      case(MONITOR_CO)
         call read_monitor_co(obs_def%key, ifile, fileformat)
      case(MONITOR_O3)
         call read_monitor_o3(obs_def%key, ifile, fileformat)
      case(MONITOR_PM25)
         call read_monitor_pm25(obs_def%key, ifile, fileformat)
      case(OMI_NO2_COLUMN)
         call read_omi_no2(obs_def%key, ifile, fileformat)
      case(MODIS_AOD_RETRIEVAL)
         call read_modis_aod(obs_def%key, ifile, fileformat)
      case(MOPITT_CO_RETRIEVAL)
         call read_mopitt_co(obs_def%key, ifile, fileformat)
      case(IASI_CO_RETRIEVAL)
         call read_iasi_co(obs_def%key, ifile, fileformat)
      case(IASI_O3_RETRIEVAL)
         call read_iasi_o3(obs_def%key, ifile, fileformat)
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(METAR_U_10_METER_WIND)
      continue
   case(METAR_V_10_METER_WIND)
      continue
   case(METAR_TEMPERATURE_2_METER)
      continue
   case(METAR_SPECIFIC_HUMIDITY_2_METER)
      continue
   case(METAR_SURFACE_PRESSURE)
      continue
   case(METAR_POT_TEMP_2_METER)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(COSMIC_ELECTRON_DENSITY)
      continue
   case(BUOY_U_WIND_COMPONENT)
      continue
   case(BUOY_V_WIND_COMPONENT)
      continue
   case(BUOY_SURFACE_PRESSURE)
      continue
   case(BUOY_TEMPERATURE)
      continue
   case(SHIP_U_WIND_COMPONENT)
      continue
   case(SHIP_V_WIND_COMPONENT)
      continue
   case(SHIP_SURFACE_PRESSURE)
      continue
   case(SHIP_TEMPERATURE)
      continue
   case(SYNOP_U_WIND_COMPONENT)
      continue
   case(SYNOP_V_WIND_COMPONENT)
      continue
   case(SYNOP_SURFACE_PRESSURE)
      continue
   case(SYNOP_SPECIFIC_HUMIDITY)
      continue
   case(SYNOP_TEMPERATURE)
      continue
   case(AIREP_U_WIND_COMPONENT)
      continue
   case(AIREP_V_WIND_COMPONENT)
      continue
   case(AIREP_PRESSURE)
      continue
   case(AIREP_TEMPERATURE)
      continue
   case(AMDAR_U_WIND_COMPONENT)
      continue
   case(AMDAR_V_WIND_COMPONENT)
      continue
   case(AMDAR_PRESSURE)
      continue
   case(AMDAR_TEMPERATURE)
      continue
   case(PILOT_U_WIND_COMPONENT)
      continue
   case(PILOT_V_WIND_COMPONENT)
      continue
   case(PILOT_PRESSURE)
      continue
   case(PILOT_TEMPERATURE)
      continue
   case(BOGUS_U_WIND_COMPONENT)
      continue
   case(BOGUS_V_WIND_COMPONENT)
      continue
   case(BOGUS_PRESSURE)
      continue
   case(BOGUS_TEMPERATURE)
      continue
   case(PROFILER_U_WIND_COMPONENT)
      continue
   case(PROFILER_V_WIND_COMPONENT)
      continue
   case(PROFILER_PRESSURE)
      continue
   case(AIRNOW_CO)
      continue
   case(AIRNOW_SO2)
      continue
   case(AIRNOW_NO2)
      continue
   case(AIRNOW_NOy)
      continue
   case(AIRNOW_O3)
      continue
   case(AIRNOW_PM10)
      continue
   case(AIRNOW_PM25)
      continue
   case(AIRNOW_PB)
      continue
   case(AIRNOW_NMOC)
      continue
   case(AIRNOW_PRESSURE)
      continue
   case(AIRNOW_TEMPERATURE)
      continue
   case(AIRNOW_RELATIVE_HUMIDITY)
      continue
   case(AIRNOW_U_WIND_COMPONENT)
      continue
   case(AIRNOW_V_WIND_COMPONENT)
      continue
   case(PANDA_CO)
      continue
   case(PANDA_SO2)
      continue
   case(PANDA_NO2)
      continue
   case(PANDA_NOy)
      continue
   case(PANDA_O3)
      continue
   case(PANDA_PM10)
      continue
   case(PANDA_PM25)
      continue
   case(PANDA_PB)
      continue
   case(PANDA_NMOC)
      continue
   case(PANDA_PRESSURE)
      continue
   case(PANDA_TEMPERATURE)
      continue
   case(PANDA_RELATIVE_HUMIDITY)
      continue
   case(PANDA_U_WIND_COMPONENT)
      continue
   case(PANDA_V_WIND_COMPONENT)
      continue

! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'read_obs_def', &
         'Attempt to read for undefined obs_kind type.', &
         source, revision, revdate)
end select

! Read the time for the observation
obs_def%time = read_time(ifile, fform)

if (is_ascii) then
   read(ifile, *) obs_def%error_variance
else
   read(ifile)    obs_def%error_variance
endif

end subroutine read_obs_def

!----------------------------------------------------------------------------

subroutine write_obs_def(ifile, obs_def, key, fform)

! Writes an obs_def to file.

integer,                    intent(in) :: ifile
type(obs_def_type),         intent(in) :: obs_def
integer,                    intent(in) :: key
character(len=*), intent(in), optional :: fform

logical           :: is_ascii
character(len=32) :: fileformat   ! here for backwards compatibility only

if ( .not. module_initialized ) call initialize_module

is_ascii = ascii_file_format(fform)

! here for backwards compatibility only; after the next release,
! remove this and force people in their own obs_def_xxx_mod.f90 code
! to set the last arg to read/write to be fform instead of fileformat
if (is_ascii) then
   fileformat = 'formatted'
else
   fileformat = 'unformatted'
endif

! Write the 5 character identifier for verbose formatted output
if (is_ascii) write(ifile, '("obdef")')

! Write out the location, kind and error variance
call write_location(ifile, obs_def%location, fform)
if (is_ascii) then
   write(ifile, '("kind")' )
   write(ifile, *) obs_def%kind
else
   write(ifile)    obs_def%kind
endif

! This kind may have its own module that needs to write more
select case(obs_def%kind)
   ! More complicated kinds may require writing additional information from
   ! an observation sequence file. Case code to do this is inserted here by
   ! the DART preprocess program.

   case(DOPPLER_RADIAL_VELOCITY)
      call write_radial_vel(obs_def%key, ifile, fform)
   case(RADAR_REFLECTIVITY)
      continue
   case(RADAR_CLEARAIR_REFLECTIVITY)
      continue
   case(PRECIPITATION_FALL_SPEED)
      continue
         case(DEWPOINT, DEWPOINT_2_METER)
            continue
         case(METAR_DEWPOINT_2_METER)
            continue
         case(AIREP_DEWPOINT, AMDAR_DEWPOINT, PILOT_DEWPOINT, BOGUS_DEWPOINT)
            continue
         case(BUOY_DEWPOINT, SHIP_DEWPOINT, SYNOP_DEWPOINT, AIRS_DEWPOINT)
            continue
         case(RADIOSONDE_DEWPOINT, AIRCRAFT_DEWPOINT, ACARS_DEWPOINT, DROPSONDE_DEWPOINT)
            continue
         case(MARINE_SFC_DEWPOINT, LAND_SFC_DEWPOINT)
            continue
         case(RADIOSONDE_RELATIVE_HUMIDITY, DROPSONDE_RELATIVE_HUMIDITY, &
              AIRCRAFT_RELATIVE_HUMIDITY,   ACARS_RELATIVE_HUMIDITY,     &
              MARINE_SFC_RELATIVE_HUMIDITY, LAND_SFC_RELATIVE_HUMIDITY,  &
              METAR_RELATIVE_HUMIDITY_2_METER, AIRS_RELATIVE_HUMIDITY)
            continue
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
         case(GPSRO_REFRACTIVITY)
            call write_gpsro_ref(obs_def%key, ifile, fform)
      case(VORTEX_LAT)
         continue
      case(VORTEX_LON)
         continue
      case(VORTEX_PMIN)
         continue
      case(VORTEX_WMAX)
         continue
 case(SATEM_THICKNESS)
      continue
      case(MONITOR_SO2)
         call write_monitor_so2(obs_def%key, ifile, fileformat)
      case(MONITOR_NO2)
         call write_monitor_no2(obs_def%key, ifile, fileformat)
      case(MONITOR_PM10)
         call write_monitor_pm10(obs_def%key, ifile, fileformat)
      case(MONITOR_CO)
         call write_monitor_co(obs_def%key, ifile, fileformat)
      case(MONITOR_O3)
         call write_monitor_o3(obs_def%key, ifile, fileformat)
      case(MONITOR_PM25)
         call write_monitor_pm25(obs_def%key, ifile, fileformat)
      case(OMI_NO2_COLUMN)
         call write_omi_no2(obs_def%key, ifile, fileformat)
      case(MODIS_AOD_RETRIEVAL)
         call write_modis_aod(obs_def%key, ifile, fileformat)
      case(MOPITT_CO_RETRIEVAL)
         call write_mopitt_co(obs_def%key, ifile, fileformat)
      case(IASI_CO_RETRIEVAL)
         call write_iasi_co(obs_def%key, ifile, fileformat)
      case(IASI_O3_RETRIEVAL)
         call write_iasi_o3(obs_def%key, ifile, fileformat)
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(METAR_U_10_METER_WIND)
      continue
   case(METAR_V_10_METER_WIND)
      continue
   case(METAR_TEMPERATURE_2_METER)
      continue
   case(METAR_SPECIFIC_HUMIDITY_2_METER)
      continue
   case(METAR_SURFACE_PRESSURE)
      continue
   case(METAR_POT_TEMP_2_METER)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(COSMIC_ELECTRON_DENSITY)
      continue
   case(BUOY_U_WIND_COMPONENT)
      continue
   case(BUOY_V_WIND_COMPONENT)
      continue
   case(BUOY_SURFACE_PRESSURE)
      continue
   case(BUOY_TEMPERATURE)
      continue
   case(SHIP_U_WIND_COMPONENT)
      continue
   case(SHIP_V_WIND_COMPONENT)
      continue
   case(SHIP_SURFACE_PRESSURE)
      continue
   case(SHIP_TEMPERATURE)
      continue
   case(SYNOP_U_WIND_COMPONENT)
      continue
   case(SYNOP_V_WIND_COMPONENT)
      continue
   case(SYNOP_SURFACE_PRESSURE)
      continue
   case(SYNOP_SPECIFIC_HUMIDITY)
      continue
   case(SYNOP_TEMPERATURE)
      continue
   case(AIREP_U_WIND_COMPONENT)
      continue
   case(AIREP_V_WIND_COMPONENT)
      continue
   case(AIREP_PRESSURE)
      continue
   case(AIREP_TEMPERATURE)
      continue
   case(AMDAR_U_WIND_COMPONENT)
      continue
   case(AMDAR_V_WIND_COMPONENT)
      continue
   case(AMDAR_PRESSURE)
      continue
   case(AMDAR_TEMPERATURE)
      continue
   case(PILOT_U_WIND_COMPONENT)
      continue
   case(PILOT_V_WIND_COMPONENT)
      continue
   case(PILOT_PRESSURE)
      continue
   case(PILOT_TEMPERATURE)
      continue
   case(BOGUS_U_WIND_COMPONENT)
      continue
   case(BOGUS_V_WIND_COMPONENT)
      continue
   case(BOGUS_PRESSURE)
      continue
   case(BOGUS_TEMPERATURE)
      continue
   case(PROFILER_U_WIND_COMPONENT)
      continue
   case(PROFILER_V_WIND_COMPONENT)
      continue
   case(PROFILER_PRESSURE)
      continue
   case(AIRNOW_CO)
      continue
   case(AIRNOW_SO2)
      continue
   case(AIRNOW_NO2)
      continue
   case(AIRNOW_NOy)
      continue
   case(AIRNOW_O3)
      continue
   case(AIRNOW_PM10)
      continue
   case(AIRNOW_PM25)
      continue
   case(AIRNOW_PB)
      continue
   case(AIRNOW_NMOC)
      continue
   case(AIRNOW_PRESSURE)
      continue
   case(AIRNOW_TEMPERATURE)
      continue
   case(AIRNOW_RELATIVE_HUMIDITY)
      continue
   case(AIRNOW_U_WIND_COMPONENT)
      continue
   case(AIRNOW_V_WIND_COMPONENT)
      continue
   case(PANDA_CO)
      continue
   case(PANDA_SO2)
      continue
   case(PANDA_NO2)
      continue
   case(PANDA_NOy)
      continue
   case(PANDA_O3)
      continue
   case(PANDA_PM10)
      continue
   case(PANDA_PM25)
      continue
   case(PANDA_PB)
      continue
   case(PANDA_NMOC)
      continue
   case(PANDA_PRESSURE)
      continue
   case(PANDA_TEMPERATURE)
      continue
   case(PANDA_RELATIVE_HUMIDITY)
      continue
   case(PANDA_U_WIND_COMPONENT)
      continue
   case(PANDA_V_WIND_COMPONENT)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue

   case DEFAULT
      call error_handler(E_ERR, 'write_obs_def', &
         'Attempt to write for undefined obs_kind type.', &
         source, revision, revdate)
end select

call write_time(ifile, obs_def%time, fform)

if (is_ascii) then
   write(ifile, *) obs_def%error_variance
else
   write(ifile)    obs_def%error_variance
endif

end subroutine write_obs_def


subroutine interactive_obs_def(obs_def, key)
!---------------------------------------------------------------------------
!
! Allows interactive creation of an observation

type(obs_def_type), intent(inout) :: obs_def
integer,               intent(in) :: key

if ( .not. module_initialized ) call initialize_module

! Get the observation kind WANT A STRING OPTION, TOO?
obs_def%kind = get_kind_from_menu()

! Input any special stuff for this kind
select case(obs_def%kind)
   ! More complicated kinds may require inputting additional information to
   ! define an observation. Case code to do this is inserted here by the
   ! DART preprocess program.

   case(DOPPLER_RADIAL_VELOCITY)
      call interactive_radial_vel(obs_def%key)
   case(RADAR_REFLECTIVITY)
      continue
   case(PRECIPITATION_FALL_SPEED)
      continue
   case(RADAR_CLEARAIR_REFLECTIVITY)
      continue
         case(DEWPOINT, DEWPOINT_2_METER)
            continue
         case(METAR_DEWPOINT_2_METER)
            continue
         case(AIREP_DEWPOINT, AMDAR_DEWPOINT, PILOT_DEWPOINT, BOGUS_DEWPOINT)
            continue
         case(BUOY_DEWPOINT, SHIP_DEWPOINT, SYNOP_DEWPOINT, AIRS_DEWPOINT)
            continue
         case(RADIOSONDE_DEWPOINT, AIRCRAFT_DEWPOINT, ACARS_DEWPOINT, DROPSONDE_DEWPOINT)
            continue
         case(MARINE_SFC_DEWPOINT, LAND_SFC_DEWPOINT)
            continue
         case(RADIOSONDE_RELATIVE_HUMIDITY, DROPSONDE_RELATIVE_HUMIDITY, &
              AIRCRAFT_RELATIVE_HUMIDITY,   ACARS_RELATIVE_HUMIDITY,     &
              MARINE_SFC_RELATIVE_HUMIDITY, LAND_SFC_RELATIVE_HUMIDITY,  &
              METAR_RELATIVE_HUMIDITY_2_METER, AIRS_RELATIVE_HUMIDITY)
            continue
         case(RADIOSONDE_SURFACE_ALTIMETER, DROPSONDE_SURFACE_ALTIMETER, MARINE_SFC_ALTIMETER, &
              LAND_SFC_ALTIMETER, METAR_ALTIMETER)
            continue
         case(GPSRO_REFRACTIVITY)
            call interactive_gpsro_ref(obs_def%key)
      case(VORTEX_LAT)
         continue
      case(VORTEX_LON)
         continue
      case(VORTEX_PMIN)
         continue
      case(VORTEX_WMAX)
         continue
 case(SATEM_THICKNESS)
      continue
      case(MONITOR_SO2)
         call interactive_monitor_so2(obs_def%key)
      case(MONITOR_NO2)
         call interactive_monitor_no2(obs_def%key)
      case(MONITOR_PM10)
         call interactive_monitor_pm10(obs_def%key)
      case(MONITOR_CO)
         call interactive_monitor_co(obs_def%key)
      case(MONITOR_O3)
         call interactive_monitor_o3(obs_def%key)
      case(MONITOR_PM25)
         call interactive_monitor_pm25(obs_def%key)
      case(OMI_NO2_COLUMN)
         call interactive_omi_no2(obs_def%key)
      case(MODIS_AOD_RETRIEVAL)
         call interactive_modis_aod(obs_def%key)
      case(MOPITT_CO_RETRIEVAL)
         call interactive_mopitt_co(obs_def%key)
      case(IASI_CO_RETRIEVAL)
         call interactive_iasi_co(obs_def%key)
      case(IASI_O3_RETRIEVAL)
         call interactive_iasi_o3(obs_def%key)
   case(RADIOSONDE_U_WIND_COMPONENT)
      continue
   case(RADIOSONDE_V_WIND_COMPONENT)
      continue
   case(RADIOSONDE_GEOPOTENTIAL_HGT)
      continue
   case(RADIOSONDE_SURFACE_PRESSURE)
      continue
   case(RADIOSONDE_TEMPERATURE)
      continue
   case(RADIOSONDE_SPECIFIC_HUMIDITY)
      continue
   case(DROPSONDE_U_WIND_COMPONENT)
      continue
   case(DROPSONDE_V_WIND_COMPONENT)
      continue
   case(DROPSONDE_SURFACE_PRESSURE)
      continue
   case(DROPSONDE_TEMPERATURE)
      continue
   case(DROPSONDE_SPECIFIC_HUMIDITY)
      continue
   case(AIRCRAFT_U_WIND_COMPONENT)
      continue
   case(AIRCRAFT_V_WIND_COMPONENT)
      continue
   case(AIRCRAFT_TEMPERATURE)
      continue
   case(AIRCRAFT_SPECIFIC_HUMIDITY)
      continue
   case(ACARS_U_WIND_COMPONENT)
      continue
   case(ACARS_V_WIND_COMPONENT)
      continue
   case(ACARS_TEMPERATURE)
      continue
   case(ACARS_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_U_WIND_COMPONENT)
      continue
   case(MARINE_SFC_V_WIND_COMPONENT)
      continue
   case(MARINE_SFC_TEMPERATURE)
      continue
   case(MARINE_SFC_SPECIFIC_HUMIDITY)
      continue
   case(MARINE_SFC_PRESSURE)
      continue
   case(LAND_SFC_U_WIND_COMPONENT)
      continue
   case(LAND_SFC_V_WIND_COMPONENT)
      continue
   case(LAND_SFC_TEMPERATURE)
      continue
   case(LAND_SFC_SPECIFIC_HUMIDITY)
      continue
   case(LAND_SFC_PRESSURE)
      continue
   case(SAT_U_WIND_COMPONENT)
      continue
   case(SAT_V_WIND_COMPONENT)
      continue
   case(ATOV_TEMPERATURE)
      continue
   case(AIRS_TEMPERATURE)
      continue
   case(AIRS_SPECIFIC_HUMIDITY)
      continue
   case(GPS_PRECIPITABLE_WATER)
      continue
   case(METAR_U_10_METER_WIND)
      continue
   case(METAR_V_10_METER_WIND)
      continue
   case(METAR_TEMPERATURE_2_METER)
      continue
   case(METAR_SPECIFIC_HUMIDITY_2_METER)
      continue
   case(METAR_SURFACE_PRESSURE)
      continue
   case(METAR_POT_TEMP_2_METER)
      continue
   case(TEMPERATURE)
      continue
   case(SPECIFIC_HUMIDITY)
      continue
   case(PRESSURE)
      continue
   case(COSMIC_ELECTRON_DENSITY)
      continue
   case(BUOY_U_WIND_COMPONENT)
      continue
   case(BUOY_V_WIND_COMPONENT)
      continue
   case(BUOY_SURFACE_PRESSURE)
      continue
   case(BUOY_TEMPERATURE)
      continue
   case(SHIP_U_WIND_COMPONENT)
      continue
   case(SHIP_V_WIND_COMPONENT)
      continue
   case(SHIP_SURFACE_PRESSURE)
      continue
   case(SHIP_TEMPERATURE)
      continue
   case(SYNOP_U_WIND_COMPONENT)
      continue
   case(SYNOP_V_WIND_COMPONENT)
      continue
   case(SYNOP_SURFACE_PRESSURE)
      continue
   case(SYNOP_SPECIFIC_HUMIDITY)
      continue
   case(SYNOP_TEMPERATURE)
      continue
   case(AIREP_U_WIND_COMPONENT)
      continue
   case(AIREP_V_WIND_COMPONENT)
      continue
   case(AIREP_PRESSURE)
      continue
   case(AIREP_TEMPERATURE)
      continue
   case(AMDAR_U_WIND_COMPONENT)
      continue
   case(AMDAR_V_WIND_COMPONENT)
      continue
   case(AMDAR_PRESSURE)
      continue
   case(AMDAR_TEMPERATURE)
      continue
   case(PILOT_U_WIND_COMPONENT)
      continue
   case(PILOT_V_WIND_COMPONENT)
      continue
   case(PILOT_PRESSURE)
      continue
   case(PILOT_TEMPERATURE)
      continue
   case(BOGUS_U_WIND_COMPONENT)
      continue
   case(BOGUS_V_WIND_COMPONENT)
      continue
   case(BOGUS_PRESSURE)
      continue
   case(BOGUS_TEMPERATURE)
      continue
   case(PROFILER_U_WIND_COMPONENT)
      continue
   case(PROFILER_V_WIND_COMPONENT)
      continue
   case(PROFILER_PRESSURE)
      continue
   case(AIRNOW_CO)
      continue
   case(AIRNOW_SO2)
      continue
   case(AIRNOW_NO2)
      continue
   case(AIRNOW_NOy)
      continue
   case(AIRNOW_O3)
      continue
   case(AIRNOW_PM10)
      continue
   case(AIRNOW_PM25)
      continue
   case(AIRNOW_PB)
      continue
   case(AIRNOW_NMOC)
      continue
   case(AIRNOW_PRESSURE)
      continue
   case(AIRNOW_TEMPERATURE)
      continue
   case(AIRNOW_RELATIVE_HUMIDITY)
      continue
   case(AIRNOW_U_WIND_COMPONENT)
      continue
   case(AIRNOW_V_WIND_COMPONENT)
      continue
   case(PANDA_CO)
      continue
   case(PANDA_SO2)
      continue
   case(PANDA_NO2)
      continue
   case(PANDA_NOy)
      continue
   case(PANDA_O3)
      continue
   case(PANDA_PM10)
      continue
   case(PANDA_PM25)
      continue
   case(PANDA_PB)
      continue
   case(PANDA_NMOC)
      continue
   case(PANDA_PRESSURE)
      continue
   case(PANDA_TEMPERATURE)
      continue
   case(PANDA_RELATIVE_HUMIDITY)
      continue
   case(PANDA_U_WIND_COMPONENT)
      continue
   case(PANDA_V_WIND_COMPONENT)
      continue

   ! A negative value means identity observations, just move along
   case (:-1)
      continue
   case DEFAULT
      call error_handler(E_ERR, 'interactive_obs_def', &
         'Attempt to interactively create undefined obs_kind type.', &
         source, revision, revdate)
end select

! If the kind is an identity observation, don't need to call location
! Get location from state meta_data
if(obs_def%kind < 0) then
! Get the location of this from model
   call get_state_meta_data(-1 * obs_def%kind, obs_def%location)
else! Get the location
   call interactive_location(obs_def%location)
endif

! Get the time
call interactive_time(obs_def%time)

write(*, *) 'Input error variance for this observation definition '
read(*, *) obs_def%error_variance

! TJH -- might want to do some sort of error checking (i.e. for positive values)

end subroutine interactive_obs_def

!----------------------------------------------------------------

subroutine destroy_obs_def(obs_def)
! TECHNICALLY NEED TO CALL DESTRUCTORS FOR ALL SUBCOMPONENTS,
! NO ALLOCATED STORAGE YET

type(obs_def_type), intent(inout) :: obs_def

if ( .not. module_initialized ) call initialize_module

call set_obs_def_location(obs_def, set_location_missing() )
obs_def%kind = missing_i
call set_obs_def_time(obs_def, set_time_missing() )
call set_obs_def_error_variance( obs_def, missing_r8)

end subroutine destroy_obs_def

!---------------------------------------------------------------------------
!---------------------------------------------------------------------------

end module obs_def_mod

! <next few lines under version control, do not edit>
! $URL$
! $Id$
! $Revision$
! $Date$
