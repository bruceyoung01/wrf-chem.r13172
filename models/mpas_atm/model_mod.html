<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<HTML>
<HEAD>
<TITLE>module model_mod (MPAS ATM)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (MPAS ATM)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P><a href="../../index.html">DART Documentation Main Index</a><br />
          <small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>This document describes the DART interface module for 
the MPAS-Atmosphere (or briefly, MPAS-ATM) global model, 
which uses an unstructured Voronoi grid mesh, formally Spherical Centriodal Voronoi 
Tesselations (SCVTs). This allows for both quasi-uniform discretization of the sphere and 
local refinement. The MPAS/DART interface was built on the SCVT-dual mesh and does not 
regrid to regular lat/lon grids. In the C-grid discretization, the normal component of
velocity on cell edges is prognosed; zonal and meridional wind components are diagnosed
on the cell centers.  We provide several options to choose from in the assimilation
of wind observations as shown below.
</P>
<P>
The grid terminology used in MPAS is as shown in the figure below:
</P>
<img src="../../doc/images/MPAS_grid_structure.png" alt="MPAS_grid_structure" height=600 />
<P>
The wind options during a DART assimilation
are controlled by combinations of 4 different namelist values.
The values determine which fields the forward operator uses to compute expected 
observation values; how the horizontal interpolation is computed in that
forward operator; and how the assimilation increments
are applied to update the wind quantities in the state vector.
Preliminary results based on real data assimilation experiments indicate that 
performance is better when the zonal and meridional winds are used as
input to the forward operator that uses Barycentric interpolation, and when the 
prognostic <i>u</i> wind is updated by the incremental method described in
the figure below.
However there remain
scientific questions about how best to handle the wind fields under different
situations.  Thus we have kept all implemented options available for use in
experimental comparisons.  See the figure below for a flow-chart representation
of how the 4 namelist items interact:
</P>
<img src="../../doc/images/MPAS_WindDA_options.png" alt="WindDA_options" height=600 />
<P>
Cycling of MPAS/DART is run in a <u>restart</u> mode.
As for all DART experiments, the overall design for an experiment is this:
the DART program <em class="program">filter</em> will read the initial
condition file, the observation sequence file, and the DART namelist
to decide whether or not to advance the MPAS-ATM model. All of the
control of the execution of the MPAS model is done by DART directly.
If the model needs to be advanced, <em class="program">filter</em> makes
a call to the shell to execute the script
<em class="program">advance_model.csh</em>,
which is ENTIRELY responsible
for getting all the input files, data files, namelists, etc. into
a temporary directory, running the model, and copying the results
back to the parent directory (which we call CENTRALDIR).
The whole process hinges on setting the MPAS-ATM model namelist values
such that it is doing a restart for every model advance.
Unlike MPAS-ATM free forecast runs, the forecast step in MPAS/DART requires to 
set up one more namelist parameter called "config_do_DAcycling = .true." in &amp;restart section 
of namelist.input to recouple the state vectors (updated by filter) with the mass field for the restart mode.
For more information, check the <a href="shell_scripts/advance_model.csh">advance_model.csh</a> script. </P>
<P>

Since DART is an ensemble algorithm, there are multiple analysis files for a single analysis time: 
one for each ensemble member. Because MPAS/DART is run in a restart mode, each member should keep its own
MPAS restart file from the previous cycle (rather than having a single template file in CENTRALDIR).
Creating the initial ensemble of states is an area of active research.

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from
prematurely terminating the namelist.
</P>

<div class=namelist>
<pre>
&amp;model_nml
   model_analysis_filename      = 'mpas_init.nc',
   grid_definition_filename     = 'mpas_init.nc',
   output_state_vector          = .false.,
   vert_localization_coord      = 3,
   assimilation_period_days     = 0,
   assimilation_period_seconds  = 21600,
   model_perturbation_amplitude = 0.0001,
   log_p_vert_interp            = .true.,
   calendar                     = 'Gregorian',
   use_u_for_wind               = .false.,
   use_rbf_option               = 2,
   update_u_from_reconstruct    = .true.,
   use_increments_for_u_update  = .true.,
   highest_obs_pressure_mb      = 100.0,
   sfc_elev_max_diff            = -1.0,
   outside_grid_level_tolerance = -1.0,
   extrapolate                  = .false.,
   debug                        = 0,
/
</pre>
</div>

<br />
<br />

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>
<TR><TD>model_analysis_filename</TD>
    <TD>character(len=256)<br />
        <em class=units>[default:&nbsp;'mpas_init.nc']</em></TD>
    <TD>The name of the MPAS analysis file to be read and/or written 
        by the DART programs for the state data.</TD>
</TR>

<TR><TD>grid_definition_filename</TD>
    <TD>character(len=256)<br />
        <em class=units>[default:&nbsp;'mpas_init.nc']</em></TD>
    <TD>The name of the MPAS file to be read 
        by the DART programs for the grid information.  Generally
        this is the same as the <em class=code>model_analysis_filename</em>.
        However, the grid information is large and if the grid is static
        that information could be omitted from the analysis files to
        save space. A single grid file could be supplied once and
        not change during the assimilation run. </TD>
</TR>

<TR><TD>highest_obs_pressure_mb</TD>
    <TD>real(r8)<br />
        <em class=units>[default:&nbsp;100.0]</em></TD>
    <TD>Observations higher than this pressure are ignored. Set to -1.0
        to ignore this test.  For models with a prescribed top boundary
        layer, trying to assimilate very high observations results in 
        problems because the model damps out any changes the assimilation
        tries to make.  With adaptive algorithms this results in larger
        and larger coefficients as the assimilation tries to effect state
        vector change.
    </TD>
</TR>

<TR><TD>output_state_vector</TD>
    <TD>logical <em class=units>[default:&nbsp;.false.]</em></TD>
    <TD>The switch to determine the form of the state vector in the
        output netCDF files. If <em class=code>.true.</em> 
        the state vector will be output exactly as DART uses it;
        as one long array.  If <em class=code>.false.</em>, 
        the state vector is parsed into prognostic variables and 
        output that way -- much easier to use with 'ncview', for
        example. [Recommended] </TD>
</TR>

<TR><TD>assimilation_period_days</TD>
    <TD>integer <em class=units>[default:&nbsp;0]</em></TD>
    <TD>The number of days to advance the model for each assimilation.
        Even if the model is being advanced outside of the DART filter
        program, the assimilation period should be set correctly. 
        Only observations with a time within +/- 1/2 this window size 
        will be assimilated.
    </TD>
</TR>

<TR><TD>assimilation_period_seconds</TD>
    <TD>integer <em class=units>[default:&nbsp;21600]</em></TD>
    <TD>In addition to <em class=code>assimilation_period_days</em>, 
        the number of seconds to advance the model for each assimilation. </TD>
</TR>

<TR><TD>vert_localization_coord</TD>
    <TD>integer <em class=units>[default:&nbsp;3]</em></TD>
    <TD>Vertical coordinate for vertical localization.</em> 
       <UL style="list-style: none;">
          <LI>1 = model level</LI>
          <LI>2 = pressure (in pascals)</LI>
          <LI>3 = height (in meters)</LI>
          <LI>4 = scale height (unitless)</LI>
       </UL></TD>
</TR>

<TR><TD>sfc_elev_max_diff</TD>
    <TD>real(r8)<em class=units>[default:&nbsp;-1.0]</em></TD>
    <TD>If > 0, the maximum difference, in meters, between an observation marked
        as a 'surface obs' as the vertical type (with the surface elevation, in
        meters, as the numerical vertical location), and the surface elevation as
        defined by the model. Observations further away from the surface than this
        threshold are rejected and not assimilated. If the value is negative, this
        test is skipped.  </TD>
</TR>

<TR><TD>log_p_vert_interp</TD>
    <TD>logical <em class=units>[default:&nbsp;.true.]</em></TD>
    <TD>If .true., vertical interpolation is done in log-pressure. Otherwise, linear.</TD>
</TR>

<TR><TD>use_u_for_wind</TD>
    <TD>logical <em class=units>[default:&nbsp;.false.]</em></TD>
    <TD>If .false., zonal and meridional winds at cell centers are used for 
        the wind observation operator [default]. In that case, triangular meshes are used for the 
        barycentric (e.g., area-weighted) interpolation. If .true., wind vectors at an arbitrary
        (e.g., observation) point are reconstructed from the normal component of velocity on cell edges
        <em class=file>(u)</em> using radial basis functions (RBFs) provided by the MPAS model.</TD>
</TR>

<TR><TD>use_rbf_option</TD>
    <TD>integer <em class=units>[default:&nbsp;2]</em></TD>
    <TD>If <em class=code>use_u_for_wind</em> is .true., this option controls
        how many points will be used in the RBF interpolation. 
        Options are available as 0, 1, 2, and 3.
        All the edges available in N (= 0,1,2, or 3) neighboring cells 
        go into the RBF reconstruction. </TD>
</TR>

<TR><TD>update_u_from_reconstruct</TD>
    <TD>logical <em class=units>[default:&nbsp;.true.]</em></TD>
    <TD>When zonal and meridional winds at cell centers are used for 
        the wind observation operator (<em class=code>use_u_for_wind</em> = .false.), 
        this option decides if the normal component of velocity on cell edges (which is
        the only wind prognostic variable in MPAS-ATM) should be updated from the winds at cell centers.
        If .true., <em class=code>use_increments_for_u_update</em> should be also decided. 
        If <em class=code>use_u_for_wind</em> = .true. and the normal component of velocity on cell
        edges is defined as a state vector, this option should be .false. so the edge winds can be
        directly updated by filter. </TD>
</TR>

<TR><TD>use_increments_for_u_update</TD>
    <TD>logical <em class=units>[default:&nbsp;.true.]</em></TD>
    <TD>Only if <em class=code>update_u_from_reconstruct</em> is .true., this option is
        used to decide if the edge winds are replaced by averaging from the analysis
        winds at cell centers (.false.), or just updated by the analysis increments
        at cell centers (.true.).  If .true., all the wind components (e.g., both at
        cell centers and edges) are read from prior and used to compute the
        increments [Recommended].  </TD>
</TR>

<TR><TD>model_perturbation_amplitude</TD>
    <TD>real(r8) <em class=units>[default:&nbsp;0.0001]</em></TD>
    <TD>The amplitude of random noise to add when trying to perturb a single
        state vector to create an ensemble. Only used when 
  <em class=file>input.nml</em>::<em class=code>&amp;filter_nml:start_from_restart = .false.</em>
        <!-- See also <a href="#InitialEnsemble">Generating the initial ensemble</a> 
             at the start of this document. -->
        Multiplied by the state vector, it produces standard deviation 
        of a gaussian distribution with the mean at the value of the state vector element. </TD>
</TR> 

<TR><TD>calendar</TD>
    <TD>character(len=32) <br /> 
        <em class=units>[default:&nbsp;'Gregorian']</em></TD>
    <TD> Character string specifying the calendar being used by MPAS.</TD>
</TR>

<TR><TD>outside_grid_level_tolerance</TD>
    <TD>real(r8) <em class=units>[default:&nbsp;-1.0]</em></TD>
    <TD>If greater than 0.0, amount of distance in fractional model levels 
        that a vertical location can be above or below the top or bottom of the 
        grid and still be evaluated without error.  
        Since <em class=code>extrapolate</em> is not implemented yet,
        the value of <em class=code>.false.</em> will be assumed.
        In this case, vertical locations equivalent to level 1
        or level N will be used.  Eventually, if
        <em class=code>extrapolate</em> is <em class=code>.true.</em>, 
        extrapolate from the first or last model level.  
        If <em class=code>extrapolate</em> is <em class=code>.false.</em>, 
        simply use the value at level 1 for low vertical locations, 
        or at level N for high vertical locations. </TD>
</TR> 

<TR><TD>extrapolate</TD>
    <TD>logical <em class=units>[default:&nbsp;.false.]</em></TD>
    <TD><em>NOT IMPLEMENTED YET</em>.  Vertical locations equivalant to level 1
        or level N will be used.  When this is implemented, it will do: <br />
        If <em class=code>outside_grid_level_tolerance</em> is greater than 0.0,
        then control how values are assigned to locations where the vertical is
        exterior to the grid.  If this is <em class=code>.true.</em>, then
        extrapolate low locations from levels 1 and 2, and high locations from
        levels N-1 and N.  If this is <em class=code>.false.</em>, then simply 
        use the corresponding values at level 1 or N.  This item is ignored if 
        <em class=code>outside_grid_level_tolerance</em> is less than or
        equal to 0.0. </TD>
</TR> 

<TR><TD>debug</TD>
    <TD>integer <em class=units>[default:&nbsp;0]</em></TD>
    <TD>The switch to specify the run-time verbosity.
         <em class=code>0</em> is as quiet as it gets.
         <em class=code>&gt; 1</em> provides more run-time messages.
         <em class=code>&gt; 5</em> provides ALL run-time messages.  
    </TD>
</TR>

</TBODY>
</TABLE>
</div>

<br />
<br />

<!--==================================================================-->

<A NAME="mpas_vars_nml"></A>
<P>
The <em class=code>&amp;mpas_vars_nml</em> namelist contains the list 
of MPAS variables that make up the DART state vector.
The order the items are specified controls the order of the data in the
state vector, so it should not be changed without regenerating all
DART initial condition or restart files.
These variables are directly updated by the filter assimilation.
</P>
<P>
Any variables whose values cannot exceed a given
minimum or maximum can be listed in <em class=code>mpas_state_bounds</em>.
When the data is written back into the MPAS NetCDF files values
outside the allowed range will be detected and changed.  
Data inside the DART state vector and data written to 
the DART diagnostic files will not go through this test and
values may exceed the allowed limits.
Note that changing values at the edges of the distribution
means it is no longer completely gaussian.  In practice
this technique has worked effectively, but if the assimilation
is continually trying to move the values outside the permitted
range the results may be of poor quality.  Examine the diagnostics for
these fields carefully when using bounds to restrict their values.
</P>

<div class=namelist>
<pre>
&amp;mpas_vars_nml
   mpas_state_variables = 'theta',                 'KIND_POTENTIAL_TEMPERATURE',
                          'uReconstructZonal',     'KIND_U_WIND_COMPONENT',
                          'uReconstructMeridional','KIND_V_WIND_COMPONENT',
                          'qv',                    'KIND_VAPOR_MIXING_RATIO',
                          'qc',                    'KIND_CLOUDWATER_MIXING_RATIO',
                          'surface_pressure',      'KIND_SURFACE_PRESSURE'
   mpas_state_bounds    = 'qv','0.0','NULL','CLAMP',
                          'qc','0.0','NULL','CLAMP',
/
</pre>
</div>

<br />
<br />

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>

<TR><TD>mpas_vars_nml</TD>
    <TD>character(len=NF90_MAX_NAME)::<br />
                   dimension(160)
    <TD>The table that both specifies which MPAS-ATM variables will be
        placed in the state vector, and also relates those variables 
        to the corresponding DART kinds.  The first column in each pair must
        be the exact NetCDF name of a field in the MPAS file.  The second column
        in each pair must be a KIND known to the DART system.  See 
        <em class=file>obs_kind/obs_kind_mod.f90</em> for known names.
        This file is autogenerated when DART builds filter for a particular
        model, so run <em class=code>quickbuild.csh</em> in the work directory
        first before examining this file.  Use the generic kind list in 
        the obs_kind_mod tables, not the specific type list.
    </TD>
</TR>

<TR><TD>mpas_state_bounds</TD>
    <TD>character(len=NF90_MAX_NAME)::<br />
                   dimension(160)
    <TD> List only MPAS-ATM variables that must restrict their values to remain
         between given lower and/or upper bounds.
         Columns are: NetCDF variable name, min value, max value, and action to take
         for out-of-range values.  Either min or max can have the string 'NULL' to indicate
         no limiting will be done.  If the action is 'CLAMP' out of range values will be
         changed to the corresponding bound and execution continues; 
         'FAIL' stops the executable if out of range values are detected.</TD>
</TR>

</TBODY>
</TABLE>
</div>

<br />
<br />
</TABLE>

<!--==================================================================-->
<A NAME="Grid information"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Grid information</H2>
<P>As the forward operators use the unstructured grid meshes in MPAS-ATM, the DART/MPAS interface needs to read static 
   variables related to the grid structure from the MPAS ATM 'history' file (specified in 
   <em class=code>model_analysis_filename</em>). 
   These variables are used to find the closest cell to an observation 
   point in the cartesian coordinate (to avoid the polar issues). 
</P>

<table width="100%" cellpadding="3">
<tr><td valign="top">integer :: nCells        </td><td>the number of cell centers</td></tr>
<tr><td valign="top">integer :: nEdges        </td><td>the number of cell edges </td></tr>
<tr><td valign="top">integer :: nVertices     </td><td>the number of cell vertices</td></tr>
<tr><td valign="top">integer :: nVertLevels   </td><td>the number of vertical levels for mass fields</td></tr>
<tr><td valign="top">integer :: nVertLevelsP1 </td><td>the number of vertical levels for vertical velocity</td></tr>
<tr><td valign="top">integer :: nSoilLevels   </td><td>the number of soil levels</td></tr>
<tr><td valign="top">real(r8) :: latCell(:)   </td><td>the latitudes  of the cell centers [-90,90] </td></tr>
<tr><td valign="top">real(r8) :: lonCell(:)   </td><td>the longitudes of the cell centers [0, 360] </td></tr>
<tr><td valign="top">real(r8) :: latEdge(:)   </td><td>the latitudes  of the edges [-90,90], if edge winds are used. </td></tr>
<tr><td valign="top">real(r8) :: lonEdge(:)   </td><td>the longitudes of the edges [0, 360], if edge winds are used. </td></tr>
<tr><td valign="top">real(r8) :: xVertex(:)   </td><td>The cartesian location in x-axis of the vertex </td></tr>
<tr><td valign="top">real(r8) :: yVertex(:)   </td><td>The cartesian location in y-axis of the vertex </td></tr>
<tr><td valign="top">real(r8) :: zVertex(:)   </td><td>The cartesian location in z-axis of the vertex </td></tr>
<tr><td valign="top">real(r8) :: xEdge(:)   </td><td>The cartesian location in x-axis of the edge, if edge winds are used. </td></tr>
<tr><td valign="top">real(r8) :: yEdge(:)   </td><td>The cartesian location in y-axis of the edge, if edge winds are used. </td></tr>
<tr><td valign="top">real(r8) :: zEdge(:)   </td><td>The cartesian location in z-axis of the edge, if edge winds are used. </td></tr>
<tr><td valign="top">real(r8) :: zgrid(:,:)   </td><td>geometric height at cell centers (nCells, nVertLevelsP1)</td></tr>
<tr><td valign="top">integer  :: CellsOnVertex(:,:)   </td><td>list of cell centers defining a triangle </td></tr>
<tr><td valign="top">integer  :: edgesOnCell(:,:)   </td><td>list of edges on each cell </td></tr>
<tr><td valign="top">integer  :: verticesOnCell(:,:)   </td><td>list of vertices on each cell </td></tr>
<tr><td valign="top">integer  :: edgeNormalVectors(:,:)   </td><td>unit direction vectors on the edges (only used if <em class=code>use_u_for_wind</em> = .true.)</td></tr>
</table>
<br />

<!--==================================================================-->
<A NAME="model_mod"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>model_mod variable storage</H2>

   <P>
   <em class=file>input.nml</em> :: <em class=code>&amp;mpas_vars_nml</em> 
   defines the list of MPAS variables used to build the DART state vector. 
   Combined with an MPAS analysis file, the information is used to 
   determine the size of the DART state vector and derive the metadata.
   To keep track of what variables are contained in the DART state vector,
   an array of a user-defined type called "progvar" is available with the 
   following components:
   </P>

   <div class="unix">
<pre>
type progvartype
   private
   character(len=NF90_MAX_NAME) :: varname
   character(len=NF90_MAX_NAME) :: long_name
   character(len=NF90_MAX_NAME) :: units
   character(len=NF90_MAX_NAME), dimension(NF90_MAX_VAR_DIMS) :: dimname
   integer, dimension(NF90_MAX_VAR_DIMS) :: dimlens
   integer :: xtype         ! netCDF variable type (NF90_double, etc.) 
   integer :: numdims       ! number of dimensions - excluding TIME
   integer :: numvertical   ! number of vertical levels in variable
   integer :: numcells      ! number of cell locations (typically cell centers)
   integer :: numedges      ! number of edge locations (edges for normal velocity)
   logical :: ZonHalf       ! vertical coordinate for mass fields (nVertLevels)
   integer :: varsize       ! variable size (dimlens(1:numdims))
   integer :: index1        ! location in dart state vector of first occurrence
   integer :: indexN        ! location in dart state vector of last  occurrence
   integer :: dart_kind
   character(len=paramname_length) :: kind_string
   logical  :: clamping     ! does variable need to be range-restricted before 
   real(r8) :: range(2)     ! lower and upper bounds for the data range.
   logical  :: out_of_range_fail  ! is out of range fatal if range-checking?
end type progvartype

type(progvartype), dimension(max_state_variables) :: progvar
</pre>
   </div>

   <P>
   The variables are simply read from the MPAS analysis file and stored in the DART state
   vector such that all quantities for one variable are stored contiguously. Within each
   variable; they are stored vertically-contiguous for each horizontal location. From a storage 
   standpoint, this would be equivalent to a Fortran variable dimensioned 
   x(nVertical,nHorizontal,nVariables). The fastest-varying dimension is vertical,
   then horizontal, then variable ... naturally, the DART state vector is 1D. 
   Each variable is also stored this way in the MPAS analysis file.
   <br />
   </P>

<br />
<!--==================================================================-->
<A NAME="Compilation"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Compilation</H2>

<P>
The DART interface for MPAS-ATM can be compiled with various fortran compilers such as (but not limited to) 
gfortran, pgf90, and intel. It has been tested on a Mac and NCAR IBM supercomputer (yellowstone).
</P>

<P>
NOTE: While MPAS requires the PIO (Parallel IO) and pNetCDF
(Parallel NetCDF) libraries, DART uses only the plain NetCDF libraries.
If an altered NetCDF library is required by the parallel versions, there may 
be incompatibilities between the run-time requirements of DART and MPAS.
Static linking of one or the other executable, or swapping of modules
between executions may be necessary.
</P>

<br />

<!--==================================================================-->
<a name="conversions"></a>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Conversions</H2>

<div class=indent1>
   <h3>Converting between DART files and MPAS analysis files</h3>
   <P>is relatively straightforward. Given the namelist mechanism for
      determining the state variables and the MPAS history netCDF
      files exist, - everything that is needed is readily determined.
      <br />
      <br />
      There are two programs - both require the list of MPAS variables 
      to use in the DART state vector: the
      <em class="code">mpas_vars_nml</em> namelist in the 
      <em class="file">input.nml</em> file. The MPAS file name being 
      read and/or written is - in all instances - specified by the 
      <em class="code">model_nml:model_analysis_filename</em> variable in the 
      <em class="file">input.nml</em> namelist file.
   </P>
   <table width="100%" cellpadding="10">
   <tr><td valign="top"><a href="model_to_dart.html">model_to_dart.f90</a></td>
       <td>converts an MPAS analysis file (nominally named <em class=file>mpas_init.nc</em>) into a 
       DART-compatible file normally called <em class=file>dart_ics</em>&nbsp;.
       We usually wind up linking the actual analysis file to a static name that is used by DART.
       </td>
   </tr>
   <tr><td valign="top"><a href="dart_to_model.html">dart_to_model.f90</a></td>
       <td>inserts the DART output into an existing MPAS analysis netCDF file by
       overwriting the variables in the analysis netCDF file. 
       There are two different types of DART output files, so there is a namelist
       option to specify if the DART file has two time records or just one 
       (if there are two, the first one is the 'advance_to' time, followed 
       by the 'valid_time' of the ensuing state).
       <em class=program>dart_to_model</em> updates the MPAS analysis file 
       specified in <em class=file>input.nml</em><em class=code>model_nml:model_analysis_filename</em>.
       If the DART file contains an 'advance_to' time, separate control information is written 
       to an auxiliary file (named 'mpas_time') that is used by the <em class=file>advance_model.csh</em> script.
       </td>
   </tr>
   </table>
</div>

<!-- In namelist.input for the mpas model, we do have start_time, run_duration, and output_interval as below.

  config_start_time = '2010-10-23_03:00:00'  
  config_run_duration = '00_00:15:00'
  config_output_interval = '00_00:15:00'

Here the run_duration and output_interval do not have 'YYYY-MM', but the rest of them are the same as in start_time.
Do you think that is enough for the advance_model script? -->

<div class=indent1>
<P>The header of an MPAS analysis file is presented below - simply for context.
   Keep in mind that <strong>many</strong> variables have been removed for clarity.
   Also keep in mind that the multi-dimensional arrays listed below have the dimensions
   reversed from the Fortran convention.
</P>
</div>

<div class="unix">
<pre>366 mirage2:thoar% ncdump -h mpas_init.nc
netcdf mpas_analysis {
dimensions:
        StrLen = 64 ;
        Time = UNLIMITED ; // (1 currently)
        <em class=redtt>nCells</em> = 10242 ;                                  <em class=redtt>available in DART</em>
        <em class=redtt>nEdges</em> = 30720 ;                                  <em class=redtt>available in DART</em>
        maxEdges = 10 ;
        maxEdges2 = 20 ;
        <em class=redtt>nVertices</em> = 20480 ;                               <em class=redtt>available in DART</em>
        TWO = 2 ;
        THREE = 3 ;
        vertexDegree = 3 ;
        FIFTEEN = 15 ;
        TWENTYONE = 21 ;
        R3 = 3 ;
        <em class=redtt>nVertLevels</em> = 41 ;                                <em class=redtt>available in DART</em>
        <em class=redtt>nVertLevelsP1</em> = 42 ;                              <em class=redtt>available in DART</em>
        nMonths = 12 ;
        nVertLevelsP2 = 43 ;
        <em class=redtt>nSoilLevels</em> = 4 ;                                 <em class=redtt>available in DART</em>
variables:
        char <em class=redtt>xtime(Time, StrLen)</em> ;                        <em class=redtt>available in DART</em>
        double <em class=redtt>latCell(nCells)</em> ;                          <em class=redtt>available in DART</em>
        double <em class=redtt>lonCell(nCells)</em> ;                          <em class=redtt>available in DART</em>
        double <em class=redtt>latEdge(nEdges)</em> ;                          <em class=redtt>available in DART</em>
        double <em class=redtt>lonEdge(nEdges)</em> ;                          <em class=redtt>available in DART</em>
        int indexToEdgeID(nEdges) ;
        double latVertex(nVertices) ;
        double lonVertex(nVertices) ;
	double <em class=redtt>xVertex(nVertices)</em> ;                       <em class=redtt>available in DART</em>
	double <em class=redtt>yVertex(nVertices)</em> ;                       <em class=redtt>available in DART</em>
	double <em class=redtt>zVertex(nVertices)</em> ;                       <em class=redtt>available in DART</em>
	double <em class=redtt>xEdge(nVertices)</em> ;                         <em class=redtt>available in DART</em>
	double <em class=redtt>yEdge(nVertices)</em> ;                         <em class=redtt>available in DART</em>
	double <em class=redtt>zEdge(nVertices)</em> ;                         <em class=redtt>available in DART</em>
        int indexToVertexID(nVertices) ;
        int cellsOnEdge(nEdges, TWO) ;
        int nEdgesOnCell(nCells) ;
        int nEdgesOnEdge(nEdges) ;
        int <em class=redtt>edgesOnCell(nCells, maxEdges)</em> ;               <em class=redtt>available in DART</em>
        int edgesOnEdge(nEdges, maxEdges2) ;
        double weightsOnEdge(nEdges, maxEdges2) ;
        double dvEdge(nEdges) ;
        double dcEdge(nEdges) ;
        double angleEdge(nEdges) ;
        double <em class=redtt>edgeNormalVectors(nEdges, R3)</em> ;            <em class=redtt>available in DART</em>
        double cellTangentPlane(nEdges, TWO, R3) ;
        int cellsOnCell(nCells, maxEdges) ;
        int <em class=redtt>verticesOnCell(nCells, maxEdges)</em> ;            <em class=redtt>available in DART</em>
        int verticesOnEdge(nEdges, TWO) ;
        int edgesOnVertex(nVertices, vertexDegree) ;
        int <em class=redtt>cellsOnVertex(nVertices, vertexDegree)</em> ;      <em class=redtt>available in DART</em>
        double kiteAreasOnVertex(nVertices, vertexDegree) ;
        double rainc(Time, nCells) ;
        double cuprec(Time, nCells) ;
        double cutop(Time, nCells) ;
        double cubot(Time, nCells) ;
        double relhum(Time, nCells, nVertLevels) ;
        double qsat(Time, nCells, nVertLevels) ;
        double graupelnc(Time, nCells) ;
        double snownc(Time, nCells) ;
        double rainnc(Time, nCells) ;
        double graupelncv(Time, nCells) ;
        double snowncv(Time, nCells) ;
        double rainncv(Time, nCells) ;
        double sr(Time, nCells) ;
        double surface_temperature(Time, nCells) ;
        double surface_pressure(Time, nCells) ;
        double coeffs_reconstruct(nCells, maxEdges, R3) ;
        double theta_base(Time, nCells, nVertLevels) ;
        double rho_base(Time, nCells, nVertLevels) ;
        double pressure_base(Time, nCells, nVertLevels) ;
        double exner_base(Time, nCells, nVertLevels) ;
        double exner(Time, nCells, nVertLevels) ;
        double h_divergence(Time, nCells, nVertLevels) ;
        double uReconstructMeridional(Time, nCells, nVertLevels) ;
        double uReconstructZonal(Time, nCells, nVertLevels) ;
        double uReconstructZ(Time, nCells, nVertLevels) ;
        double uReconstructY(Time, nCells, nVertLevels) ;
        double uReconstructX(Time, nCells, nVertLevels) ;
        double pv_cell(Time, nCells, nVertLevels) ;
        double pv_vertex(Time, nVertices, nVertLevels) ;
        double ke(Time, nCells, nVertLevels) ;
        double rho_edge(Time, nEdges, nVertLevels) ;
        double pv_edge(Time, nEdges, nVertLevels) ;
        double vorticity(Time, nVertices, nVertLevels) ;
        double divergence(Time, nCells, nVertLevels) ;
        double v(Time, nEdges, nVertLevels) ;
        double rh(Time, nCells, nVertLevels) ;
        double theta(Time, nCells, nVertLevels) ;
        double rho(Time, nCells, nVertLevels) ;
        double qv_init(nVertLevels) ;
        double t_init(nCells, nVertLevels) ;
        double u_init(nVertLevels) ;
        double pressure_p(Time, nCells, nVertLevels) ;
        double tend_theta(Time, nCells, nVertLevels) ;
        double tend_rho(Time, nCells, nVertLevels) ;
        double tend_w(Time, nCells, nVertLevelsP1) ;
        double tend_u(Time, nEdges, nVertLevels) ;
        double qv(Time, nCells, nVertLevels) ;
        double qc(Time, nCells, nVertLevels) ;
        double qr(Time, nCells, nVertLevels) ;
        double qi(Time, nCells, nVertLevels) ;
        double qs(Time, nCells, nVertLevels) ;
        double qg(Time, nCells, nVertLevels) ;
        double tend_qg(Time, nCells, nVertLevels) ;
        double tend_qs(Time, nCells, nVertLevels) ;
        double tend_qi(Time, nCells, nVertLevels) ;
        double tend_qr(Time, nCells, nVertLevels) ;
        double tend_qc(Time, nCells, nVertLevels) ;
        double tend_qv(Time, nCells, nVertLevels) ;
        double qnr(Time, nCells, nVertLevels) ;
        double qni(Time, nCells, nVertLevels) ;
        double tend_qnr(Time, nCells, nVertLevels) ;
        double tend_qni(Time, nCells, nVertLevels) ;

</pre>
</div>



<A NAME="OtherModulesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>

<PRE>
types_mod
time_manager_mod
threed_sphere/location_mod
threed_cartesian/xyz_location_mod
utilities_mod
obs_kind_mod
mpi_utilities_mod
random_seq_mod
mpas_atm/get_geometry_mod
mpas_atm/get_reconstruct_mod
</PRE>


<!--==================================================================-->
<!-- Note to authors. The first row of the table is different.        -->
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<P>
Only a select number of interfaces used are discussed here.
Each module has its own discussion of their routines. 
</P>

<h3 class=indent1>Required Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod,&nbsp;only&nbsp;:</em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<h3 class=indent1>Unique Interface Routines</h3>
<TABLE width=50%>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_model_analysis_filename">get_model_analysis_filename</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_grid_definition_filename">get_grid_definition_filename</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#analysis_file_to_statevector">analysis_file_to_statevector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#statevector_to_analysis_file">statevector_to_analysis_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_analysis_time">get_analysis_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_model_time">write_model_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_grid_dims">get_grid_dims</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#print_variable_ranges">print_variable_ranges</A></TD></TR>
</TABLE>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--==================================================================-->
<H3 class=indent1>Required Interface Routines</H3>
<!--==================================================================-->

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br />
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
Required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br />
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>adv_1step</em>
is not used for the mpas model.
Advancing the model is done through the <em class=program>advance_model</em> script.
This is a NULL_INTERFACE, provided only for compatibility with the DART requirements.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br />
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,&nbsp;var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_state_meta_data</em>
returns metadata about a given element of the DART representation of the 
model state vector. Since the DART model state vector is a 1D array and the
native model grid is multidimensional, <em class=code>get_state_meta_data</em>  
returns information about the native model state vector representation. Things
like the <em class=code>location</em>, or the type of the variable 
(for instance: temperature, u wind component, ...). 
The integer values used to indicate different variable types in 
<em class=code>var_type</em> are themselves defined as public interfaces 
to model_mod if required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns the 3D location of the indexed state variable.
        The <em class=code>location_ type</em> comes from
        <em class=file>DART/location/threed_sphere/location_mod.f90</em>.
        Note that the lat/lon are specified in degrees by the user but are converted
        to radians internally.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.
        The type is one of the list of supported observation types, found in
        the block of code starting 
        <em class=code>!&nbsp;Integer&nbsp;definitions&nbsp;for&nbsp;DART&nbsp;TYPES</em>
        in <em class=file>DART/obs_kind/obs_kind_mod.f90</em> 
        </TD></TR>

</TABLE>

<P>
The list of supported variables in <em class=file>DART/obs_kind/obs_kind_mod.f90</em>
is created by <em class=program>preprocess</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br />
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a model state, <em class=code>model_interpolate</em> returns the value of 
the desired observation type (which could be a state variable) that would be 
observed at the desired location. The interpolation method is either
completely specified by the model, or uses some standard 2D or 3D scalar
interpolation routines.
Put another way, <em class=code>model_interpolate</em> will apply the forward
operator <strong>H</strong> to the model state to create an observation at the desired 
location.
<br />
<br />
If the interpolation is valid, <em class=code>istatus = 0</em>. 
In the case where the observation operator is not defined at the given 
location (e.g. the observation is below the lowest model level, above the top
level, a type not found in the state vector), interp_val is returned 
as <em>MISSING_R8</em> and istatus = 1. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which type of observation is desired.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.
       <br />success == 0, failure == any positive values (negative values
        are reserved for system use)</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br />
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_model_time_step</em>
returns the forecast length to be used as the "model base time step" in the filter.
This is the minimum amount of time the model can be advanced by 
<em class=program>filter</em>.  
This is <em>NOT</em> related to the internal dynamic typestep of the
model; it must be a multiple of the minimum amount of model time
in which the model can be started and stopped.
<em>This is also the assimilation window</em>. 
All observations within (+/-) one half of the forecast
length are used for the assimilation.
In the <em class=program>MPAS</em> case, this is set from 
the namelist values for <em class=file>input.nml</em> :: 
<em class=code>&amp;model_nml :: assimilation_period_days, assimilation_period_seconds</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Assimilation window and multiple of some timestep the
        model can be advanced.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br />
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>static_init_model</em>
is called for runtime initialization of the model. 
The namelists are read to determine runtime configuration of the model, 
the grid coordinates, etc. There are no input arguments and no return values. 
The routine sets module-local private attributes that can then be queried by the
public interface routines.
<br />
<br />
The namelists (all mandatory) are:<br />
<em class=file>input.nml</em> :: <em class=code>&amp;model_mod_nml</em>, and<br />
<em class=file>input.nml</em> :: <em class=code>&amp;mpas_vars_nml</em>.<br />
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br />
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>end_model</em>
is used to clean up storage for the model, etc. 
when the model is no longer needed. There are no arguments and no return values.
The grid variables are deallocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br />
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_time</em>
returns the time at which the model will start if no input initial conditions are
to be used. 
The only time this routine would get called is if the 
<em class=file>input.nml</em> :: <em class=code>&amp;perfect_model_obs_nml:start_from_restart</em> 
is .false., which is not supported in the MPAS model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>the starting time for the model if no initial conditions are to be supplied.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br />
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_conditions</em>
returns default initial conditions for model; generally used for spinning up
initial model states. For the MPAS model it is just a stub because 
the initial state is always provided by the input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial conditions for state vector.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_atts</em>
writes model-specific attributes to an opened netCDF file:
In the MPAS case, this includes information like the 
coordinate variables (the grid arrays: lonCell, latCell, xCell, lonVertex, zgrid, etc.),
information from some of the namelists, and the variable attributes of either the 1D state 
vector or the prognostic variables (potential temperature, dry density, vertical velocity, etc.).
All the required information (except for the netCDF file identifier) 
is obtained from the scope of the <em class=program>model_mod</em> module.
The <em class=file>input.nml</em> 
is preserved in the netCDF file as variables <em class=code>inputnml</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

<P>
<em class=code>nc_write_model_atts</em>
is responsible for the model-specific attributes in the following DART-output netCDF files:
<em class=file>True_State.nc</em>, 
<em class=file>Prior_Diag.nc</em>, and 
<em class=file>Posterior_Diag.nc</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
integer                            :: <em class=code>ierr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_vars</em>
writes a copy of the state variables to a NetCDF file. Multiple copies of the
state for a given time are supported, allowing, for instance, a single file to
include multiple ensemble estimates of the state. Whether the state vector is 
parsed into prognostic variables (potential temperature, dry density, vertical velocity, etc.) or simply written as a 1D array is controlled by 
<em class=file>input.nml</em> <em class=code>&amp;model_mod_nml:output_state_vector</em>.
If <em class=code>output_state_vector&nbsp;=&nbsp;.true.</em> the state vector is 
written as a 1D array (the simplest case, but hard to explore with the diagnostics).
If <em class=code>output_state_vector&nbsp;=&nbsp;.false.</em> the state vector is 
parsed into prognostic variables before being written.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br />
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1> <!-- Description -->
<P>
Only called when
<em class=file>input.nml</em> :: <em class=code>&amp;filter_nml:start_from_restart = .false.</em>.
A single model state is still required, and gaussian noise with the magnitude
determined by the setting of
<em class=file>input.nml</em> :: <em class=code>&amp;model_mod_nml:model_perturbation_amplitude</em>.
is added to each item in the state vector.
Generally this is not the best way to generate a set of initial conditions,
but can be useful if very small magnitude noise is added and then the
model is run freely for an extended period of time (several model weeks)
to generate realistic features in the model state.
<br />
<br />
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>The perturbed state vector.</TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>This is always 
        <em class=code>.true.</em>, indicating a random perturbation is added to each model state
 variable independently.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, obs, obs_kind, &amp;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type),              intent(in ) :: <em class=code>gc</em>
type(location_type),               intent(in ) :: <em class=code>base_obs_loc</em>
integer,                           intent(in ) :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in ) :: <em class=code>obs</em>
integer,             dimension(:), intent(in ) :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer,             dimension(:), intent(out) :: <em class=code>close_ind</em>
real(r8), optional,  dimension(:), intent(out) :: <em class=optionalcode>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a DART location (referred to as "base") and a set of locations, and a
definition of 'close' - return a subset of locations that are 'close', as well
as their distances to the DART location and their indices. This routine intentionally
masks a routine of the same name in <em class=program>location_mod</em> because we
need to be able to convert vertical coordinates that are not already
in the same units as specified by
<em class=file>input.nml</em>::<em class=code>&amp;model_nml:vert_localization_coord</em>.
<br />
<br />
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.  The list of locations
passed in via the <em class=code>obs</em> argument must be identical to
the list of <em class=code>obs</em> passed into the most recent call
to <em class=code>get_close_obs_init()</em>.  If the list of locations
of interest changes, <em class=code>get_close_obs_destroy()</em> must
be called and then the two initialization routines must be called
before using <em class=code>get_close_obs()</em> again.
<br />
<br />
For vertical distance computations, the general philosophy is to convert all
vertical coordinates to a common coordinate. This coordinate type is defined
in the namelist with the variable "vert_localization_coord".
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Structure to allow efficient identification of
        locations 'close' to a given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_loc</em></TD>
    <TD>Single given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_kind</em></TD>
    <TD>Kind of the single location.</TD></TR>
<TR><TD valign=top><em class=code>obs</em></TD>
    <TD>List of candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Kind associated with candidate locations.</TD></TR>
<TR><TD valign=top><em class=code>num_close</em></TD>
    <TD>Number of locations close to the given location.</TD></TR>
<TR><TD valign=top><em class=code>close_ind</em></TD>
    <TD>Indices of those locations that are close.</TD></TR>
<TR><TD valign=top><em class=optionalcode>dist</em></TD>
    <TD>Distance between given location and the
        close ones identified in close_ind.</TD></TR>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br />
<div class="routine">
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>ens_mean_for_model</em>
normally saves a copy of the ensemble mean to module-local storage.
This is a NULL_INTERFACE for the MPAS model. At present there is
no application which requires module-local storage of the ensemble mean.
No storage is allocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean</em></TD>
    <TD>State vector containing the ensemble mean.</TD></TR>

</TABLE>

</div>
<br />
<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>

<TABLE border=0 width=100%>
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the namelist - model_mod_nml and mpas_vars_nml</TD></TR>
<TR><TD>mpas_init.nc</TD>
    <TD>provides model state, and 'valid_time' of the model state</TD></TR>
<TR><TD>static.nc</TD>
    <TD>provides grid dimensions </TD></TR>
<TR><TD>True_State.nc</TD>
    <TD>the time-history of the "true" model state from an OSSE</TD></TR>
<TR><TD>Prior_Diag.nc</TD>
    <TD>the time-history of the model state before assimilation</TD></TR>
<TR><TD>Posterior_Diag.nc&nbsp;</TD>
    <TD>the time-history of the model state after assimilation</TD></TR>
<TR><TD>dart_log.out [default name]</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml [default name]</TD>
    <TD>the record of all the namelists actually USED - 
        contains the default values</TD></TR>
</TABLE>
<br />

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ul>
<li> The Data Assimilation section in the MPAS documentation
found at <a href="http://mpas-dev.github.io"> 
http://mpas-dev.github.io</a></li>
</ul>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>KNOWN BUGS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
