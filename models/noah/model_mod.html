<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (NOAH)</TITLE>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (NOAH)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>The <strong><a href="http://www.ral.ucar.edu/research/land/technology/lsm.php">NOAH</a>
   Land Surface Model</strong> and <strong>Data Assimilation Research Testbed (DART)</strong> 
   may now be used for assimilation experiments.
   This should be considered an 'alpha' release -- the code has only been
   tested for a single column configuration of NOAH.
   The offline 2D driver code:
   <a href="http://www.ral.ucar.edu/research/land/technology/lsm.php"
   >High-Resolution Land Data Assimilation System (HRLDAS) v3.3</a>
   (April 2011) is the version used to develop the interface.
   This must be downloaded and compiled outside the framework of DART.
   <br />
   <br />
   The <em class=file>simple_driver-v3.3</em> was deemed suboptimal because of poor restart
   characteristics.  Since the offline 2D driver code can be run at a single gridpoint
   and has excellent restart characteristics, there are no plans to support the
   <em class=file>simple-driver-v3.3</em> version of NOAH.
   <br />
   <br />
   Any of the variables in the NOAH restart file are available to be adjusted by the
   assimilation. The list of variables is set though a simple namelist interface. Since
   we are testing in a column configuration, there is no practical reason not to include
   all the variables necessary for a bit-for-bit restart:
   <em class=code>SOIL_T</em>,
   <em class=code>SOIL_M</em>,
   <em class=code>SOIL_W</em>,
   <em class=code>SKINTEMP</em>,
   <em class=code>SNODEP</em>,
   <em class=code>WEASD</em>,
   <em class=code>CANWAT</em>, and
   <em class=code>QFX</em>. These variables are then adjusted to be consistent
   with real observations and stuffed back into the same netCDF restart files.
   Since DART is an ensemble algorithm there are multiple restart files for a
   single restart time; one for each ensemble member. Creating the initial ensemble
   of land surface states is an area of active research. At present, it may be sufficient
   to use a climatological ensemble; e.g., using the restarts for '1 January 00Z'
   from 50 consecutive years.
   <br />
   <br />
   The <em class=program>offline hrldas-v3.3</em> driver is designed to use atmospheric
   forcing files that cover a VERY short period - about every hour.
   Consequently, the directories that contain the forcing files get very
   cluttered for experiments that may cover years, for example.
   There is reason to believe that the ensemble system will benefit from having
   unique atmospheric forcing for each ensemble member.
   A reasonable ensemble size is 50 or 80 or so. You do the math.
   <br />
   <br />
   DART reads the NOAH namelist <em class=code>&amp;NOAHLSM_OFFLINE</em> from a
   file called <em class=file>namelist.hrldas</em> for several pieces of information.
   DART is responsible for starting/stopping NOAH; the restart information is
   conveyed through the NOAH namelist. <strong>Unpleasant Reality #1 :</strong> managing
   the tremendous number of hourly forcing files for every ensemble member is tedious.
   To facilitate matters, the DART/NOAH system uses a <em>single</em> netCDF file for
   each ensemble member that contains ALL of the forcing for that ensemble member.
   The DART <a href="shell_scripts/advance_model.csh">advance_model.csh</a>
   script for NOAH uses the
   <em class=program>ncks</em> program to extract the required forcing timesteps
   into the unique forcing files required by NOAH. The simplest way we could think of to
   provide the location of the 'master' forcing files was by adding a <em>comment</em>
   in the <em class=file>namelist.hrldas</em> file of the form :
   <em class=code>FORCING_FILE_DIRECTORY&nbsp;=&nbsp;"/path/to/your/forcing/files"</em>
   We felt it important to specify this information in the
   <em class=file>namelist.hrldas</em> file since it is a strong analogue of the
   traditional NOAH <em class=code>INDIR</em> variable.
</P>
   <h3 class=indent1>For the impatient - skip the fundamentals and get frustrated.</h3>
<P>
   There are several scripts in the <em class=file>DART/models/noah/shell_scripts</em>
   directory that assist in configuring and running experiments:
   <em class=program>setup_pmo.csh</em>,
   <em class=program>run_pmo.csh</em>,
   <em class=program>setup_filter.csh</em>, and
   <em class=program>run_filter.csh</em>&nbsp;.
   The scripts are not intended to be black boxes.
   <strong>You are expected to read them and modify them to your own purpose.</strong>
</P>

<h3 class=indent1>The offline 2D HRLDAS-V3.3</h3>
<P>
   The offline 2D HRLDAS-V3.3 and the development branch of DART was tested and 
   run on a MacBook Pro laptop running OS X 10.7.4 (Lion) with gfortran v 4.5.0.
   The <em class=program>Noah_hrldas_beta</em> source code was downloaded from
   <a href="http://www.ral.ucar.edu/research/land/technology/lsm.php"
   >the Unified NOAH/LSM website</a> and built - outside the DART framework - 
   to produce a standalone executable.
</P>
   <br />
   <br />
<P>
   Trivial modifications to the distributed hrldas makefiles were necessary to compile
   <em class=program>the Noah_hrldas_beta</em> on a case-insensitive filesystem.
   All of the original 14 <em class=file>Makefile</em> files have to be changed:
</P>
   <div class=unix>
   $(CPP) $(CPPFLAGS) $(CPPHRLDAS) $(*).F &gt; $(*).f<br />
   to<br />
   $(CPP) $(CPPFLAGS) $(CPPHRLDAS) $(*).F &gt; $(*).<em class=input>f90</em><br />
   </div>
<P>
   i.e. all instances of ".f" must be changed to ".f90". If you do not have
   a case-insensitive filesystem, the original Makefiles will not need these modifications. 
</P>
   <br />
   <br />
   The DART components were built for debugging with the following settings:
   <pre>
   FC = gfortran
   LD = gfortran
   INCS = -I${NETCDF}/include
   LIBS = -L${NETCDF}/lib -lnetcdff -lnetcdf -lcurl -lhdf5_hl -lhdf5 -lz  -lm
   FFLAGS = -g -O0 -ffree-line-length-none -fbounds-check -frecord-marker=4 -ffpe-trap=invalid $(INCS)
   LDFLAGS = $(FFLAGS) $(LIBS)
   </pre>

<a name="NOAHtimes"></a>
<h3 class=indent1>A word about NOAH times and dates</h3>
   <P>HRLDAS-V3.3 has some unusual conventions as pertains the contents of 'restart' files.
   You should confirm the following to prove it to yourself - <strong>outside</strong> of
   the DART framework. Your actual numbers will change, but the point should be obvious.
   </P>
   <br />
   <br />
   <OL>
   <LI>Assume there is a NOAH restart file:<br />
       <em class=file>RESTART.2009010118_DOMAIN1</em> containing
       <pre>
       Times = "2009-01-01_18:00:00" ;
       SOIL_M = 0.100843, 0.1324335, 0.1104331, 0.16349 ;
       QFX = 12.03423 ;
       </pre>
   </LI>
   <LI> Now, run/advance NOAH for a single (1 hour) timestep
       (i.e. from 18Z to 19Z). The following files are created:<br />
       <em class=file>2009010118.LDASOUT_DOMAIN1</em> containing
       <pre>
       Times = "2009-01-01_18:00:00" ;
<div style="color: blue">       SOIL_M = 0.1007659, 0.132411, 0.1104217, 0.1634897 ;
       QFX = 14.90484 ;</div></pre>
       <em class=file>RESTART.2009010119_DOMAIN1</em> containing
       <pre>
       Times = "2009-01-01_19:00:00" ;
<div style="color: blue">       SOIL_M = 0.1007659, 0.132411, 0.1104217, 0.1634897 ;
       QFX = 14.90484 ;</div></pre>
       <em class=file>2009010119.LDASOUT_DOMAIN1</em> containing
       <pre>
       Times = "2009-01-01_19:00:00" ;
       SOIL_M = 0.1006793, 0.1323851, 0.1104083, 0.1634894 ;
       QFX = 17.13207 ;
       </pre>
    </LI>
    </OL>

<P>
   The contents of the <em class=file>2009010118.LDASOUT_DOMAIN1</em>
   contain the <strong>same</strong> values as the 
   <em class=file>RESTART.2009010119_DOMAIN1</em>
   -- <strong>although the names and <em class=code>Times</em> imply they
   are from different times.</strong> The <em class=code>Times</em> in the
   LDASOUT files are fundamentally "now"casts and reflect the valid
   time of the model state. This is the time that DART requires.
</P>
   <br />
   <br />
<P>
   <strong>IMPORTANT:</strong> DART reads and modifies the RESTART files.
   DART internally adjusts the times in the restart files to correspond to
   the time of the companion LDASOUT file. The <em class=code>Times</em> array
   is unchanged. NOTE: The DART/NOAH interface uses the Gregorian calendar.
</P>

<a name="conversion"></a>
<h3 class=indent1>Converting between DART files and NOAH restart files</h3>
   <P>
      The information about how the NOAH variables are stored in the DART
      state vector comes from the order in which the variables are specified in
      <em class=file>input.nml</em>&nbsp;<em class=code>&amp;model_nml:noah_state_variables</em>&nbsp;,
      as is the the name of the NOAH restart file.
      DART also needs to read the
      <em class=file>namelist.hrldas</em>&nbsp;<em class=code>&amp;NOAHLSM_OFFLINE</em> namelist.
      <br />
      <br />
      There are two programs - both use the <em class=program>model_mod</em> module,
      and both have their own documentation :
   </P>
   <table width="100%" cellpadding="10">
   <tr><td valign="top"><a href="noah_to_dart.html">noah_to_dart.f90</a></td>
       <td>converts a NOAH restart file into a DART-compatible file normally 
       called <em class=file>dart_ics</em>&nbsp;.
       We usually wind up linking the NOAH restart files to a
       static name (<em class=file>restart.nc</em>).
       <a href="noah_to_dart.html">[noah_to_dart.html]</a>
       </td>
   </tr>
   <tr><td valign="top"><a href="dart_to_noah.html">dart_to_noah.f90</a></td>
       <td><strong>updates</strong> some or all of a NOAH restart file with the 
       posterior DART state vector.  There is the ability to selectively avoid
       updating the NOAH variables. This allows one to include NOAH variables in
       the DART state vector to aid in the application of observation operators, etc.,
       without having to modify those variables in the NOAH restart file.
       <!--There are two different types of DART output files, so there is a namelist
       option to specify if the DART file has two time records or just one
       (if there are two, the first one is the 'advance_to' time, followed
       by the 'valid_time' of the ensuing state). <em class=program>dart_to_noah</em>
       requires the DART file to be named <em class=file>dart_restart</em> and the
       NOAH restart file have a name of <em class=file>restart.nc</em> &nbsp;.
       If the DART file contains an 'advance_to' time,
       <em class=program>dart_to_noah</em> creates a file
       <em class=file>noah_advance_information.txt</em> which contains information
       to control the length of the NOAH integration.-->
       <a href="dart_to_noah.html">[dart_to_noah.html]</a>
       </td>
   </tr>
   </table>

<a name="PerfectModel"></a>
   <h3 class=indent1>Running a "Perfect Model" experiment ... OSSE</h3>
   <P>
   The example requires a basic knowledge of running NOAH for a single column.
   Since the single-column version requires such small netCDF input files, it is
   possible to simply use <em class=program>ncdump</em> to convert these files
   to text files, edit them, and generate new netCDF files using
   <em class=program>ncgen</em>.
   An appropriate <em class=file>wrfinput</em> file may be generated by editing the
   <em class=file>templates/wrfinput.template.ascii</em> file and using
   <em class=program>ncgen</em>, for example.
   <br />
   <br />
   Four scripts are provided to demonstrate how to set up and run a
   perfect model experiment for a single site - with one caveat.
   You must provide your own initial ensemble for the experiment.
   The scripts are not intended to be black boxes.
   You are expected to read them and modify them to your own purpose.
   <br />
   <br />
   The scripts assume the directory containing the DART
   executables is <em class=file>${DARTDIR}/work</em>. and 
   the directory containing the NOAH executables is <em class=file>${NOAHDIR}/Run</em>.
   </P>
   <table width="100%" cellpadding="10">
   <TR><TD valign=top>1)<a href="shell_scripts/setup_pmo.csh">&nbsp;setup_pmo.csh</a></TD>
       <TD>This script stages the run of
       <a href="../../perfect_model_obs/perfect_model_obs.html">perfect_model_obs</a>.
       The directory where you run the script is called <strong>CENTRALDIR</strong>
       and will be the working directory for the experiment. The required input
       observation sequence file must be created in the normal DART way 
       (<a href="http://www.image.ucar.edu/DAReS/DART/DART_Observations.php#obs_synthetic">one way: synthetic</a>)
       and must
       exist before running this script.  All the necessary data
       files and exectuables for a perfect model experiment get copied to
       CENTRALDIR so that you may run multiple experiments at the same time - 
       in separate CENTRALDIRs.</TD>
   </TR>

   <TR><TD valign=top>2)<a href="shell_scripts/run_pmo.csh">&nbsp;run_pmo.csh</a></TD>
       <TD>very simply - it advances NOAH and applies the observation operator
       to put the "perfect" observations in an observation sequence file that can
       then be used for an assimilation.</TD>
   </TR>

   <TR><TD valign=top>3)<a href="shell_scripts/setup_filter.csh">&nbsp;setup_filter.csh</a></TD>
       <TD>builds upon the work of <em class=program>setup_pmo.csh</em> and stages
       a PRE-EXISTING initial ensemble. </TD>
   </TR>

   <TR><TD valign=top>4)<a href="shell_scripts/run_filter.csh">&nbsp;run_filter.csh</a></TD>
       <TD>Actually runs the filtering (assimilation) experiment.</TD>
   </TR>
   </table>

<a name="InitialEnsemble"></a>
<h3 class=indent1>Generating the initial ensemble</h3>
   <P>
      Creating the initial ensemble of soil moisture states is an area of active research.
      The ensemble must come from 'somewhere else'.
      At present, it may be sufficient to use a climatological ensemble; e.g.,
      using the NOAH restarts for '1 January 00Z' from 50 consecutive years
      from a hindcast experiment. It may also be sufficient to take a single
      model state, replicate it N times and force each of the N instances with
      different atmospheric conditions for 'a long time'.
      <br />
      <br />
      BTW - Experience has shown that having a paired (unique) atmospheric forcing
      maintains the ensemble spread during an assimilation better than simply
      forcing all the ensemble members with one single atmospheric state.
      <br />
      <br />
      DART has routines to perturb a single NOAH state and generate its own
      ensemble (typically done with <a href="#pert_model_state">pert_model_state</a>),
      but this produces model states that are incompatible with NOAH. We are interested
      in adopting/adapting strategies to create sensible initial conditions for NOAH.
      If you have an algorithm you believe will be useful, please contact us!
   </P>

<a name="observations"></a>
<h3 class=indent1>Observations</h3>
   <P>
      Some novel observations come from the Cosmic-ray Soil Moisture Observing System:
      <a href="http://cosmos.hwr.arizona.edu/">COSMOS</a>
      and are processed by DART routines in the
   <a href="../../observations/COSMOS/COSMOS_to_obs.html">DART/observations/COSMOS</a> directory.
   <br />
   <br />
   DART has a very object-oriented approach to observation support. 
   All observations that are intended to be supported must be
   <a href="../../preprocess/preprocess.html">preprocessed</a> into a single
   <em class=file>obs_def_mod.f90</em> and
   <em class=file>obs_kind_mod.f90</em> in the standard DART way.
   </P>

<a name="ExploringOutput"></a>
<h3 class=indent1>Exploring the Output</h3>
   <P>
      There are Matlab&#174; scripts for exploring the performance of the
      assimilation in observation-space (after running
      <a href="../../diagnostics/threed_sphere/obs_diag.html">obs_diag</a>
      to explore the <em class=file>obs_seq.final</em> file) - use the
      scripts starting with 'plot_', i.e.
      <em class=file>DART/diagnostics/matlab/plot_*.m</em>.
      As always, there are some model-specific items Matlab&#174; will need to know about in
      <em class=file>DART/models/NOAH/matlab</em>.
      <br />
      <br />
      The <em class=file>Prior_Diag.nc</em> and <em class=file>Posterior_Diag.nc</em>
      (and possibly <em class=file>True_State.nc</em> ) netCDF files have the model
      prognostic variables before and after the assimilation.
      The <em class=file>DART/matlab</em> scripts for NOAH are under development.
      <br />
      <br />
      It is also worthwhile to convert your obs_seq.final file to a netCDF format
      obs_sequence file with <a href="../../obs_sequence/obs_seq_to_netcdf.html">obs_seq_to_netcdf</a>
      and use any of the standard plots. Be aware that the COSMOS site-specific
      metadata will not get conveyed to the netCDF file.
</P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>model_nml NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
Consider yourself forewarned that character strings that contain a '/' must be
enclosed in quotes to prevent them from prematurely terminating the namelist.
</P>
<div class=namelist><pre>
<em class=call>namelist /model_nml/ </em> noah_netcdf_filename, &amp;
          assimilation_period_days, assimilation_period_seconds, &amp;
          model_perturbation_amplitude, output_state_vector, &amp;
          debug, noah_state_variables
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>This namelist is read from a file called <em class=file>input.nml</em>.
   This namelist provides control over the assimilation period for the model.
   All observations within (+/-) half of the assimilation period are assimilated.
   The assimilation period is the minimum amount of time the model can be advanced,
   and checks are performed to ensure that the assimilation window is a multiple of
   the NOAH model dynamical timestep.
</P>

<a name="model_perturbation_amplitude"></a>
<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>


<TR><!--contents--><TD valign=top>noah_netcdf_filename   </TD>
    <!--  type  --><TD valign=top>character(len=128)   </TD>
    <!--descript--><TD>The name of the NOAH RESTART file to use to
                       create the DART state vector. For convenience, the
                       <em class=program>advance_model.csh</em> script usually
                       links the most recent restart file to a static name.
                       <em class=units>[default: 'restart.nc']</em></TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_days</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The number of days to advance the model for each assimilation.
                       <em class=units>[default: 1]</em></TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_seconds</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>In addition to <em class=code>assimilation_period_days</em>,
                       the number of seconds to advance the model for each assimilation.
                       <em class=units>[default: 0]</em></TD></TR>

<TR><!--contents--><TD valign=top>model_perturbation_amplitude</TD>
    <!--  type  --><TD valign=top>real(r8)</TD>
    <!--descript--><TD valign=top>The amount of noise to add when trying to perturb a 
                       single state vector to create an ensemble. Only used when 
		       <em class=file>input.nml</em> <em class=code>&amp;filter_nml:start_from_restart = .false.</em>
                       See also <a href="#InitialEnsemble">Generating the initial ensemble</a>
                       at the start of this document. units: standard deviation
                       of a Gaussian distribution with the mean at the value of
                       the state vector element. <em class=units>[default: 0.2]</em>
		       </TD></TR>

<TR><!--contents--><TD valign=top>output_state_vector</TD>
    <!--  type  --><TD valign=top>logical</TD>
    <!--descript--><TD valign=top>The switch to determine the form of the state vector in the
                       output netCDF files. If <em class=code>.true.</em>
                       the state vector will be output exactly as DART uses it
                       ... one long array.  If <em class=code>.false.</em>,
                       the state vector is parsed into prognostic variables and
                       output that way -- much easier to use with 'ncview', for
                       example. <em class=units>[default: .false.]</em>
                       </TD></TR>

<TR><!--contents--><TD valign=top>debug</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The switch to specify the run-time verbosity.
                       <em class=code>0</em> is as quiet as it gets.
                       <em class=code>&gt; 1</em> provides more run-time messages.
                       <em class=code>&gt; 5</em> provides ALL run-time messages.
                       All values above 0 will also write a netCDF file of the grid
                       information and perform a grid interpolation test.
                       <em class=units>[default: 0]</em></TD></TR>

<TR><!--contents--><TD valign=top>noah_state_variables   </TD>
    <!--  type  --><TD valign=top>character(len=32)::<br />
                              dimension(2,40)   </TD>
    <!--descript--><TD>The list of variable names in the NOAH restart file to use to
                       create the DART state vector and their corresponding DART kind.
                       <em class=units>[default: see example below]</em>
                       </TD></TR>

</TABLE>
</div>

<H3 class=indent1>Example</H3>

<div>
<pre>
&amp;model_nml
   noah_netcdf_file             = 'restart.nc',
   assimilation_period_days     = 0,
   assimilation_period_seconds  = 3600,
   model_perturbation_amplitude = 0.0,
   output_state_vector          = .false.,
   debug                        = 0,
   noah_state_variables         = 'SOIL_T',   'KIND_SOIL_TEMPERATURE',
                                  'SOIL_M',   'KIND_SOIL_MOISTURE',
                                  'SOIL_W',   'KIND_SOIL_LIQUID_WATER',
                                  'SKINTEMP', 'KIND_SKIN_TEMPERATURE',
                                  'SNODEP',   'KIND_SNOW_THICKNESS',
                                  'WEASD',    'KIND_SNOW_WATER',
                                  'CANWAT',   'KIND_CANOPY_WATER',
                                  'QFX',      'KIND_LATENT_HEAT_FLUX',
                                  'HFX',      'KIND_SENSIBLE_HEAT_FLUX',
                                  'GRDFLX',   'KIND_GROUND_HEAT_FLUX'
   /
</pre>

<P>The second column of <em class=code>noah_state_variables</em> needs some explanation.
The DART 'KIND's match what the <em class=program>model_mod</em> knows
how to interpolate, so you can't just add a new kind and expect it to work.
There is a complex interplay between 
<a href="../../obs_def/obs_def_mod.html">obs_def_mod</a>,
<a href="../../preprocess/preprocess.html">preprocess</a>, and
<a href="model_mod.html">model_mod</a> that defines what KINDs are supported.
There is only a single KIND that works with each variable and the example shows
the current KINDs. Support for these KINDs was provided by running 
<em class=program>preprocess</em> with the following namelist settings:</P>

<pre>
&amp;preprocess_nml
    input_obs_kind_mod_file = '../../../obs_kind/DEFAULT_obs_kind_mod.F90',
   output_obs_kind_mod_file = '../../../obs_kind/obs_kind_mod.f90',
     input_obs_def_mod_file = '../../../obs_def/DEFAULT_obs_def_mod.F90',
    output_obs_def_mod_file = '../../../obs_def/obs_def_mod.f90',
   input_files              = '../../../obs_def/obs_def_tower_mod.f90'
  /
</pre>

</div>
<br />

<!--==================================================================-->

<A NAME="namelist.hrldas"></A>
<br />
<H2>NOAHLSM_OFFLINE NAMELIST</H2>
<div class=namelist><pre>
<em class=call>namelist /NOAHLSM_OFFLINE/ </em>  hrldas_constants_file, &amp;
     indir, outdir,  &amp;
     restart_filename_requested, &amp;
     khour,  kday, &amp;
     forcing_timestep, &amp;
     noah_timestep,  &amp;
     output_timestep, &amp;
     restart_frequency_hours, &amp;
     split_output_count, &amp;
     nsoil, &amp;
     zsoil

<div style="color: blue">
     The remaining variables are not used by DART - but are used by NOAH.
     Since DART verifies namelist accuracy, any namelist entry in
     <em class=code>NOAHLSM_OFFLINE</em> that is not in the following list
     will cause a FATAL DART ERROR.</div>

     zlvl, zlvl_wind, iz0tlnd, sfcdif_option, update_snow_from_forcing,
     start_year, start_month, start_day, start_hour, start_min,
     external_fpar_filename_template, external_lai_filename_template,
     subwindow_xstart, subwindow_xend, subwindow_ystart, subwindow_yend
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   This namelist is read from a file called <em class=file>namelist.hrldas</em>&nbsp;.
   This namelist is the same one that is used by NOAH.
   The values are explained in full in the NOAH documentation.
   Only the namelist variables of interest to DART are discussed. All
   other namelist variables are ignored by DART - but mean something to NOAH.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>hrldas_constants_file</TD>
    <!--  type  --><TD valign=top>character(len=256)</TD>
    <!--descript--><TD valign=top>The name of the netCDF file containing the grid information.
                   <em class=units>[default: 'wrfinput']</em></TD></TR>

<TR><!--contents--><TD valign=top>indir</TD>
    <!--  type  --><TD valign=top>character(len=256)</TD>
    <!--descript--><TD valign=top>The DART/NOAH environment requires all the input files
                                  to be in the current working directory.
                   <em class=units>[default: '.']</em></TD></TR>

<TR><!--contents--><TD valign=top>outdir</TD>
    <!--  type  --><TD valign=top>character(len=256)</TD>
    <!--descript--><TD valign=top>The DART/NOAH environment requires all output files
                                  are in the current working directory.
                   <em class=units>[default: '.']</em></TD></TR>

<TR><!--contents--><TD valign=top>restart_filename_requested</TD>
    <!--  type  --><TD valign=top>character(len=256)</TD>
    <!--descript--><TD valign=top>The name of the file containing the grid information.
                                  The default value is implicitly used by the scripting
				  examples. Change at your own risk.
                   <em class=units>[default: 'restart.nc']</em></TD></TR>

<TR><!--contents--><TD valign=top>khour</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The duration (in hours) of the model integration.
				  <em class=units>[default: 1]</em></TD></TR>

<TR><!--contents--><TD valign=top>kday</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The duration (in days) of the model integration.
				  <em class=units>[default: 0]</em></TD></TR>

<TR><!--contents--><TD valign=top>forcing_timestep</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The timestep (in seconds) of the atmospheric forcing.
				  <em class=units>[default: 3600]</em></TD></TR>

<TR><!--contents--><TD valign=top>noah_timestep</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The internal (dynamical) timestep (in seconds).
				  <em class=units>[default: 3600]</em></TD></TR>

<TR><!--contents--><TD valign=top>output_timestep</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The output interval (in seconds).
				  <em class=units>[default: 3600]</em></TD></TR>

<TR><!--contents--><TD valign=top>restart_frequency_hours</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>How often the NOAH restart files get written.
				  <em class=units>[default: 1]</em></TD></TR>

<TR><!--contents--><TD valign=top>split_output_count</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>should be 1 or bad things happen.
				  <em class=units>[default: 1]</em></TD></TR>

<TR><!--contents--><TD valign=top>nsoil</TD>
    <!--  type  --><TD valign=top>integer</TD>
    <!--descript--><TD valign=top>The number of soil interfaces. As I understand it,
                                  NOAH requires this to be 4.
				  <em class=units>[default: 4]</em></TD></TR>


<TR><!--contents--><TD valign=top>zsoil</TD>
    <!--  type  --><TD valign=top>integer(NSOLDX)</TD>
    <!--descript--><TD valign=top>The depth (in meters) of the soil interfaces.
				  <em class=units>[default: -0.1, -0.4, -1.0, -2.04]</em></TD></TR>
</TABLE>
</div>

<H3 class=indent1>Example</H3>
<P>Note: the <em class=code>FORCING_FILE_DIRECTORY</em> line is not required by NOAH but
IS required by DART - specifically in the <em class=program>advance_model.csh</em> script.
</P>
<pre><div style="color: green">
### THIS IS FOR DART ###
FORCING_FILE_DIRECTORY = "/path/to/your/forcing/files"</div>
&amp;NOAHLSM_OFFLINE

   HRLDAS_CONSTANTS_FILE = "wrfinput"
   INDIR  = "."
   OUTDIR = "."

   RESTART_FILENAME_REQUESTED = "restart.nc"

   KHOUR                   = 1
   FORCING_TIMESTEP        = 3600
   NOAH_TIMESTEP           = 3600
   OUTPUT_TIMESTEP         = 3600
   RESTART_FREQUENCY_HOURS = 1
   SPLIT_OUTPUT_COUNT      = 1

   NSOIL=4
   ZSOIL(1) = -0.10
   ZSOIL(2) = -0.40
   ZSOIL(3) = -1.00
   ZSOIL(4) = -2.00

   /
</pre>
</div>
<P></P>

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>

<PRE>
types_mod
time_manager_mod
threed_sphere/location_mod
utilities_mod
obs_kind_mod
mpi_utilities_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!-- Note to authors. The first row of the table is different.        -->
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<P>
Only the public interfaces used are discussed here.
</P>

<h3 class=indent1>Required Interface Routines</h3>
<TABLE width=90%>
<TR><TD><em class=call>use model_mod,&nbsp;only&nbsp;:</em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<h3 class=indent1>Additional Interface Routines</h3>
<TABLE width=90%>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#noah_to_dart_vector">noah_to_dart_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dart_vector_to_model_file">dart_vector_to_model_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_noah_restart_filename">get_noah_restart_filename</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_noah_timestepping">get_noah_timestepping</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_debug_level">get_debug_level</A></TD></TR>
</TABLE>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--==================================================================-->
<H3 class=indent1>Required Interface Routines</H3>
<!--==================================================================-->

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br />
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
Required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br />
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>adv_1step</em>
is not used for the NOAH model.
Advancing the model is done through the <em class=program>advance_model</em> script.
This is a NULL_INTERFACE, provided only for compatibility with the DART requirements.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time   </em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br />
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location
                          <em class=optionalcode>[, var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_state_meta_data</em>
returns metadata about a given element of the DART representation of the
model state vector. Since the DART model state vector is a 1D array and the
native model grid is multidimensional, <em class=code>get_state_meta_data</em>
returns information about the native model state vector representation. Things
like the <em class=code>location</em>, or the type of the variable
(for instance: salinity, temperature, u current component, ...).
The integer values used to indicate different variable types in
<em class=code>var_type</em> are themselves defined as public interfaces
to model_mod if required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in   </em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns the 3D location of the indexed state variable.
        The <em class=code>location_ type</em> comes from
        <em class=file>DART/location/threed_sphere/location_mod.f90</em>.
        Note that the lat/lon are specified in degrees by the user but are converted
        to radians internally.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the KIND of the indexed state variable as an optional argument.
        The kind is one of the list of supported observation kinds, found in
        the block of code starting
        <em class=code>! Integer definitions for DART TYPES</em>
        in <em class=file>DART/obs_kind/obs_kind_mod.f90</em>. To clarify between DART
        'KIND's and 'TYPE's ... a KIND is a more generic reference (i.e. KIND_TEMPERATURE)
        as opposed to the more specific TYPE (i.e. RADIOSONDE_TEMPERATURE).
        </TD></TR>

</TABLE>

<P>
The list of supported variables in <em class=file>DART/obs_kind/obs_kind_mod.f90</em>
is created by <em class=program>preprocess</em> using the entries in
<em class=file>input.nml</em>[<em class=code>&amp;preprocess_nml, &amp;obs_kind_nml</em>],
<em class=file>DEFAULT_obs_kind_mod.F90</em>,
<em class=file>obs_def_tower_mod.f90</em>, and perhaps
<em class=file>obs_def_COSMOS_mod.f90</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br />
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given the DART vector, <em class=code>model_interpolate</em> returns the value of
the desired KIND (i.e. KIND_TEMPERATURE) at the desired location. 
Put another way, <em class=code>model_interpolate</em> applies the observation
operator <strong>H</strong> to the model state to create an 'expected' observation 
at the desired location. Some observation operators are more complicated and are
defined in their own modules - 
<a href="../../obs_def/obs_def_COSMOS_mod.html">obs_def_COSMOS_mod.f90</a>, for example.
If the interpolation is valid, <em class=code>istatus = 0</em>.
Negative values are reserved for the system, any positive value indicates an error.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location   </em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which DART KIND is desired.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.
       <br />success == 0, failure == anything else</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br />
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>get_model_time_step</em>
returns the forecast length to be used as the "model base time step" in the filter.
This is the minimum amount of time the model can be advanced by
<em class=program>filter</em>.
<em class="strong">This is also the assimilation window</em>.
All observations within (+/-) one half of the forecast
length are used for the assimilation.
In the <em class=program>NOAH</em> case, this is set from
the namelist values for <em class=file>input.nml</em> 
<em class=code>&amp;model_nml:assimilation_period_days, assimilation_period_seconds</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var   </em></TD>
    <TD>Smallest time step of model.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br />
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>static_init_model</em>
is called for runtime initialization of the model.
The namelists are read to determine runtime configuration of the model,
the grid coordinates, etc. There are no input arguments and no return values.
The routine sets module-local private attributes that can then be queried by the
public interface routines. In order to initialize the model, DART needs to 
allocate arrays in proportion to the model size. To calculate the model size,
DART queries a NOAH restart file for the variables listed in 
<em class=file>input.nml</em> <em class=code>&amp;model_nml:noah_state_variables</em>. 
The model time is also computed from information in this file.
The grid locations, etc. come from a file specified in the 
<em class=file>namelist.hrldas</em> <em class=code>&amp;NOAHLSM_OFFLINE</em>
namelist in the <em class=code>HRLDAS_CONSTANTS_FILE</em> variable.
<br />
<br />
<strong>Important</strong>: this routine requires:
</P>
<ol><li><em class=file>input.nml</em> <em class=code>&amp;model_mod_nml</em> (and more),
    <li><em class=file>namelist.hrldas</em> <em class=code>&amp;NOAHLSM_OFFLINE</em>, 
    <li> a NOAH restart file (normally <em class=file>restart.nc</em>),  and
    <li> a HRLDAS_CONSTANTS_FILE (normally <em class=file>wrfinput</em>).
</ol>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br />
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>end_model</em>
is used to clean up storage for the model, etc.
when the model is no longer needed. There are no arguments and no return values.
The grid variables are deallocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br />
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_time</em>
returns the time at which the model will start if no input initial conditions are
to be used. This is frequently used to spin-up models from rest, but is not
meaningfully supported for the NOAH model.
The only time this routine would get called is if the
<em class=file>input.nml</em> 
<em class=code>&amp;perfect_model_obs_nml:start_from_restart</em> is .false., which is
not supported in the NOAH model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time   </em></TD>
    <TD>the starting time for the model if no initial conditions are to be supplied.
    This is hardwired to be identical to valid time of the model state in the NOAH
    restart file specified in <em class=code>noah_netcdf_filename</em>.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br />
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>init_conditions</em>
returns default initial conditions for the model; generally used for spinning up
initial model states. For the NOAH model it is just a stub because
the initial state is always provided by the input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x   </em></TD>
    <TD>Initial conditions for state vector.
    This is hardwired to 0.0</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_atts</em>
writes model-specific attributes to an opened netCDF file.
In the NOAH case, this includes information like the
coordinate variables (the grid arrays: <em class=code>XLONG, XLAT,</em> and 
<em class=code>soil_layers_stag</em>),
information from some of the namelists, and the attributes for either the 1D state
vector or the prognostic variables (those listed in <em class=code>noah_state_variables</em>).
All the required information (except for the netCDF file identifier)
is obtained from the scope of the <em class=program>model_mod</em> module.
Both the <em class=file>input.nml</em> and <em class=file>namelist.hrldas</em> files
are preserved in the netCDF file as variables <em class=code>inputnml</em> and
<em class=code>namelist.hrldas</em>, respectively.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID   </em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

<P>
<em class=code>nc_write_model_atts</em>
is responsible for the model-specific attributes in the following DART-output netCDF files:
<em class=file>True_State.nc</em>,
<em class=file>Prior_Diag.nc</em>, and
<em class=file>Posterior_Diag.nc</em>.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br />
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
integer                            :: <em class=code>ierr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>nc_write_model_vars</em>
writes a copy of the state variables to a NetCDF file. Multiple copies of the
state for a given time are supported, allowing, for instance, a single file to
include multiple ensemble estimates of the state. Whether the state vector is
parsed into prognostic variables (i.e. those listed in <em class=code>noah_state_variables</em>) 
or simply written as a 1D array is controlled by
<em class=file>input.nml</em>&nbsp;<em class=code>&amp;model_mod_nml:output_state_vector</em>.
If <em class=code>output_state_vector&nbsp;=&nbsp;.true.</em> the state vector is
written as a 1D array (the simplest case, but hard to explore with the diagnostics).
If <em class=code>output_state_vector&nbsp;=&nbsp;.false.</em> the state vector is
parsed into prognostic variables before being written.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex   </em></TD>
    <TD>Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br />
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1> <!-- Description -->
<P>
<em class=code>pert_model_state</em> cannot be used with NOAH.
The intent is to to generate ensemble initial conditions
around some control trajectory state when one is preparing to spin-up 
an ensemble. However, simply adding gaussian noise about a central
value does not result in states that NOAH can advance. Consequently,
you are responsible for providing a complete initial ensemble.

<!-- This is done by setting:<br />
<em class=code>&amp;filter_nml:start_from_restart = .false.</em><br />
<em class=code>&amp;ensemble_manager_nml:single_restart_file_in = .true.</em>
<br />
<br />
The magnitude of the perturbation is wholly determined by
<a href="#model_perturbation_amplitude">model_perturbation_amplitude</a>.
<br />
<br / -->
A more robust perturbation mechanism is needed.
Until then, you may avoid this routine by using your own ensemble of initial conditions.
This is done by setting:
<em class=code>&amp;filter_nml:start_from_restart&nbsp;=&nbsp;.true.</em>
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>The perturbed state vector.</TD></TR>

<TR><TD valign=top><em class=code>interf_provided   </em></TD>
    <TD>Because of the 'wet/dry' issue discussed above, this is always
        <em class=code>.true.</em>, indicating a model-specific perturbation
        is available.</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type),                intent(inout) :: <em class=code>gc</em>
integer,                             intent(in)    :: <em class=code>num</em>
type(location_type), dimension(num), intent(in)    :: <em class=code>obs</em>
</pre>
</div>

<!-- FIXME - NANCY - do you agree with dimension(num) -->

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br />
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, obs, obs_kind, &amp;<br />
          num_close, close_ind
  <em class=optionalcode>[, dist]</em>) </em>
<pre>
type(get_close_type),              intent(in ) :: <em class=code>gc</em>
type(location_type),               intent(in ) :: <em class=code>base_obs_loc</em>
integer,                           intent(in ) :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in ) :: <em class=code>obs</em>
integer,             dimension(:), intent(in ) :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer,             dimension(:), intent(out) :: <em class=code>close_ind</em>
real(r8), optional,  dimension(:), intent(out) :: <em class=optionalcode>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.
</P>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br />
<div class="routine">
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=code>ens_mean_for_model</em>
normally saves a copy of the ensemble mean to module-local storage.
This is a NULL_INTERFACE for the NOAH model. At present there is
no application which requires module-local storage of the ensemble mean.
No storage is allocated.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean</em></TD>
    <TD>State vector containing the ensemble mean.</TD></TR>

</TABLE>

</div>


<div class="top">[<a href="#">top</a>]</div><hr />
<H3 class=indent1>Unique Interface Routines</H3>



<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="noah_to_dart_vector"></A>
<br />
<div class="routine">
<em class=call>call noah_to_dart_vector( filename, state_vector, restart_time )</em>
<pre>
character(len=*), intent(in)  :: <em class=code>filename</em>
real(r8),         intent(out) :: <em class=code>state_vector(:)</em>
type(time_type),  intent(out) :: <em class=code>restart_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=program>noah_to_dart_vector</em> unpacks the specified variables from a NOAH
restart file into a DART state vector. The NOAH variables are those specified by
<em class=code>noah_state_variables</em>.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename</em></TD>
    <TD>The NOAH restart file of interest. In normal DART practice,
    the unique NOAH restart file name has been linked to a static
    <em class=file>restart.nc</em> to ease scripting. This is possible
    since each NOAH model advance takes place in a unique directory.</TD></TR>

<TR><TD valign=top><em class=code>state_vector  </em></TD>
    <TD>The DART state vector from this NOAH state.
        The variable must be allocated before this routine is called.</TD></TR>

<TR><TD valign=top><em class=code>restart_time</em></TD>
    <TD>The VALID TIME of the NOAH restart file.
    <a href="#NOAHtimes">As noted previously</a>, the VALID time of the
    variables in the NOAH restart file must be computed.
    </TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="dart_vector_to_model_file"></A>
<br />
<div class="routine">
<em class=call>call dart_vector_to_model_file(state_vector, filename, dart_time, skip_variables)</em>
<pre>
real(r8),         dimension(:), intent(in) :: <em class=code>state_vector</em>
character(len=*),               intent(in) :: <em class=code>filename</em>
type(time_type),                intent(in) :: <em class=code>dart_time</em>
character(len=*), dimension(:), intent(in) :: <em class=code>skip_variables</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
   <em class=program>dart_vector_to_model_file</em>
    Updates a NOAH netCDF restart file with the assimilated values from DART.
    A list of variables that should NOT be updated in the NOAH restart file
    allows NOAH variables to be part of the DART state (say, for example,
    for the observation operators) without concern that the values in the
    NOAH restart file will change.  Each NOAH variable modified by DART
    will have a netCDF attribute added.  For example:
</P>
<pre>
float SOIL_W(Time, soil_layers_stag, south_north, west_east) ;
         SOIL_W:MemoryOrder = "XYZ" ;
         SOIL_W:description = "-" ;
         SOIL_W:units = "-" ;
         SOIL_W:stagger = "Z" ;
<div style="color: green">         SOIL_W:DART = "variable modified by DART" ;</div>
</pre>


<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state_vector</em></TD>
    <TD>The 1D array to be used by DART.</TD></TR>

<TR><TD valign=top><em class=code>filename</em></TD>
    <TD>The name of the netCDF format NOAH restart file.</TD></TR>

<TR><TD valign=top><em class=code>dart_time</em></TD>
    <TD>ensures that the proper NOAH restart file is being updated.</TD></TR>

<TR><TD valign=top><em class=code>skip_variables  </em></TD>
    <TD>the list of variables that may be in the DART state vector that SHOULD NOT be
    updated in the NOAH restart file. This list is read from the <em class=file>input.nml</em>
    <em class=code>dart_to_noah_nml</em> namelist.</TD></TR>
</TABLE>
</div>

<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_noah_restart_filename"></A>
<br />
<div class="routine">
<em class=call>call get_noah_restart_filename( filename )</em>
<pre>
character(len=*), intent(out) :: <em class=code>filename</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=program>get_noah_restart_filename</em>
allows other programs and modules access to the <em class=code>noah_netcdf_filename</em>.
The scoping rules in <em class=program>model_mod</em> require an interface routine to
access this information.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>filename  </em></TD>
    <TD>the netCDF-format NOAH restart file.
</TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_noah_timestepping"></A>
<br />
<div class="routine">
<em class=call>call get_noah_timestepping( day, hour, dynamical, output, forcing, restart )</em>
<pre>
integer, intent(out) :: <em class=code>day</em>
integer, intent(out) :: <em class=code>hour</em>
integer, intent(out) :: <em class=code>dynamical</em>
integer, intent(out) :: <em class=code>output</em>
integer, intent(out) :: <em class=code>forcing</em>
integer, intent(out) :: <em class=code>restart</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=program>get_noah_timestepping</em> allows other routines
(such as those in <em class=program>dart_to_noah</em>) access to the
NOAH timestepping information from the <em class=file>namelist.hrldas</em>&nbsp;
<em class=code>NOAHLSM_OFFLINE</em> namelist.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>day</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:kday</em></TD></TR>

<TR><TD valign=top><em class=code>hour</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:khour</em></TD></TR>

<TR><TD valign=top><em class=code>dynamical</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:noah_timestep</em></TD></TR>

<TR><TD valign=top><em class=code>output</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:output_timestep</em></TD></TR>

<TR><TD valign=top><em class=code>forcing</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:forcing_timestep</em></TD></TR>

<TR><TD valign=top><em class=code>restart</em></TD>
    <TD>the value of <em class=code>NOAHLSM_OFFLINE:restart_frequency_hours*3600</em></TD></TR>

</TABLE>

</div>
<br />

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_debug_level"></A>
<br />
<div class="routine">
<em class=call>debug = get_debug_level()</em>
<pre>
integer :: <em class=code>debug</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
<em class=program>get_debug_level</em> allows external routines
access to the variable controlling the level of run-time output
specified in <em class=file>input.nml</em> <em class=code>model_nml:debug</em> .
</P>

</div>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>INPUT FILES</H2>

<TABLE border=0 width=100% summary='input files'>
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>namelist.hrldas</TD>
    <TD>to read the NOAHLSM_OFLINE namelist</TD></TR>
<TR><TD>wrfinput</TD>
    <TD>provides NOAH grid information</TD></TR>
<TR><TD><em class=code>&amp;model_nml:noah_netcdf_filename</em></TD>
    <TD>the RESTART file containing the NOAH model state.</TD></TR>
</TABLE>

<H2>OUTPUT FILES</H2>

<TABLE border=0 width=100% summary='output files'>
<TR><TD><em class=code>&amp;model_nml:noah_netcdf_filename</em></TD>
    <TD>the updated RESTART file containing the NOAH model state.</TD></TR>
<TR><TD>True_State.nc</TD>
    <TD>the time-history of the "true" model state from an OSSE</TD></TR>
<TR><TD>Prior_Diag.nc</TD>
    <TD>the time-history of the model state(s) before assimilation</TD></TR>
<TR><TD>Posterior_Diag.nc </TD>
    <TD>the time-history of the model state(s) after assimilation</TD></TR>
<TR><TD>dart_log.out [default name]</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml [default name]</TD>
    <TD>the record of all the namelists actually USED -
        contains the default values</TD></TR>
</TABLE>


<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ul>
<li> none </li>
</ul>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH width="50%">Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>static_init_model</TD>
    <!-- message --><TD VALIGN=top>Expected ## soil layers ...</TD>
    <!-- comment --><TD VALIGN=top>We read the <em class=code>model_nml</em> namelist for
    the name of the NOAH restart file. NOAH restart files (at present) do not actually
    have the depths of the soil interfaces recorded in them - they come from the
    <em class=code>NOAHLSM_OFFLINE</em> namelist.
    <em class=program>static_init_model</em> checks to make sure the namelist and the
    restart file are compatible.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>model_interpolate</TD>
    <!-- message --><TD VALIGN=top>unable to find state vector component
    matching type 'xxxx'</TD>
    <!-- comment --><TD VALIGN=top>The observation operator requires a certain
    model state variable but it is not part of the model state.</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>get_state_meta_data</TD>
    <!-- message --><TD VALIGN=top>PROBLEM: not set up for a case with multiple
    locations yet.</TD>
    <!-- comment --><TD VALIGN=top>This is on my short list for future work.</TD>
</TR>

</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
This is not really a bug, but it is a nuisance.
DART requires that the number of MPI tasks cannot exceed the state vector length.
In a single-column configuration, the DART state vector is simply not very long.
My initial throught was to run with 40 MPI tasks for a 40 member ensemble ... this
cannot work because the dimension of the model is less than 40! With
<em class=code>SOIL_T, SOIL_M, SOIL_W, SKINTEMP, SNODEP, WEASD, CANWAT, QFX, HFX,</em>
and <em class=code>GRDFLX</em> the DART state vector is still only 19 elements long
(for a 4-layer run).
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS - in no particular order.</H2>
<P>Support multiple grid cells. Current implementation only allows for
a single gridcell.
<br />
<br />
Ensure the model_time_step is a multiple of OUTPUT_TIMESTEP.
<br />
<br />
More Error-checking for shapes, dimension orders, etc.
<br />
<br />
Provide a better mechanism for generating a set of perturbed initial
conditions - <em class=code>pert_model_state()</em>
<br />
<br />
Use the <em class=file>namelist.hrldas</em> 
<em class=code>&amp;NOAHLSM_OFFLINE:RESTART_FILENAME_REQUESTED</em>
variable and remove <em class=code>&amp;model_nml:noah_netcdf_filename</em>
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br />
This open source software is provided by UCAR, "as is",<br />
without charge, subject to all terms of use at<br />
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change history: </TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
